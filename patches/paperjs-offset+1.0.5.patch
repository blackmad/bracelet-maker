diff --git a/node_modules/paperjs-offset/README.md b/node_modules/paperjs-offset/README.md
index 5fd76b9..e8a960d 100644
--- a/node_modules/paperjs-offset/README.md
+++ b/node_modules/paperjs-offset/README.md
@@ -1,6 +1,5 @@
 # Paperjs Offset
 The dicussion to implement a offset function in paper.js started years ago, yet the author have not decided to put a offset feature into the library. So I implement an extension of my own.
-<br/>As far as I know, the author has promised recently to implement a native offset functionality in near feature, the library will be closed once the native implement is published.
 <br/>This library implement both path offset and stroke offset, you may offset a path or expand a stroke like what you did in Adobe illustrator. Offset complicate path may cause unwanted self intersections, this library already take care some cases but bugs still exists. Please let me notice the false conditions in the issue pannel so I can correct it.
 
 ## Usage
@@ -11,62 +10,34 @@ npm install paperjs-offset
 And then, in you project:
 ```javascript
 import paper from 'paper'
-import { PaperOffset } from 'paperjs-offset'
-
-// call offset
-PaperOffset.offset(path, offset, options)
-
-// call offset stroke
-PaperOffset.offsetStroke(path, offset, options)
-```
-
-You may still use the old way to extend paperjs module, which is **deprecated** and will be removed in future version.
-```typescript
 import ExtendPaperJs from 'paperjs-offset'
-// extend paper.Path, paper.CompoundPath with offset, offsetStroke method
-ExtendPaperJs(paper);
 
-// Warning: The library no longer include extended definitions for paper.Path & paper.CompoundPath, you may need your own declarations to use extension in typescript.
-(path as any).offset(10);
+ExtendPaperJs(paper)
 ```
-
 Or for web development, include the **paperjs-offset.js** or **paperjs-offset.min.js** in demo folder.
-<br/>The library now exposes a global variable **PaperOffset**, again, the extension of **paper.Path** and **paper.CompoundPath** with offset/offsetStroke functions is still available, but no longer recommended.
+<br/>The library extends **paper.Path** and **paper.CompoundPath** object, with offset/offsetStroke functions.
 ```javascript
 let path = new paper.Path(/* params */)
-
-PaperOffset.offset(path, 10, { join: 'round' })
-PaperOffset.offsetStroke(path, 10, { cap: 'round' })
-
-// deprecated
 path.offset(10, { join: 'round' })
-// deprecated
 path.offsetStroke(10, { cap: 'round' })
 ```
-
-Sample references:
-```typescript
-offset(path: paper.Path | paper.CompoundPath, offset: number, options?: OffsetOptions): paper.Path | paper.CompoundPath
-
-offsetStroke(path: paper.Path | paper.CompoundPath, offset: number, options?: OffsetOptions): paper.Path | paper.CompoundPath
-
-interface OffsetOptions {
-  // the join style of offset path, default is 'miter'
-  join?: 'miter' | 'bevel' | 'round';
-  // the cap style of offset (only validate for offsetStroke), default is 'butt', ('square' will be supported in future)
-  cap?: 'butt' | 'round';
-  // the limit for miter style (refer to the miterLimit definition in paper)
-  limit?: number;
-  // whether the result should be insert into the canvas, default is true
-  insert?: boolean;
-}
-```
+Both offset/offsetStroke take the form of **f(offset: number, options?: {})**, the options have following parameters:
+<br/>&nbsp;&nbsp;**join**: the join style of offset path, you can choose **'miter'**, **'bevel'** or **'round'**, default is **'miter'**.
+<br/>&nbsp;&nbsp;**limit**: the limit for miter style (refer the miterLimit's definition in paper.js).
+<br/>&nbsp;&nbsp;**cap**: the cap style of offset (only available in offsetStroke), you can choose **'butt'** and **'round'** (**'square'** is not supported yet), default is **'butt'**
+<br/>&nbsp;&nbsp;**insert**: whether the result should be insert into the canvas, default is **true**.
 
 ## Preview
 There are some cases that the library may return weird result or failed silently, please let me noticed in the project issues. And in some cases the library will yeild an ok result than a perfect one. Currently the library should give good results for closed shapes, but may fail in some open curve cases, I'm still working on it.
 ![Preview](/public/preview.jpg)
 
+## Development
+```sh
+# build es5/umd/iife packages
+npm run build
+```
 You can use open demo folder for simple cases demonstration.
+<br/>*I've noticed there is a react adaption of paper.js but no vue adaption, so I create a vue adaption of paper.js, you can visit this [repo](https://github.com/luz-alphacode/paper-vueify) if you are interested.*
 
 ## License
-Distributed under the MIT license. See [LICENSE](https://github.com/glenzli/paperjs-offset/blob/master/LICENSE) for detail.
\ No newline at end of file
+Distributed under the MIT license. See [LICENSE](https://github.com/luz-alphacode/paperjs-offset/blob/master/LICENSE) for detail.
\ No newline at end of file
diff --git a/node_modules/paperjs-offset/build.js b/node_modules/paperjs-offset/build.js
index 4588637..6384aaf 100644
--- a/node_modules/paperjs-offset/build.js
+++ b/node_modules/paperjs-offset/build.js
@@ -22,7 +22,7 @@ let tasks = []
 
 tasks.push(rollup.rollup({
   input: 'src/index.ts',
-  external: ['paper'],
+  external: ['arrayex', 'paper'],
   plugins: defaultPlugins
 }).then(bundle => {
   bundle.write({ format: 'umd', file: pkg.main, name: camelCase(libraryName), sourcemap: true })
diff --git a/node_modules/paperjs-offset/demo/debug.html b/node_modules/paperjs-offset/demo/debug.html
deleted file mode 100644
index 49c34b8..0000000
--- a/node_modules/paperjs-offset/demo/debug.html
+++ /dev/null
@@ -1,12 +0,0 @@
-<html>
-  <head>
-    <title>Demo</title>
-    <link rel="stylesheet" href="./demo.css"/>
-    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/paper@0.12.4/dist/paper-full.min.js"></script>
-    <script type="text/javascript" src="./paperjs-offset.js"></script>
-    <script type="text/javascript" src="./debug.js"></script>
-  </head>
-  <body>
-    <canvas width="1200" height="768"></canvas>
-  </body>
-</html>
\ No newline at end of file
diff --git a/node_modules/paperjs-offset/demo/debug.js b/node_modules/paperjs-offset/demo/debug.js
deleted file mode 100644
index 4026928..0000000
--- a/node_modules/paperjs-offset/demo/debug.js
+++ /dev/null
@@ -1,26 +0,0 @@
-(function() {
-  function DebugCase() {
-    let canvas = document.querySelector('canvas');
-    paper.setup(canvas);
-    paper.view.center = [0, 0];
-
-    const c3 = new paper.Path.Circle({ center: [180, 260], radius: 50, strokeColor: 'black' });
-    const c4 = new paper.Path.Circle({ center: [230, 260], radius: 40, strokeColor: 'black' });
-    const c5 = new paper.Path.Circle({ center: [205, 200], radius: 40, strokeColor: 'black' });
-    const cc1 = c3.unite(c4, { insert: true });
-    const cc = cc1.unite(c5, { insert: true });
-    c3.remove();
-    c4.remove();
-    c5.remove();
-    cc1.remove();
-    cc.bringToFront();
-    cc.translate(new paper.Point(-100, -100));
-
-    PaperOffset.offset(cc, 24);
-
-    const c = new paper.Path({pathData: "M4,11L5,13", strokeColor: 'rgba(156, 104, 193, 0.5)', strokeWidth: 4});
-    PaperOffset.offsetStroke(c, 10, {cap: "round", join: "round"});
-  }
-
-  window.onload = DebugCase;
-})();
\ No newline at end of file
diff --git a/node_modules/paperjs-offset/demo/demo.js b/node_modules/paperjs-offset/demo/demo.js
index e5d8e8a..a5a4ef9 100644
--- a/node_modules/paperjs-offset/demo/demo.js
+++ b/node_modules/paperjs-offset/demo/demo.js
@@ -6,38 +6,38 @@
 
     // simple polygon
     let r = new paper.Path.Rectangle({ point: [-500, -300], size: [80, 80], fillColor: 'rgb(191, 91, 91, 0.5)', strokeColor: 'black' })
-    PaperOffset.offset(r, 10)
+    r.offset(10)
     r.bringToFront()
-    PaperOffset.offset(PaperOffset.offset(PaperOffset.offset(r, -10), -10), -10);
+    r.offset(-10).offset(-10).offset(-10)
 
     // simple polygon + bevel
     let r11 = new paper.Path.Rectangle({ point: [-500, -150], size: [60, 60], fillColor: 'rgb(191, 91, 91, 0.5)', strokeColor: 'black' })
-    let r12 = PaperOffset.offset(r11, -10, { insert: false })
+    let r12 = r11.offset(-10, { insert: false })
     let r1 = r11.subtract(r12, { insert: true })
     r11.remove()
-    PaperOffset.offset(r1, 15, { join: 'bevel' })
+    r1.offset(15, { join: 'bevel' })
     r1.bringToFront()
 
     // simple polygon + round
     let r21 = new paper.Path.Rectangle({ point: [-350, -150], size: [60, 60], fillColor: 'rgb(191, 91, 91, 0.5)', strokeColor: 'black' })
-    let r22 = PaperOffset.offset(r21, -10, { insert: false })
+    let r22 = r21.offset(-10, { insert: false })
     let r2 = r21.subtract(r22, { insert: true })
     r21.remove()
-    PaperOffset.offset(r2, 15, { join: 'round' })
+    r2.offset(15, { join: 'round' })
     r2.bringToFront()
 
     // simple polygon
     let s = new paper.Path.Star({ center: [-300, -260], points: 12, radius1: 40, radius2: 30, fillColor: 'rgba(234, 154, 100, 0.5)', strokeColor: 'black' })
-    PaperOffset.offset(s, 10)
+    s.offset(10)
     s.bringToFront()
-    PaperOffset.offset(PaperOffset.offset(s, -10), -10);
+    s.offset(-10).offset(-10)
 
     // smooth
     let s2 = new paper.Path.Star({ center: [-150, -260], points: 7, radius1: 40, radius2: 30, fillColor: 'rgba(239, 209, 88, 0.5)', strokeColor: 'black' })
     s2.smooth()
-    PaperOffset.offset(s2, 10);
+    s2.offset(10)
     s2.bringToFront()
-    PaperOffset.offset(PaperOffset.offset(s2, -10), -10)
+    s2.offset(-10).offset(-10)
 
     // complex
     let c1 = new paper.Path.Circle({ center: [-20, -260], radius: 40, fillColor: 'rgba(165, 193, 93, 0.5)', strokeColor: 'black' })
@@ -45,9 +45,9 @@
     let c = c1.unite(c2, { insert: true })
     c1.remove()
     c2.remove()
-    PaperOffset.offset(c, 10);
+    c.offset(10)
     c.bringToFront()
-    PaperOffset.offset(PaperOffset.offset(PaperOffset.offset(c, -10), -10), -10)
+    c.offset(-10).offset(-10).offset(-10)
 
     let c3 = new paper.Path.Circle({ center: [180, -260], radius: 40, fillColor: 'rgba(117, 170, 173, 0.5)', strokeColor: 'black' })
     let c4 = new paper.Path.Circle({ center: [230, -260], radius: 40, fillColor: 'rgba(117, 170, 173, 0.5)', strokeColor: 'black' })
@@ -58,9 +58,9 @@
     c4.remove()
     c5.remove()
     cc1.remove()
-    PaperOffset.offset(cc, 10)
+    cc.offset(10)
     cc.bringToFront()
-    PaperOffset.offset(PaperOffset.offset(PaperOffset.offset(PaperOffset.offset(cc, -10), -10), -10), -5)
+    cc.offset(-10).offset(-10).offset(-10).offset(-5)
 
     // complex+
     let c6 = new paper.Path.Circle({ center: [380, -260], radius: 40, fillColor: 'rgba(156, 104, 193, 0.5)', strokeColor: 'black' })
@@ -75,17 +75,17 @@
     ccc.smooth()
     ccc.offset(10)
     ccc.bringToFront()
-    PaperOffset.offset(PaperOffset.offset(ccc, -10), -10)
-    PaperOffset.offset(PaperOffset.offset(ccc, -30), -5)
+    ccc.offset(-10).offset(-10)
+    ccc.offset(-30).offset(-5)
 
     // stroke
     let rs = new paper.Path.Rectangle({ point: [-200, -150], size: [80, 80], fillColor: null, strokeColor: 'rgb(191, 91, 91, 0.5)' })
-    PaperOffset.offsetStroke(rs, 10)
+    rs.offsetStroke(10)
     rs.bringToFront()
 
     // stroke
     let st1 = new paper.Path.Line({ from: [-50, -100], to: [0, -100], strokeColor: 'rgba(156, 104, 193, 0.5)', strokeWidth: 3 })
-    PaperOffset.offsetStroke(st1, 20, { cap: 'round' })
+    st1.offsetStroke(20, { cap: 'round' })
     st1.bringToFront()
 
     // stroke complex
@@ -95,31 +95,30 @@
     cs.fillColor = null
     cs.position = [150, -50]
     cs.closed = false
-    PaperOffset.offsetStroke(cs, 20)
+    cs.offsetStroke(20)
     cs.bringToFront()
     let cs2 = cs.clone()
     cs2.position = [400, -50]
     cs2.strokeColor = 'rgba(117, 170, 173, 0.5)'
-    PaperOffset.offsetStroke(cs2, 25, { cap: 'round' })
+    cs2.offsetStroke(25, { cap: 'round' })
     cs2.bringToFront()
 
     // edge cases
     let ec1 = new paper.Path({ pathData: 'M466,467c0,0 -105,-235 0,0c-376.816,-119.63846 -469.06596,-146.09389 -650.61329,-266.59735c-282.68388,-230.49081 300.86045,-10.26825 452.77726,121.52815z', fillColor: 'rgba(156, 104, 193, 0.5)' })
     ec1.translate(-450, -250)
     ec1.scale(0.4)
-    PaperOffset.offset(ec1, 10)
-    PaperOffset.offset(PaperOffset.offset(PaperOffset.offset(ec1, -10), -10), -10)
+    ec1.offset(10)
+    ec1.offset(-10).offset(-10).offset(-10)
 
     let ec2 = new paper.Path({ pathData: 'M466,467c-65,-34 136,64 0,0c-391,-270 62,-670 62,-670l-463,370z', strokeColor: 'rgba(239, 209, 88, 0.5)', strokeWidth: 3 })
     ec2.scale(0.4)
     ec2.translate(-350, 20)
-    PaperOffset.offsetStroke(ec2, 10)
+    ec2.offsetStroke(10)
 
     let ec3 = new paper.Path({ pathData: 'M466,467c-65,-34 136,64 0,0c-391,-270 520,-471 522,-137c-214,-144 -1489,123 -923,-163z', fillColor: 'rgb(191, 91, 91, 0.5)' })
     ec3.scale(0.4)
     ec3.translate(-100, -150)
-    PaperOffset.offset(ec3, -10)
+    ec3.offset(-10)
   }
-
   window.onload = RunDemo
 })()
\ No newline at end of file
diff --git a/node_modules/paperjs-offset/demo/index.html b/node_modules/paperjs-offset/demo/index.html
index 0a2ec01..0ba69a1 100644
--- a/node_modules/paperjs-offset/demo/index.html
+++ b/node_modules/paperjs-offset/demo/index.html
@@ -2,7 +2,7 @@
   <head>
     <title>Demo</title>
     <link rel="stylesheet" href="./demo.css"/>
-    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/paper@0.12.4/dist/paper-full.min.js"></script>
+    <script type="text/javascript" src="https://cdn.bootcss.com/paper.js/0.12.0/paper-core.min.js"></script>
     <script type="text/javascript" src="./paperjs-offset.js"></script>
     <script type="text/javascript" src="./demo.js"></script>
   </head>
diff --git a/node_modules/paperjs-offset/demo/paperjs-offset.js b/node_modules/paperjs-offset/demo/paperjs-offset.js
index 0f1c3e7..b164b94 100644
--- a/node_modules/paperjs-offset/demo/paperjs-offset.js
+++ b/node_modules/paperjs-offset/demo/paperjs-offset.js
@@ -1,410 +1,656 @@
 (function (paper) {
-  'use strict';
+    'use strict';
 
-  paper = paper && Object.prototype.hasOwnProperty.call(paper, 'default') ? paper['default'] : paper;
+    paper = paper && paper.hasOwnProperty('default') ? paper['default'] : paper;
 
-  /**
-   * Offset the start/terminal segment of a bezier curve
-   * @param segment segment to offset
-   * @param curve curve to offset
-   * @param handleNormal the normal of the the line formed of two handles
-   * @param offset offset value
-   */
-  function offsetSegment(segment, curve, handleNormal, offset) {
-      var isFirst = segment.curve === curve;
-      // get offset vector
-      var offsetVector = (curve.getNormalAtTime(isFirst ? 0 : 1)).multiply(offset);
-      // get offset point
-      var point = segment.point.add(offsetVector);
-      var newSegment = new paper.Segment(point);
-      // handleOut for start segment & handleIn for terminal segment
-      var handle = (isFirst ? 'handleOut' : 'handleIn');
-      newSegment[handle] = segment[handle].add(handleNormal.subtract(offsetVector).divide(2));
-      return newSegment;
-  }
-  /**
-   * Adaptive offset a curve by repeatly apply the approximation proposed by Tiller and Hanson.
-   * @param curve curve to offset
-   * @param offset offset value
-   */
-  function adaptiveOffsetCurve(curve, offset) {
-      var hNormal = (new paper.Curve(curve.segment1.handleOut.add(curve.segment1.point), new paper.Point(0, 0), new paper.Point(0, 0), curve.segment2.handleIn.add(curve.segment2.point))).getNormalAtTime(0.5).multiply(offset);
-      var segment1 = offsetSegment(curve.segment1, curve, hNormal, offset);
-      var segment2 = offsetSegment(curve.segment2, curve, hNormal, offset);
-      // divide && re-offset
-      var offsetCurve = new paper.Curve(segment1, segment2);
-      // if the offset curve is not self intersected, divide it
-      if (offsetCurve.getIntersections(offsetCurve).length === 0) {
-          var threshold = Math.min(Math.abs(offset) / 10, 1);
-          var midOffset = offsetCurve.getPointAtTime(0.5).getDistance(curve.getPointAtTime(0.5));
-          if (Math.abs(midOffset - Math.abs(offset)) > threshold) {
-              var subCurve = curve.divideAtTime(0.5);
-              if (subCurve != null) {
-                  return adaptiveOffsetCurve(curve, offset).concat(adaptiveOffsetCurve(subCurve, offset));
-              }
-          }
-      }
-      return [segment1, segment2];
-  }
-  /**
-   * Create a round join segment between two adjacent segments.
-   */
-  function makeRoundJoin(segment1, segment2, originPoint, radius) {
-      var through = segment1.point.subtract(originPoint).add(segment2.point.subtract(originPoint))
-          .normalize(Math.abs(radius)).add(originPoint);
-      var arc = new paper.Path.Arc({ from: segment1.point, to: segment2.point, through: through, insert: false });
-      segment1.handleOut = arc.firstSegment.handleOut;
-      segment2.handleIn = arc.lastSegment.handleIn;
-      return arc.segments.length === 3 ? arc.segments[1] : null;
-  }
-  function det(p1, p2) {
-      return p1.x * p2.y - p1.y * p2.x;
-  }
-  /**
-   * Get the intersection point of point based lines
-   */
-  function getPointLineIntersections(p1, p2, p3, p4) {
-      var l1 = p1.subtract(p2);
-      var l2 = p3.subtract(p4);
-      var dl1 = det(p1, p2);
-      var dl2 = det(p3, p4);
-      return new paper.Point(dl1 * l2.x - l1.x * dl2, dl1 * l2.y - l1.y * dl2).divide(det(l1, l2));
-  }
-  /**
-   * Connect two adjacent bezier curve, each curve is represented by two segments,
-   * create different types of joins or simply removal redundant segment.
-   */
-  function connectAdjacentBezier(segments1, segments2, origin, joinType, offset, limit) {
-      var curve1 = new paper.Curve(segments1[0], segments1[1]);
-      var curve2 = new paper.Curve(segments2[0], segments2[1]);
-      var intersection = curve1.getIntersections(curve2);
-      var distance = segments1[1].point.getDistance(segments2[0].point);
-      if (origin.isSmooth()) {
-          segments2[0].handleOut = segments2[0].handleOut.project(origin.handleOut);
-          segments2[0].handleIn = segments1[1].handleIn.project(origin.handleIn);
-          segments2[0].point = segments1[1].point.add(segments2[0].point).divide(2);
-          segments1.pop();
-      }
-      else {
-          if (intersection.length === 0) {
-              if (distance > Math.abs(offset) * 0.1) {
-                  // connect
-                  switch (joinType) {
-                      case 'miter':
-                          var join = getPointLineIntersections(curve1.point2, curve1.point2.add(curve1.getTangentAtTime(1)), curve2.point1, curve2.point1.add(curve2.getTangentAtTime(0)));
-                          // prevent sharp angle
-                          var joinOffset = Math.max(join.getDistance(curve1.point2), join.getDistance(curve2.point1));
-                          if (joinOffset < Math.abs(offset) * limit) {
-                              segments1.push(new paper.Segment(join));
-                          }
-                          break;
-                      case 'round':
-                          var mid = makeRoundJoin(segments1[1], segments2[0], origin.point, offset);
-                          if (mid) {
-                              segments1.push(mid);
-                          }
-                          break;
-                  }
-              }
-              else {
-                  segments2[0].handleIn = segments1[1].handleIn;
-                  segments1.pop();
-              }
-          }
-          else {
-              var second1 = curve1.divideAt(intersection[0]);
-              if (second1) {
-                  var join = second1.segment1;
-                  var second2 = curve2.divideAt(curve2.getIntersections(curve1)[0]);
-                  join.handleOut = second2 ? second2.segment1.handleOut : segments2[0].handleOut;
-                  segments1.pop();
-                  segments2[0] = join;
-              }
-              else {
-                  segments2[0].handleIn = segments1[1].handleIn;
-                  segments1.pop();
-              }
-          }
-      }
-  }
-  /**
-   * Connect all the segments together.
-   */
-  function connectBeziers(rawSegments, join, source, offset, limit) {
-      var originSegments = source.segments;
-      var first = rawSegments[0].slice();
-      for (var i = 0; i < rawSegments.length - 1; ++i) {
-          connectAdjacentBezier(rawSegments[i], rawSegments[i + 1], originSegments[i + 1], join, offset, limit);
-      }
-      if (source.closed) {
-          connectAdjacentBezier(rawSegments[rawSegments.length - 1], first, originSegments[0], join, offset, limit);
-          rawSegments[0][0] = first[0];
-      }
-      return rawSegments;
-  }
-  function reduceSingleChildCompoundPath(path) {
-      if (path.children.length === 1) {
-          path = path.children[0];
-          path.remove(); // remove from parent, this is critical, or the style attributes will be ignored
-      }
-      return path;
-  }
-  /** Normalize a path, always clockwise, non-self-intersection, ignore really small components, and no one-component compound path. */
-  function normalize(path, areaThreshold) {
-      if (areaThreshold === void 0) { areaThreshold = 0.01; }
-      if (path.closed) {
-          var ignoreArea_1 = Math.abs(path.area * areaThreshold);
-          if (!path.clockwise) {
-              path.reverse();
-          }
-          path = path.unite(path, { insert: false });
-          if (path instanceof paper.CompoundPath) {
-              path.children.filter(function (c) { return Math.abs(c.area) < ignoreArea_1; }).forEach(function (c) { return c.remove(); });
-              if (path.children.length === 1) {
-                  return reduceSingleChildCompoundPath(path);
-              }
-          }
-      }
-      return path;
-  }
-  function isSameDirection(partialPath, fullPath) {
-      var offset1 = partialPath.segments[0].location.offset;
-      var offset2 = partialPath.segments[Math.max(1, Math.floor(partialPath.segments.length / 2))].location.offset;
-      var sampleOffset = (offset1 + offset2) / 3;
-      var originOffset1 = fullPath.getNearestLocation(partialPath.getPointAt(sampleOffset)).offset;
-      var originOffset2 = fullPath.getNearestLocation(partialPath.getPointAt(2 * sampleOffset)).offset;
-      return originOffset1 < originOffset2;
-  }
-  /** Remove self intersection when offset is negative by point direction dectection. */
-  function removeIntersection(path) {
-      if (path.closed) {
-          var newPath = path.unite(path, { insert: false });
-          if (newPath instanceof paper.CompoundPath) {
-              newPath.children.filter(function (c) {
-                  if (c.segments.length > 1) {
-                      return !isSameDirection(c, path);
-                  }
-                  else {
-                      return true;
-                  }
-              }).forEach(function (c) { return c.remove(); });
-              return reduceSingleChildCompoundPath(newPath);
-          }
-      }
-      return path;
-  }
-  function getSegments(path) {
-      if (path instanceof paper.CompoundPath) {
-          return path.children.map(function (c) { return c.segments; }).flat();
-      }
-      else {
-          return path.segments;
-      }
-  }
-  /**
-   * Remove impossible segments in negative offset condition.
-   */
-  function removeOutsiders(newPath, path) {
-      var segments = getSegments(newPath).slice();
-      segments.forEach(function (segment) {
-          if (!path.contains(segment.point)) {
-              segment.remove();
-          }
-      });
-  }
-  function preparePath(path, offset) {
-      var source = path.clone({ insert: false });
-      source.reduce({});
-      if (!path.clockwise) {
-          source.reverse();
-          offset = -offset;
-      }
-      return [source, offset];
-  }
-  function offsetSimpleShape(path, offset, join, limit) {
-      var _a;
-      var source;
-      _a = preparePath(path, offset), source = _a[0], offset = _a[1];
-      var curves = source.curves.slice();
-      var offsetCurves = curves.map(function (curve) { return adaptiveOffsetCurve(curve, offset); }).flat();
-      var raws = [];
-      for (var i = 0; i < offsetCurves.length; i += 2) {
-          raws.push(offsetCurves.slice(i, i + 2));
-      }
-      var segments = connectBeziers(raws, join, source, offset, limit).flat();
-      var newPath = removeIntersection(new paper.Path({ segments: segments, insert: false, closed: path.closed }));
-      newPath.reduce({});
-      if (source.closed && ((source.clockwise && offset < 0) || (!source.clockwise && offset > 0))) {
-          removeOutsiders(newPath, path);
-      }
-      // recovery path
-      if (source.clockwise !== path.clockwise) {
-          newPath.reverse();
-      }
-      return normalize(newPath);
-  }
-  function makeRoundCap(from, to, offset) {
-      var origin = from.point.add(to.point).divide(2);
-      var normal = to.point.subtract(from.point).rotate(-90, new paper.Point(0, 0)).normalize(offset);
-      var through = origin.add(normal);
-      var arc = new paper.Path.Arc({ from: from.point, to: to.point, through: through, insert: false });
-      return arc.segments;
-  }
-  function connectSide(outer, inner, offset, cap) {
-      if (outer instanceof paper.CompoundPath) {
-          var cs = outer.children.map(function (c) { return ({ c: c, a: Math.abs(c.area) }); });
-          cs = cs.sort(function (c1, c2) { return c2.a - c1.a; });
-          outer = cs[0].c;
-      }
-      var oSegments = outer.segments.slice();
-      var iSegments = inner.segments.slice();
-      switch (cap) {
-          case 'round':
-              var heads = makeRoundCap(iSegments[iSegments.length - 1], oSegments[0], offset);
-              var tails = makeRoundCap(oSegments[oSegments.length - 1], iSegments[0], offset);
-              var result = new paper.Path({ segments: heads.concat(oSegments, tails, iSegments), closed: true, insert: false });
-              result.reduce({});
-              return result;
-          default: return new paper.Path({ segments: oSegments.concat(iSegments), closed: true, insert: false });
-      }
-  }
-  function offsetSimpleStroke(path, offset, join, cap, limit) {
-      offset = path.clockwise ? offset : -offset;
-      var positiveOffset = offsetSimpleShape(path, offset, join, limit);
-      var negativeOffset = offsetSimpleShape(path, -offset, join, limit);
-      if (path.closed) {
-          return positiveOffset.subtract(negativeOffset, { insert: false });
-      }
-      else {
-          var inner = negativeOffset;
-          var holes = new Array();
-          if (negativeOffset instanceof paper.CompoundPath) {
-              holes = negativeOffset.children.filter(function (c) { return c.closed; });
-              holes.forEach(function (h) { return h.remove(); });
-              inner = negativeOffset.children[0];
-          }
-          inner.reverse();
-          var final = connectSide(positiveOffset, inner, offset, cap);
-          if (holes.length > 0) {
-              for (var _i = 0, holes_1 = holes; _i < holes_1.length; _i++) {
-                  var hole = holes_1[_i];
-                  final = final.subtract(hole, { insert: false });
-              }
-          }
-          return final;
-      }
-  }
-  function getNonSelfItersectionPath(path) {
-      if (path.closed) {
-          return path.unite(path, { insert: false });
-      }
-      return path;
-  }
-  function offsetPath(path, offset, join, limit) {
-      var nonSIPath = getNonSelfItersectionPath(path);
-      var result = nonSIPath;
-      if (nonSIPath instanceof paper.Path) {
-          result = offsetSimpleShape(nonSIPath, offset, join, limit);
-      }
-      else {
-          var offsetParts = nonSIPath.children.map(function (c) {
-              if (c.segments.length > 1) {
-                  if (!isSameDirection(c, path)) {
-                      c.reverse();
-                  }
-                  var offseted = offsetSimpleShape(c, offset, join, limit);
-                  offseted = normalize(offseted);
-                  if (offseted.clockwise !== c.clockwise) {
-                      offseted.reverse();
-                  }
-                  if (offseted instanceof paper.CompoundPath) {
-                      offseted.applyMatrix = true;
-                      return offseted.children;
-                  }
-                  else {
-                      return offseted;
-                  }
-              }
-              else {
-                  return null;
-              }
-          });
-          var children = offsetParts.flat().filter(function (c) { return !!c; });
-          result = new paper.CompoundPath({ children: children, insert: false });
-      }
-      result.copyAttributes(nonSIPath, false);
-      result.remove();
-      return result;
-  }
-  function offsetStroke(path, offset, join, cap, limit) {
-      var nonSIPath = getNonSelfItersectionPath(path);
-      var result = nonSIPath;
-      if (nonSIPath instanceof paper.Path) {
-          result = offsetSimpleStroke(nonSIPath, offset, join, cap, limit);
-      }
-      else {
-          var children = nonSIPath.children.flatMap(function (c) {
-              return offsetSimpleStroke(c, offset, join, cap, limit);
-          });
-          result = children.reduce(function (c1, c2) { return c1.unite(c2, { insert: false }); });
-      }
-      result.strokeWidth = 0;
-      result.fillColor = nonSIPath.strokeColor;
-      result.shadowBlur = nonSIPath.shadowBlur;
-      result.shadowColor = nonSIPath.shadowColor;
-      result.shadowOffset = nonSIPath.shadowOffset;
-      return result;
-  }
+    var Arrayex;
+    (function (Arrayex) {
+        function Delete(array, item, deleteAll) {
+            if (deleteAll === void 0) { deleteAll = false; }
+            if (deleteAll) {
+                var predicate = (typeof item === 'function') ? (function (v, i, a) { return !item(v, i, a); }) : (function (v) { return v !== item; });
+                var afterDeleted = array.filter(predicate);
+                if (afterDeleted.length < array.length) {
+                    array.splice.apply(array, [0, array.length].concat(afterDeleted));
+                    return true;
+                }
+            }
+            else {
+                var index = (typeof item === 'function') ? array.findIndex(item) : array.indexOf(item);
+                if (index > -1) {
+                    array.splice(index, 1);
+                    return true;
+                }
+            }
+            return false;
+        }
+        Arrayex.Delete = Delete;
+        function BatchDelete(array, items, deleteAll) {
+            if (deleteAll === void 0) { deleteAll = false; }
+            items.forEach(function (item) { Delete(array, item, deleteAll); });
+        }
+        Arrayex.BatchDelete = BatchDelete;
+        function Replace(array, item, newItem, replaceAll) {
+            if (replaceAll === void 0) { replaceAll = false; }
+            if (array != null) {
+                var replaced = false;
+                do {
+                    var index = (typeof item === 'function') ? array.findIndex(item) : array.indexOf(item);
+                    if (index > -1) {
+                        array[index] = newItem;
+                        replaced = true;
+                    }
+                    else {
+                        break;
+                    }
+                } while (replaceAll);
+                return replaced;
+            }
+            return false;
+        }
+        Arrayex.Replace = Replace;
+        function Find(array, predicate) {
+            var index = array.findIndex(predicate);
+            return array[index];
+        }
+        Arrayex.Find = Find;
+        /**
+         * IncludeSome() determines if at least one element in items is included in array.
+         */
+        function IncludeSome(array, items) {
+            return items.some(function (item) { return array.includes(item); });
+        }
+        Arrayex.IncludeSome = IncludeSome;
+        function OrderedInsert(orderedArray, item, compare, unique) {
+            if (unique === void 0) { unique = false; }
+            var index = orderedArray.findIndex(function (val) { return compare(val, item) >= 0; });
+            if (index > -1) {
+                var exist = compare(orderedArray[index], item) === 0;
+                orderedArray.splice(index, (exist && unique) ? 1 : 0, item);
+                return index;
+            }
+            else {
+                orderedArray.push(item);
+                return orderedArray.length - 1;
+            }
+        }
+        Arrayex.OrderedInsert = OrderedInsert;
+        /**
+         * InsertBefore() inserts an item into array before nextItem. insert to the head of array if nextItem doesn't exist.
+         */
+        function InsertBefore(array, item, nextItem) {
+            var index = array.indexOf(nextItem);
+            array.splice(Math.max(index, 0), 0, item);
+        }
+        Arrayex.InsertBefore = InsertBefore;
+        /**
+         * InsertAfter() inserts an item into array after prevItem. insert to the tail of array if prevItem doesn't exist.
+         */
+        function InsertAfter(array, item, prevItem) {
+            var index = array.indexOf(prevItem);
+            if (index > -1) {
+                array.splice(index + 1, 0, item);
+            }
+            else {
+                array.push(prevItem);
+            }
+        }
+        Arrayex.InsertAfter = InsertAfter;
+        function ApproximateIndex(array, value, epsilon) {
+            if (epsilon === void 0) { epsilon = 0; }
+            return array.findIndex(function (val) { return Math.abs(val - value) <= epsilon; });
+        }
+        Arrayex.ApproximateIndex = ApproximateIndex;
+        function Approximate(array, value, epsilon) {
+            if (epsilon === void 0) { epsilon = 0; }
+            var index = array.findIndex(function (val) { return Math.abs(val - value) <= epsilon; });
+            return array[index];
+        }
+        Arrayex.Approximate = Approximate;
+        function Empty(n) {
+            return n > 0 ? new Array(n).fill(null) : [];
+        }
+        Arrayex.Empty = Empty;
+        function Create(n, creator) {
+            return n > 0 ? new Array(n).fill(null).map(function (_, index) { return creator(index, n); }) : [];
+        }
+        Arrayex.Create = Create;
+        /**
+         * Repeat() repeats each element in sequence n times. e.g. Repeat(2, 1, 2) => [1, 1, 2, 2]
+         */
+        function Repeat(n) {
+            var sequence = [];
+            for (var _i = 1; _i < arguments.length; _i++) {
+                sequence[_i - 1] = arguments[_i];
+            }
+            return Create(n * sequence.length, function (index) { return sequence[Math.floor(index / n)]; });
+        }
+        Arrayex.Repeat = Repeat;
+        /**
+         * RepeatSequence() repeats full sequence n tims. e.g. Repeat(2, 1, 2) => [1, 2, 1, 2]
+         */
+        function RepeatSequence(n) {
+            var sequence = [];
+            for (var _i = 1; _i < arguments.length; _i++) {
+                sequence[_i - 1] = arguments[_i];
+            }
+            return Create(n * sequence.length, function (index) { return sequence[index % sequence.length]; });
+        }
+        Arrayex.RepeatSequence = RepeatSequence;
+        /**
+         * AnalyzePeriod() returns the minimum preriod of give array.
+         */
+        function AnalyzePeriod(array) {
+            var threshold = Math.ceil(Math.sqrt(array.length));
+            for (var length_1 = 1; length_1 <= threshold; ++length_1) {
+                if (array.length % length_1 === 0) {
+                    var sample = array.slice(0, length_1);
+                    var validate = true;
+                    for (var i = length_1; i < array.length; ++i) {
+                        if (array[i] !== sample[i % length_1]) {
+                            validate = false;
+                            break;
+                        }
+                    }
+                    if (validate) {
+                        return sample;
+                    }
+                }
+            }
+            return array;
+        }
+        Arrayex.AnalyzePeriod = AnalyzePeriod;
+        /**
+         * Flat() flats the array inside an array.
+         */
+        function Flat(array, keepNull) {
+            if (keepNull === void 0) { keepNull = false; }
+            var flat = Array.prototype.concat.apply([], array);
+            return keepNull ? flat : flat.filter(function (v) { return v != null; });
+        }
+        Arrayex.Flat = Flat;
+        /**
+         * Divide() divides a given array into partitions, each partition contains count element except the last one.
+         */
+        function Divide(array, count) {
+            var divides = [];
+            for (var i = 0; i < array.length; i += count) {
+                divides.push(array.slice(i, i + count));
+            }
+            return divides;
+        }
+        Arrayex.Divide = Divide;
+        /**
+         * Group() groups items in array into a directMap by a groupBy function.
+         */
+        function Group(array, groupBy) {
+            var groups = {};
+            array.forEach(function (item, index) {
+                var group = groupBy(item, index, array);
+                if (!groups[group]) {
+                    groups[group] = [];
+                }
+                groups[group].push(item);
+            });
+            return groups;
+        }
+        Arrayex.Group = Group;
+        /**
+         * Sample() samples a subarray of count in array.
+         */
+        function Sample(array, count, random) {
+            if (random === void 0) { random = false; }
+            if (count >= array.length) {
+                return array;
+            }
+            else {
+                if (!random) {
+                    var interval_1 = array.length / count;
+                    return Create(count, function (index) { return array[Math.round(interval_1 * index)]; });
+                }
+                else {
+                    var result = [];
+                    var copy = array.slice();
+                    for (var i = 0; i < count; ++i) {
+                        var item = copy.splice(Math.round(copy.length * Math.random()), 1)[0];
+                        result.push(item);
+                    }
+                    return result;
+                }
+            }
+        }
+        Arrayex.Sample = Sample;
+        function Union(arrays, unique) {
+            if (unique === void 0) { unique = false; }
+            var union = Array.prototype.concat.apply([], arrays);
+            return unique ? Array.from(new Set(union)) : union;
+        }
+        Arrayex.Union = Union;
+        function Intersect(arrays) {
+            if (arrays.length > 1) {
+                var intersectMap_1 = new Map();
+                arrays[0].forEach(function (v) { return intersectMap_1.set(v, 1); });
+                for (var i = 1; i < arrays.length; ++i) {
+                    arrays[i].forEach(function (item) {
+                        if (intersectMap_1.has(item)) {
+                            intersectMap_1.set(item, intersectMap_1.get(item) + 1);
+                        }
+                    });
+                }
+                var intersect_1 = new Array();
+                intersectMap_1.forEach(function (value, item) {
+                    if (value === arrays.length) {
+                        intersect_1.push(item);
+                    }
+                });
+                return intersect_1;
+            }
+            else {
+                return arrays[0] || [];
+            }
+        }
+        Arrayex.Intersect = Intersect;
+        function Subtract(array, arrays) {
+            if (arrays.length > 1) {
+                var union_1 = new Set(Array.prototype.concat.apply([], arrays));
+                return array.filter(function (item) { return !union_1.has(item); });
+            }
+            else {
+                return array || [];
+            }
+        }
+        Arrayex.Subtract = Subtract;
+        function NonNull(array) {
+            return array.filter(function (i) { return i != null; });
+        }
+        Arrayex.NonNull = NonNull;
+    })(Arrayex || (Arrayex = {}));
 
-  var PaperOffset = /** @class */ (function () {
-      function PaperOffset() {
-      }
-      PaperOffset.offset = function (path, offset, options) {
-          options = options || {};
-          var newPath = offsetPath(path, offset, options.join || 'miter', options.limit || 10);
-          if (options.insert === undefined) {
-              options.insert = true;
-          }
-          if (options.insert) {
-              (path.parent || paper.project.activeLayer).addChild(newPath);
-          }
-          return newPath;
-      };
-      PaperOffset.offsetStroke = function (path, offset, options) {
-          options = options || {};
-          var newPath = offsetStroke(path, offset, options.join || 'miter', options.cap || 'butt', options.limit || 10);
-          if (options.insert === undefined) {
-              options.insert = true;
-          }
-          if (options.insert) {
-              (path.parent || paper.project.activeLayer).addChild(newPath);
-          }
-          return newPath;
-      };
-      return PaperOffset;
-  }());
-  /**
-   * @deprecated EXTEND existing paper module is not recommend anymore
-   */
-  function ExtendPaperJs(paperNs) {
-      paperNs.Path.prototype.offset = function (offset, options) {
-          return PaperOffset.offset(this, offset, options);
-      };
-      paperNs.Path.prototype.offsetStroke = function (offset, options) {
-          return PaperOffset.offsetStroke(this, offset, options);
-      };
-      paperNs.CompoundPath.prototype.offset = function (offset, options) {
-          return PaperOffset.offset(this, offset, options);
-      };
-      paperNs.CompoundPath.prototype.offsetStroke = function (offset, options) {
-          return PaperOffset.offsetStroke(this, offset, options);
-      };
-  }
+    var Offsets;
+    (function (Offsets) {
+        /**
+         * Offset the start/terminal segment of a bezier curve
+         * @param segment segment to offset
+         * @param curve curve to offset
+         * @param handleNormal the normal of the the line formed of two handles
+         * @param offset offset value
+         */
+        function OffsetSegment(segment, curve, handleNormal, offset) {
+            var isFirst = segment.curve === curve;
+            // get offset vector
+            var offsetVector = (curve.getNormalAt(isFirst ? 0 : 1, true)).multiply(offset);
+            // get offset point
+            var point = segment.point.add(offsetVector);
+            var newSegment = new paper.Segment(point);
+            // handleOut for start segment & handleIn for terminal segment
+            var handle = (isFirst ? 'handleOut' : 'handleIn');
+            newSegment[handle] = segment[handle].add(handleNormal.subtract(offsetVector).divide(2));
+            return newSegment;
+        }
+        /**
+         * Adaptive offset a curve by repeatly apply the approximation proposed by Tiller and Hanson.
+         * @param curve curve to offset
+         * @param offset offset value
+         */
+        function AdaptiveOffsetCurve(curve, offset) {
+            var hNormal = (new paper.Curve(curve.segment1.handleOut.add(curve.segment1.point), new paper.Point(0, 0), new paper.Point(0, 0), curve.segment2.handleIn.add(curve.segment2.point))).getNormalAt(0.5, true).multiply(offset);
+            var segment1 = OffsetSegment(curve.segment1, curve, hNormal, offset);
+            var segment2 = OffsetSegment(curve.segment2, curve, hNormal, offset);
+            // divide && re-offset
+            var offsetCurve = new paper.Curve(segment1, segment2);
+            // if the offset curve is not self intersected, divide it
+            if (offsetCurve.getIntersections(offsetCurve).length === 0) {
+                var threshold = Math.min(Math.abs(offset) / 10, 1);
+                var midOffset = offsetCurve.getPointAt(0.5, true).getDistance(curve.getPointAt(0.5, true));
+                if (Math.abs(midOffset - Math.abs(offset)) > threshold) {
+                    var subCurve = curve.divideAtTime(0.5);
+                    if (subCurve != null) {
+                        return AdaptiveOffsetCurve(curve, offset).concat(AdaptiveOffsetCurve(subCurve, offset));
+                    }
+                }
+            }
+            return [segment1, segment2];
+        }
+        /**
+         * Create a round join segment between two adjacent segments.
+         */
+        function MakeRoundJoin(segment1, segment2, originPoint, radius) {
+            var through = segment1.point.subtract(originPoint).add(segment2.point.subtract(originPoint)).normalize(Math.abs(radius)).add(originPoint);
+            var arc = new paper.Path.Arc({ from: segment1.point, to: segment2.point, through: through, insert: false });
+            segment1.handleOut = arc.firstSegment.handleOut;
+            segment2.handleIn = arc.lastSegment.handleIn;
+            return arc.segments.length === 3 ? arc.segments[1] : null;
+        }
+        function Det(p1, p2) {
+            return p1.x * p2.y - p1.y * p2.x;
+        }
+        /**
+         * Get the intersection point of two point
+         */
+        function Intersection(p1, p2, p3, p4) {
+            var l1 = p1.subtract(p2);
+            var l2 = p3.subtract(p4);
+            var dl1 = Det(p1, p2);
+            var dl2 = Det(p3, p4);
+            return new paper.Point(dl1 * l2.x - l1.x * dl2, dl1 * l2.y - l1.y * dl2).divide(Det(l1, l2));
+        }
+        /**
+         * Connect two adjacent bezier curve, each curve is represented by two segments, create different types of joins or simply removal redundant segment.
+         */
+        function ConnectAdjacentBezier(segments1, segments2, origin, join, offset, limit) {
+            var curve1 = new paper.Curve(segments1[0], segments1[1]);
+            var curve2 = new paper.Curve(segments2[0], segments2[1]);
+            var intersection = curve1.getIntersections(curve2);
+            var distance = segments1[1].point.getDistance(segments2[0].point);
+            if (origin.isSmooth()) {
+                segments2[0].handleOut = segments2[0].handleOut.project(origin.handleOut);
+                segments2[0].handleIn = segments1[1].handleIn.project(origin.handleIn);
+                segments2[0].point = segments1[1].point.add(segments2[0].point).divide(2);
+                segments1.pop();
+            }
+            else {
+                if (intersection.length === 0) {
+                    if (distance > Math.abs(offset) * 0.1) {
+                        // connect
+                        switch (join) {
+                            case 'miter':
+                                var join_1 = Intersection(curve1.point2, curve1.point2.add(curve1.getTangentAt(1, true)), curve2.point1, curve2.point1.add(curve2.getTangentAt(0, true)));
+                                // prevent sharp angle
+                                var joinOffset = Math.max(join_1.getDistance(curve1.point2), join_1.getDistance(curve2.point1));
+                                if (joinOffset < Math.abs(offset) * limit) {
+                                    segments1.push(new paper.Segment(join_1));
+                                }
+                                break;
+                            case 'round':
+                                var mid = MakeRoundJoin(segments1[1], segments2[0], origin.point, offset);
+                                if (mid) {
+                                    segments1.push(mid);
+                                }
+                                break;
+                            default: break;
+                        }
+                    }
+                    else {
+                        segments2[0].handleIn = segments1[1].handleIn;
+                        segments1.pop();
+                    }
+                }
+                else {
+                    var second1 = curve1.divideAt(intersection[0]);
+                    if (second1) {
+                        var join_2 = second1.segment1;
+                        var second2 = curve2.divideAt(curve2.getIntersections(curve1)[0]);
+                        join_2.handleOut = second2 ? second2.segment1.handleOut : segments2[0].handleOut;
+                        segments1.pop();
+                        segments2[0] = join_2;
+                    }
+                    else {
+                        segments2[0].handleIn = segments1[1].handleIn;
+                        segments1.pop();
+                    }
+                }
+            }
+        }
+        Offsets.ConnectAdjacentBezier = ConnectAdjacentBezier;
+        /**
+         * Connect all the segments together.
+         */
+        function ConnectBeziers(rawSegments, join, source, offset, limit) {
+            var originSegments = source.segments;
+            var first = rawSegments[0].slice();
+            for (var i = 0; i < rawSegments.length - 1; ++i) {
+                ConnectAdjacentBezier(rawSegments[i], rawSegments[i + 1], originSegments[i + 1], join, offset, limit);
+            }
+            if (source.closed) {
+                ConnectAdjacentBezier(rawSegments[rawSegments.length - 1], first, originSegments[0], join, offset, limit);
+                rawSegments[0][0] = first[0];
+            }
+            return rawSegments;
+        }
+        function Decompound(path) {
+            if (path.children.length === 1) {
+                path = path.children[0];
+                path.remove(); // remove from parent, this is critical, or the style attributes will be ignored
+            }
+            return path;
+        }
+        /** Normalize a path, always clockwise, non-self-intersection, ignore really small components, and no one-component compound path. */
+        function Normalize(path, areaThreshold) {
+            if (areaThreshold === void 0) { areaThreshold = 0.01; }
+            if (path.closed) {
+                var ignoreArea_1 = Math.abs(path.area * areaThreshold);
+                if (!path.clockwise) {
+                    path.reverse();
+                }
+                path = path.unite(path, { insert: false });
+                if (path instanceof paper.CompoundPath) {
+                    path.children.filter(function (c) { return Math.abs(c.area) < ignoreArea_1; }).forEach(function (c) { return c.remove(); });
+                    if (path.children.length === 1) {
+                        return Decompound(path);
+                    }
+                }
+            }
+            return path;
+        }
+        Offsets.Normalize = Normalize;
+        function IsSameDirection(partialPath, fullPath) {
+            var offset1 = partialPath.segments[0].location.offset;
+            var offset2 = partialPath.segments[Math.max(1, Math.floor(partialPath.segments.length / 2))].location.offset;
+            var sampleOffset = (offset1 + offset2) / 3;
+            var originOffset1 = fullPath.getNearestLocation(partialPath.getPointAt(sampleOffset)).offset;
+            var originOffset2 = fullPath.getNearestLocation(partialPath.getPointAt(2 * sampleOffset)).offset;
+            return originOffset1 < originOffset2;
+        }
+        Offsets.IsSameDirection = IsSameDirection;
+        /** Remove self intersection when offset is negative by point direction dectection. */
+        function RemoveIntersection(path) {
+            var newPath = path.unite(path, { insert: false });
+            if (newPath instanceof paper.CompoundPath) {
+                newPath.children.filter(function (c) {
+                    if (c.segments.length > 1) {
+                        return !IsSameDirection(c, path);
+                    }
+                    else {
+                        return true;
+                    }
+                }).forEach(function (c) { return c.remove(); });
+                return Decompound(newPath);
+            }
+            return path;
+        }
+        Offsets.RemoveIntersection = RemoveIntersection;
+        function Segments(path) {
+            if (path instanceof paper.CompoundPath) {
+                return Arrayex.Flat(path.children.map(function (c) { return c.segments; }));
+            }
+            else {
+                return path.segments;
+            }
+        }
+        /**
+         * Remove impossible segments in negative offset condition.
+         */
+        function RemoveOutsiders(offsetPath, path) {
+            var segments = Segments(offsetPath).slice();
+            segments.forEach(function (segment) {
+                if (!path.contains(segment.point)) {
+                    segment.remove();
+                }
+            });
+        }
+        function PreparePath(path, offset) {
+            var source = path.clone({ insert: false });
+            source.reduce();
+            if (!path.clockwise) {
+                source.reverse();
+                offset = -offset;
+            }
+            return [source, offset];
+        }
+        function OffsetSimpleShape(path, offset, join, limit) {
+            var _a;
+            var source;
+            _a = PreparePath(path, offset), source = _a[0], offset = _a[1];
+            var curves = source.curves.slice();
+            var raws = Arrayex.Divide(Arrayex.Flat(curves.map(function (curve) { return AdaptiveOffsetCurve(curve, offset); })), 2);
+            var segments = Arrayex.Flat(ConnectBeziers(raws, join, source, offset, limit));
+            var offsetPath = RemoveIntersection(new paper.Path({ segments: segments, insert: false, closed: path.closed }));
+            offsetPath.reduce();
+            if (source.closed && ((source.clockwise && offset < 0) || (!source.clockwise && offset > 0))) {
+                RemoveOutsiders(offsetPath, path);
+            }
+            // recovery path
+            if (source.clockwise !== path.clockwise) {
+                offsetPath.reverse();
+            }
+            return Normalize(offsetPath);
+        }
+        Offsets.OffsetSimpleShape = OffsetSimpleShape;
+        function MakeRoundCap(from, to, offset) {
+            var origin = from.point.add(to.point).divide(2);
+            var normal = to.point.subtract(from.point).rotate(-90).normalize(offset);
+            var through = origin.add(normal);
+            var arc = new paper.Path.Arc({ from: from.point, to: to.point, through: through, insert: false });
+            return arc.segments;
+        }
+        function ConnectSide(outer, inner, offset, cap) {
+            if (outer instanceof paper.CompoundPath) {
+                var cs = outer.children.map(function (c) { return ({ c: c, a: Math.abs(c.area) }); });
+                cs = cs.sort(function (c1, c2) { return c2.a - c1.a; });
+                outer = cs[0].c;
+            }
+            var oSegments = outer.segments.slice();
+            var iSegments = inner.segments.slice();
+            switch (cap) {
+                case 'round':
+                    var heads = MakeRoundCap(iSegments[iSegments.length - 1], oSegments[0], offset);
+                    var tails = MakeRoundCap(oSegments[oSegments.length - 1], iSegments[0], offset);
+                    var result = new paper.Path({ segments: heads.concat(oSegments, tails, iSegments), closed: true, insert: false });
+                    result.reduce();
+                    return result;
+                default: return new paper.Path({ segments: oSegments.concat(iSegments), closed: true, insert: false });
+            }
+        }
+        function OffsetSimpleStroke(path, offset, join, cap, limit) {
+            offset = path.clockwise ? offset : -offset;
+            var positiveOffset = OffsetSimpleShape(path, offset, join, limit);
+            var negativeOffset = OffsetSimpleShape(path, -offset, join, limit);
+            if (path.closed) {
+                return positiveOffset.subtract(negativeOffset, { insert: false });
+            }
+            else {
+                var inner = negativeOffset;
+                var holes = new Array();
+                if (negativeOffset instanceof paper.CompoundPath) {
+                    holes = negativeOffset.children.filter(function (c) { return c.closed; });
+                    holes.forEach(function (h) { return h.remove(); });
+                    inner = negativeOffset.children[0];
+                }
+                inner.reverse();
+                var final = ConnectSide(positiveOffset, inner, offset, cap);
+                if (holes.length > 0) {
+                    for (var _i = 0, holes_1 = holes; _i < holes_1.length; _i++) {
+                        var hole = holes_1[_i];
+                        final = final.subtract(hole, { insert: false });
+                    }
+                }
+                return final;
+            }
+        }
+        Offsets.OffsetSimpleStroke = OffsetSimpleStroke;
+    })(Offsets || (Offsets = {}));
+    function OffsetPath(path, offset, join, limit) {
+        var nonSIPath = path.unite(path, { insert: false });
+        var result = nonSIPath;
+        if (nonSIPath instanceof paper.Path) {
+            result = Offsets.OffsetSimpleShape(nonSIPath, offset, join, limit);
+        }
+        else {
+            var children = Arrayex.Flat(nonSIPath.children.map(function (c) {
+                if (c.segments.length > 1) {
+                    if (!Offsets.IsSameDirection(c, path)) {
+                        c.reverse();
+                    }
+                    var offseted = Offsets.OffsetSimpleShape(c, offset, join, limit);
+                    offseted = Offsets.Normalize(offseted);
+                    if (offseted.clockwise !== c.clockwise) {
+                        offseted.reverse();
+                    }
+                    if (offseted instanceof paper.CompoundPath) {
+                        offseted.applyMatrix = true;
+                        return offseted.children;
+                    }
+                    else {
+                        return offseted;
+                    }
+                }
+                else {
+                    return null;
+                }
+            }), false);
+            result = new paper.CompoundPath({ children: children, insert: false });
+        }
+        result.copyAttributes(nonSIPath, false);
+        result.remove();
+        return result;
+    }
+    function OffsetStroke(path, offset, join, cap, limit) {
+        var nonSIPath = path.unite(path, { insert: false });
+        var result = nonSIPath;
+        if (nonSIPath instanceof paper.Path) {
+            result = Offsets.OffsetSimpleStroke(nonSIPath, offset, join, cap, limit);
+        }
+        else {
+            var children = Arrayex.Flat(nonSIPath.children.map(function (c) {
+                return Offsets.OffsetSimpleStroke(c, offset, join, cap, limit);
+            }));
+            result = children.reduce(function (c1, c2) { return c1.unite(c2, { insert: false }); });
+        }
+        result.strokeWidth = 0;
+        result.fillColor = nonSIPath.strokeColor;
+        result.shadowBlur = nonSIPath.shadowBlur;
+        result.shadowColor = nonSIPath.shadowColor;
+        result.shadowOffset = nonSIPath.shadowOffset;
+        return result;
+    }
 
-  ExtendPaperJs(paper);
-  window.PaperOffset = {
-      offset: PaperOffset.offset,
-      offsetStroke: PaperOffset.offsetStroke,
-  };
+    function PrototypedOffset(path, offset, options) {
+        options = options || {};
+        var offsetPath = OffsetPath(path, offset, options.join || 'miter', options.limit || 10);
+        if (options.insert === undefined) {
+            options.insert = true;
+        }
+        if (options.insert) {
+            (path.parent || paper.project.activeLayer).addChild(offsetPath);
+        }
+        return offsetPath;
+    }
+    function PrototypedOffsetStroke(path, offset, options) {
+        options = options || {};
+        var offsetPath = OffsetStroke(path, offset, options.join || 'miter', options.cap || 'butt', options.limit || 10);
+        if (options.insert === undefined) {
+            options.insert = true;
+        }
+        if (options.insert) {
+            (path.parent || paper.project.activeLayer).addChild(offsetPath);
+        }
+        return offsetPath;
+    }
+    function ExtendPaperJs(paper) {
+        paper.Path.prototype.offset = function (offset, options) {
+            return PrototypedOffset(this, offset, options);
+        };
+        paper.Path.prototype.offsetStroke = function (offset, options) {
+            return PrototypedOffsetStroke(this, offset, options);
+        };
+        paper.CompoundPath.prototype.offset = function (offset, options) {
+            return PrototypedOffset(this, offset, options);
+        };
+        paper.CompoundPath.prototype.offsetStroke = function (offset, options) {
+            return PrototypedOffsetStroke(this, offset, options);
+        };
+    }
+
+    ExtendPaperJs(paper);
 
 }(paper));
diff --git a/node_modules/paperjs-offset/demo/paperjs-offset.min.js b/node_modules/paperjs-offset/demo/paperjs-offset.min.js
index 51a8ec0..00bf908 100644
--- a/node_modules/paperjs-offset/demo/paperjs-offset.min.js
+++ b/node_modules/paperjs-offset/demo/paperjs-offset.min.js
@@ -1 +1 @@
-!function(S){"use strict";function p(e,t,n,r){var o=e.curve===t,i=t.getNormalAtTime(o?0:1).multiply(r),a=e.point.add(i),s=new S.Segment(a),c=o?"handleOut":"handleIn";return s[c]=e[c].add(n.subtract(i).divide(2)),s}function T(e,t){return e.x*t.y-e.y*t.x}function m(e,t,n,r,o,i){var a,s,c,u,f,l,d,h,p,m,g,v,w,P,b=new S.Curve(e[0],e[1]),k=new S.Curve(t[0],t[1]),C=b.getIntersections(k),y=e[1].point.getDistance(t[0].point);if(n.isSmooth())t[0].handleOut=t[0].handleOut.project(n.handleOut),t[0].handleIn=e[1].handleIn.project(n.handleIn),t[0].point=e[1].point.add(t[0].point).divide(2),e.pop();else if(0===C.length)if(y>.1*Math.abs(o))switch(r){case"miter":var A=(d=b.point2,h=b.point2.add(b.getTangentAtTime(1)),p=k.point1,m=k.point1.add(k.getTangentAtTime(0)),g=d.subtract(h),v=p.subtract(m),w=T(d,h),P=T(p,m),new S.Point(w*v.x-g.x*P,w*v.y-g.y*P).divide(T(g,v)));Math.max(A.getDistance(b.point2),A.getDistance(k.point1))<Math.abs(o)*i&&e.push(new S.Segment(A));break;case"round":var M=(a=e[1],s=t[0],c=n.point,u=o,f=a.point.subtract(c).add(s.point.subtract(c)).normalize(Math.abs(u)).add(c),l=new S.Path.Arc({from:a.point,to:s.point,through:f,insert:!1}),a.handleOut=l.firstSegment.handleOut,s.handleIn=l.lastSegment.handleIn,3===l.segments.length?l.segments[1]:null);M&&e.push(M)}else t[0].handleIn=e[1].handleIn,e.pop();else{var O=b.divideAt(C[0]);if(O){A=O.segment1;var I=k.divideAt(k.getIntersections(b)[0]);A.handleOut=I?I.segment1.handleOut:t[0].handleOut,e.pop(),t[0]=A}else t[0].handleIn=e[1].handleIn,e.pop()}}function g(e){return 1===e.children.length&&(e=e.children[0]).remove(),e}function v(e,t){if(void 0===t&&(t=.01),e.closed){var n=Math.abs(e.area*t);if(e.clockwise||e.reverse(),(e=e.unite(e,{insert:!1}))instanceof S.CompoundPath&&(e.children.filter(function(e){return Math.abs(e.area)<n}).forEach(function(e){return e.remove()}),1===e.children.length))return g(e)}return e}function w(e,t){var n=(e.segments[0].location.offset+e.segments[Math.max(1,Math.floor(e.segments.length/2))].location.offset)/3;return t.getNearestLocation(e.getPointAt(n)).offset<t.getNearestLocation(e.getPointAt(2*n)).offset}function P(e,t){var n;((n=e)instanceof S.CompoundPath?n.children.map(function(e){return e.segments}).flat():n.segments).slice().forEach(function(e){t.contains(e.point)||e.remove()})}function h(e,t,n,r){var o,i,a,s,c;s=t,(c=(a=e).clone({insert:!1})).reduce({}),a.clockwise||(c.reverse(),s=-s),t=(o=[c,s])[1];for(var u=(i=o[0]).curves.slice().map(function(e){return function e(t,n){var r=new S.Curve(t.segment1.handleOut.add(t.segment1.point),new S.Point(0,0),new S.Point(0,0),t.segment2.handleIn.add(t.segment2.point)).getNormalAtTime(.5).multiply(n),o=p(t.segment1,t,r,n),i=p(t.segment2,t,r,n),a=new S.Curve(o,i);if(0===a.getIntersections(a).length){var s=Math.min(Math.abs(n)/10,1),c=a.getPointAtTime(.5).getDistance(t.getPointAtTime(.5));if(Math.abs(c-Math.abs(n))>s){var u=t.divideAtTime(.5);if(null!=u)return e(t,n).concat(e(u,n))}}return[o,i]}(e,t)}).flat(),f=[],l=0;l<u.length;l+=2)f.push(u.slice(l,l+2));var d=function(e,t,n,r,o){for(var i=n.segments,a=e[0].slice(),s=0;s<e.length-1;++s)m(e[s],e[s+1],i[s+1],t,r,o);return n.closed&&(m(e[e.length-1],a,i[0],t,r,o),e[0][0]=a[0]),e}(f,n,i,t,r).flat(),h=function(t){if(t.closed){var e=t.unite(t,{insert:!1});if(e instanceof S.CompoundPath)return e.children.filter(function(e){return!(1<e.segments.length)||!w(e,t)}).forEach(function(e){return e.remove()}),g(e)}return t}(new S.Path({segments:d,insert:!1,closed:e.closed}));return h.reduce({}),i.closed&&(i.clockwise&&t<0||!i.clockwise&&0<t)&&P(h,e),i.clockwise!==e.clockwise&&h.reverse(),v(h)}function b(e,t,n){var r=e.point.add(t.point).divide(2),o=t.point.subtract(e.point).rotate(-90,new S.Point(0,0)).normalize(n),i=r.add(o);return new S.Path.Arc({from:e.point,to:t.point,through:i,insert:!1}).segments}function l(e,t,n,r,o){var i=h(e,t=e.clockwise?t:-t,n,o),a=h(e,-t,n,o);if(e.closed)return i.subtract(a,{insert:!1});var s=a,c=new Array;a instanceof S.CompoundPath&&((c=a.children.filter(function(e){return e.closed})).forEach(function(e){return e.remove()}),s=a.children[0]),s.reverse();var u=function(e,t,n,r){if(e instanceof S.CompoundPath){var o=e.children.map(function(e){return{c:e,a:Math.abs(e.area)}});e=(o=o.sort(function(e,t){return t.a-e.a}))[0].c}var i=e.segments.slice(),a=t.segments.slice();switch(r){case"round":var s=b(a[a.length-1],i[0],n),c=b(i[i.length-1],a[0],n),u=new S.Path({segments:s.concat(i,c,a),closed:!0,insert:!1});return u.reduce({}),u;default:return new S.Path({segments:i.concat(a),closed:!0,insert:!1})}}(i,s,t,r);if(0<c.length)for(var f=0,l=c;f<l.length;f++){var d=l[f];u=u.subtract(d,{insert:!1})}return u}function d(e){return e.closed?e.unite(e,{insert:!1}):e}S=S&&Object.prototype.hasOwnProperty.call(S,"default")?S.default:S;var e,n=(t.offset=function(e,t,n){var r=function(n,r,o,i){var e=d(n),t=e;if(e instanceof S.Path)t=h(e,r,o,i);else{var a=e.children.map(function(e){if(1<e.segments.length){w(e,n)||e.reverse();var t=h(e,r,o,i);return(t=v(t)).clockwise!==e.clockwise&&t.reverse(),t instanceof S.CompoundPath?(t.applyMatrix=!0,t.children):t}return null}).flat().filter(function(e){return!!e});t=new S.CompoundPath({children:a,insert:!1})}return t.copyAttributes(e,!1),t.remove(),t}(e,t,(n=n||{}).join||"miter",n.limit||10);return void 0===n.insert&&(n.insert=!0),n.insert&&(e.parent||S.project.activeLayer).addChild(r),r},t.offsetStroke=function(e,t,n){var r,o,i,a,s,c,u,f=(r=e,o=t,i=(n=n||{}).join||"miter",a=n.cap||"butt",s=n.limit||10,c=d(r),(u=(u=c)instanceof S.Path?l(c,o,i,a,s):c.children.flatMap(function(e){return l(e,o,i,a,s)}).reduce(function(e,t){return e.unite(t,{insert:!1})})).strokeWidth=0,u.fillColor=c.strokeColor,u.shadowBlur=c.shadowBlur,u.shadowColor=c.shadowColor,u.shadowOffset=c.shadowOffset,u);return void 0===n.insert&&(n.insert=!0),n.insert&&(e.parent||S.project.activeLayer).addChild(f),f},t);function t(){}(e=S).Path.prototype.offset=function(e,t){return n.offset(this,e,t)},e.Path.prototype.offsetStroke=function(e,t){return n.offsetStroke(this,e,t)},e.CompoundPath.prototype.offset=function(e,t){return n.offset(this,e,t)},e.CompoundPath.prototype.offsetStroke=function(e,t){return n.offsetStroke(this,e,t)},window.PaperOffset={offset:n.offset,offsetStroke:n.offsetStroke}}(paper);
+!function(w){"use strict";var y,u,n;function e(n,t,e){var r=function(e,r,i,o){var n=e.unite(e,{insert:!1}),t=n;if(n instanceof w.Path)t=u.OffsetSimpleShape(n,r,i,o);else{var a=y.Flat(n.children.map(function(n){if(1<n.segments.length){u.IsSameDirection(n,e)||n.reverse();var t=u.OffsetSimpleShape(n,r,i,o);return(t=u.Normalize(t)).clockwise!==n.clockwise&&t.reverse(),t instanceof w.CompoundPath?(t.applyMatrix=!0,t.children):t}return null}),!1);t=new w.CompoundPath({children:a,insert:!1})}return t.copyAttributes(n,!1),t}(n,t,(e=e||{}).join||"miter",e.limit||10);return void 0===e.insert&&(e.insert=!0),e.insert&&(n.parent||w.project.activeLayer).addChild(r),r}function r(n,t,e){var r=function(n,t,e,r,i){var o=n.unite(n,{insert:!1}),a=o;return(a=o instanceof w.Path?u.OffsetSimpleStroke(o,t,e,r,i):y.Flat(o.children.map(function(n){return u.OffsetSimpleStroke(n,t,e,r,i)})).reduce(function(n,t){return n.unite(t,{insert:!1})})).strokeWidth=0,a.fillColor=o.strokeColor,a.shadowBlur=o.shadowBlur,a.shadowColor=o.shadowColor,a.shadowOffset=o.shadowOffset,a}(n,t,(e=e||{}).join||"miter",e.cap||"butt",e.limit||10);return void 0===e.insert&&(e.insert=!0),e.insert&&(n.parent||w.project.activeLayer).addChild(r),r}w=w&&w.hasOwnProperty("default")?w.default:w,function(n){function r(n,r,t){if(void 0===t&&(t=!1),t){var e="function"==typeof r?function(n,t,e){return!r(n,t,e)}:function(n){return n!==r},i=n.filter(e);if(i.length<n.length)return n.splice.apply(n,[0,n.length].concat(i)),!0}else{var o="function"==typeof r?n.findIndex(r):n.indexOf(r);if(-1<o)return n.splice(o,1),!0}return!1}function c(e,r){return 0<e?new Array(e).fill(null).map(function(n,t){return r(t,e)}):[]}n.Delete=r,n.BatchDelete=function(t,n,e){void 0===e&&(e=!1),n.forEach(function(n){r(t,n,e)})},n.Replace=function(n,t,e,r){if(void 0===r&&(r=!1),null==n)return!1;var i=!1;do{var o="function"==typeof t?n.findIndex(t):n.indexOf(t);if(!(-1<o))break;n[o]=e,i=!0}while(r);return i},n.Find=function(n,t){var e=n.findIndex(t);return n[e]},n.IncludeSome=function(t,n){return n.some(function(n){return t.includes(n)})},n.OrderedInsert=function(n,t,e,r){void 0===r&&(r=!1);var i=n.findIndex(function(n){return 0<=e(n,t)});if(-1<i){var o=0===e(n[i],t);return n.splice(i,o&&r?1:0,t),i}return n.push(t),n.length-1},n.InsertBefore=function(n,t,e){var r=n.indexOf(e);n.splice(Math.max(r,0),0,t)},n.InsertAfter=function(n,t,e){var r=n.indexOf(e);-1<r?n.splice(r+1,0,t):n.push(e)},n.ApproximateIndex=function(n,t,e){return void 0===e&&(e=0),n.findIndex(function(n){return Math.abs(n-t)<=e})},n.Approximate=function(n,t,e){void 0===e&&(e=0);var r=n.findIndex(function(n){return Math.abs(n-t)<=e});return n[r]},n.Empty=function(n){return 0<n?new Array(n).fill(null):[]},n.Create=c,n.Repeat=function(t){for(var e=[],n=1;n<arguments.length;n++)e[n-1]=arguments[n];return c(t*e.length,function(n){return e[Math.floor(n/t)]})},n.RepeatSequence=function(n){for(var t=[],e=1;e<arguments.length;e++)t[e-1]=arguments[e];return c(n*t.length,function(n){return t[n%t.length]})},n.AnalyzePeriod=function(n){for(var t=Math.ceil(Math.sqrt(n.length)),e=1;e<=t;++e)if(n.length%e==0){for(var r=n.slice(0,e),i=!0,o=e;o<n.length;++o)if(n[o]!==r[o%e]){i=!1;break}if(i)return r}return n},n.Flat=function(n,t){void 0===t&&(t=!1);var e=Array.prototype.concat.apply([],n);return t?e:e.filter(function(n){return null!=n})},n.Divide=function(n,t){for(var e=[],r=0;r<n.length;r+=t)e.push(n.slice(r,r+t));return e},n.Group=function(r,i){var o={};return r.forEach(function(n,t){var e=i(n,t,r);o[e]||(o[e]=[]),o[e].push(n)}),o},n.Sample=function(t,n,e){if(void 0===e&&(e=!1),n>=t.length)return t;if(e){for(var r=[],i=t.slice(),o=0;o<n;++o){var a=i.splice(Math.round(i.length*Math.random()),1)[0];r.push(a)}return r}var u=t.length/n;return c(n,function(n){return t[Math.round(u*n)]})},n.Union=function(n,t){void 0===t&&(t=!1);var e=Array.prototype.concat.apply([],n);return t?Array.from(new Set(e)):e},n.Intersect=function(e){if(1<e.length){var t=new Map;e[0].forEach(function(n){return t.set(n,1)});for(var n=1;n<e.length;++n)e[n].forEach(function(n){t.has(n)&&t.set(n,t.get(n)+1)});var r=new Array;return t.forEach(function(n,t){n===e.length&&r.push(t)}),r}return e[0]||[]},n.Subtract=function(n,t){if(1<t.length){var e=new Set(Array.prototype.concat.apply([],t));return n.filter(function(n){return!e.has(n)})}return n||[]},n.NonNull=function(n){return n.filter(function(n){return null!=n})}}(y||(y={})),function(n){function f(n,t,e,r){var i=n.curve===t,o=t.getNormalAt(i?0:1,!0).multiply(r),a=n.point.add(o),u=new w.Segment(a),c=i?"handleOut":"handleIn";return u[c]=n[c].add(e.subtract(o).divide(2)),u}function v(n,t){return n.x*t.y-n.y*t.x}function l(n,t,e,r,i,o){var a=new w.Curve(n[0],n[1]),u=new w.Curve(t[0],t[1]),c=a.getIntersections(u),s=n[1].point.getDistance(t[0].point);if(e.isSmooth())t[0].handleOut=t[0].handleOut.project(e.handleOut),t[0].handleIn=n[1].handleIn.project(e.handleIn),t[0].point=n[1].point.add(t[0].point).divide(2),n.pop();else if(0===c.length)if(s>.1*Math.abs(i))switch(r){case"miter":var f=function(n,t,e,r){var i=n.subtract(t),o=e.subtract(r),a=v(n,t),u=v(e,r);return new w.Point(a*o.x-i.x*u,a*o.y-i.y*u).divide(v(i,o))}(a.point2,a.point2.add(a.getTangentAt(1,!0)),u.point1,u.point1.add(u.getTangentAt(0,!0)));Math.max(f.getDistance(a.point2),f.getDistance(u.point1))<Math.abs(i)*o&&n.push(new w.Segment(f));break;case"round":var l=function(n,t,e,r){var i=n.point.subtract(e).add(t.point.subtract(e)).normalize(Math.abs(r)).add(e),o=new w.Path.Arc({from:n.point,to:t.point,through:i,insert:!1});return n.handleOut=o.firstSegment.handleOut,t.handleIn=o.lastSegment.handleIn,3===o.segments.length?o.segments[1]:null}(n[1],t[0],e.point,i);l&&n.push(l)}else t[0].handleIn=n[1].handleIn,n.pop();else{var h=a.divideAt(c[0]);if(h){var d=h.segment1,p=u.divideAt(u.getIntersections(a)[0]);d.handleOut=p?p.segment1.handleOut:t[0].handleOut,n.pop(),t[0]=d}else t[0].handleIn=n[1].handleIn,n.pop()}}function r(n){return 1===n.children.length&&(n=n.children[0]).remove(),n}function h(n,t){if(void 0===t&&(t=.01),n.closed){var e=Math.abs(n.area*t);if(n.clockwise||n.reverse(),(n=n.unite(n,{insert:!1}))instanceof w.CompoundPath&&(n.children.filter(function(n){return Math.abs(n.area)<e}).forEach(function(n){return n.remove()}),1===n.children.length))return r(n)}return n}function e(n,t){var e=(n.segments[0].location.offset+n.segments[Math.max(1,Math.floor(n.segments.length/2))].location.offset)/3;return t.getNearestLocation(n.getPointAt(e)).offset<t.getNearestLocation(n.getPointAt(2*e)).offset}function d(t){var n=t.unite(t,{insert:!1});return n instanceof w.CompoundPath?(n.children.filter(function(n){return!(1<n.segments.length)||!e(n,t)}).forEach(function(n){return n.remove()}),r(n)):t}function p(n,t){(function(n){return n instanceof w.CompoundPath?y.Flat(n.children.map(function(n){return n.segments})):n.segments})(n).slice().forEach(function(n){t.contains(n.point)||n.remove()})}function m(n,t,e,r){var i,o;o=(i=function(n,t){var e=n.clone({insert:!1});return e.reduce(),n.clockwise||(e.reverse(),t=-t),[e,t]}(n,t))[0],t=i[1];var a=o.curves.slice(),u=y.Divide(y.Flat(a.map(function(n){return function n(t,e){var r=new w.Curve(t.segment1.handleOut.add(t.segment1.point),new w.Point(0,0),new w.Point(0,0),t.segment2.handleIn.add(t.segment2.point)).getNormalAt(.5,!0).multiply(e),i=f(t.segment1,t,r,e),o=f(t.segment2,t,r,e),a=new w.Curve(i,o);if(0===a.getIntersections(a).length){var u=Math.min(Math.abs(e)/10,1),c=a.getPointAt(.5,!0).getDistance(t.getPointAt(.5,!0));if(Math.abs(c-Math.abs(e))>u){var s=t.divideAtTime(.5);if(null!=s)return n(t,e).concat(n(s,e))}}return[i,o]}(n,t)})),2),c=y.Flat(function(n,t,e,r,i){for(var o=e.segments,a=n[0].slice(),u=0;u<n.length-1;++u)l(n[u],n[u+1],o[u+1],t,r,i);return e.closed&&(l(n[n.length-1],a,o[0],t,r,i),n[0][0]=a[0]),n}(u,e,o,t,r)),s=d(new w.Path({segments:c,insert:!1,closed:n.closed}));return s.reduce(),o.closed&&(o.clockwise&&t<0||!o.clockwise&&0<t)&&p(s,n),o.clockwise!==n.clockwise&&s.reverse(),h(s)}function g(n,t,e){var r=n.point.add(t.point).divide(2),i=t.point.subtract(n.point).rotate(-90).normalize(e),o=r.add(i);return new w.Path.Arc({from:n.point,to:t.point,through:o,insert:!1}).segments}n.ConnectAdjacentBezier=l,n.Normalize=h,n.IsSameDirection=e,n.RemoveIntersection=d,n.OffsetSimpleShape=m,n.OffsetSimpleStroke=function(n,t,e,r,i){var o=m(n,t=n.clockwise?t:-t,e,i),a=m(n,-t,e,i);if(n.closed)return o.subtract(a,{insert:!1});var u=a,c=new Array;a instanceof w.CompoundPath&&((c=a.children.filter(function(n){return n.closed})).forEach(function(n){return n.remove()}),u=a.children[0]),u.reverse();var s=function(n,t,e,r){if(n instanceof w.CompoundPath){var i=n.children.map(function(n){return{c:n,a:Math.abs(n.area)}});n=(i=i.sort(function(n,t){return t.a-n.a}))[0].c}var o=n.segments.slice(),a=t.segments.slice();switch(r){case"round":var u=g(a[a.length-1],o[0],e),c=g(o[o.length-1],a[0],e),s=new w.Path({segments:u.concat(o,c,a),closed:!0,insert:!1});return s.reduce(),s;default:return new w.Path({segments:o.concat(a),closed:!0,insert:!1})}}(o,u,t,r);if(0<c.length)for(var f=0,l=c;f<l.length;f++){var h=l[f];s=s.subtract(h,{insert:!1})}return s}}(u||(u={})),(n=w).Path.prototype.offset=function(n,t){return e(this,n,t)},n.Path.prototype.offsetStroke=function(n,t){return r(this,n,t)},n.CompoundPath.prototype.offset=function(n,t){return e(this,n,t)},n.CompoundPath.prototype.offsetStroke=function(n,t){return r(this,n,t)}}(paper);
diff --git a/node_modules/paperjs-offset/dist/index.es5.js b/node_modules/paperjs-offset/dist/index.es5.js
index 300d644..37fee82 100644
--- a/node_modules/paperjs-offset/dist/index.es5.js
+++ b/node_modules/paperjs-offset/dist/index.es5.js
@@ -1,316 +1,313 @@
 import paper from 'paper';
+import { Arrayex } from 'arrayex';
 
-/**
- * Offset the start/terminal segment of a bezier curve
- * @param segment segment to offset
- * @param curve curve to offset
- * @param handleNormal the normal of the the line formed of two handles
- * @param offset offset value
- */
-function offsetSegment(segment, curve, handleNormal, offset) {
-    var isFirst = segment.curve === curve;
-    // get offset vector
-    var offsetVector = (curve.getNormalAtTime(isFirst ? 0 : 1)).multiply(offset);
-    // get offset point
-    var point = segment.point.add(offsetVector);
-    var newSegment = new paper.Segment(point);
-    // handleOut for start segment & handleIn for terminal segment
-    var handle = (isFirst ? 'handleOut' : 'handleIn');
-    newSegment[handle] = segment[handle].add(handleNormal.subtract(offsetVector).divide(2));
-    return newSegment;
-}
-/**
- * Adaptive offset a curve by repeatly apply the approximation proposed by Tiller and Hanson.
- * @param curve curve to offset
- * @param offset offset value
- */
-function adaptiveOffsetCurve(curve, offset) {
-    var hNormal = (new paper.Curve(curve.segment1.handleOut.add(curve.segment1.point), new paper.Point(0, 0), new paper.Point(0, 0), curve.segment2.handleIn.add(curve.segment2.point))).getNormalAtTime(0.5).multiply(offset);
-    var segment1 = offsetSegment(curve.segment1, curve, hNormal, offset);
-    var segment2 = offsetSegment(curve.segment2, curve, hNormal, offset);
-    // divide && re-offset
-    var offsetCurve = new paper.Curve(segment1, segment2);
-    // if the offset curve is not self intersected, divide it
-    if (offsetCurve.getIntersections(offsetCurve).length === 0) {
-        var threshold = Math.min(Math.abs(offset) / 10, 1);
-        var midOffset = offsetCurve.getPointAtTime(0.5).getDistance(curve.getPointAtTime(0.5));
-        if (Math.abs(midOffset - Math.abs(offset)) > threshold) {
-            var subCurve = curve.divideAtTime(0.5);
-            if (subCurve != null) {
-                return adaptiveOffsetCurve(curve, offset).concat(adaptiveOffsetCurve(subCurve, offset));
+var Offsets;
+(function (Offsets) {
+    /**
+     * Offset the start/terminal segment of a bezier curve
+     * @param segment segment to offset
+     * @param curve curve to offset
+     * @param handleNormal the normal of the the line formed of two handles
+     * @param offset offset value
+     */
+    function OffsetSegment(segment, curve, handleNormal, offset) {
+        var isFirst = segment.curve === curve;
+        // get offset vector
+        var offsetVector = (curve.getNormalAt(isFirst ? 0 : 1, true)).multiply(offset);
+        // get offset point
+        var point = segment.point.add(offsetVector);
+        var newSegment = new paper.Segment(point);
+        // handleOut for start segment & handleIn for terminal segment
+        var handle = (isFirst ? 'handleOut' : 'handleIn');
+        newSegment[handle] = segment[handle].add(handleNormal.subtract(offsetVector).divide(2));
+        return newSegment;
+    }
+    /**
+     * Adaptive offset a curve by repeatly apply the approximation proposed by Tiller and Hanson.
+     * @param curve curve to offset
+     * @param offset offset value
+     */
+    function AdaptiveOffsetCurve(curve, offset) {
+        var hNormal = (new paper.Curve(curve.segment1.handleOut.add(curve.segment1.point), new paper.Point(0, 0), new paper.Point(0, 0), curve.segment2.handleIn.add(curve.segment2.point))).getNormalAt(0.5, true).multiply(offset);
+        var segment1 = OffsetSegment(curve.segment1, curve, hNormal, offset);
+        var segment2 = OffsetSegment(curve.segment2, curve, hNormal, offset);
+        // divide && re-offset
+        var offsetCurve = new paper.Curve(segment1, segment2);
+        // if the offset curve is not self intersected, divide it
+        if (offsetCurve.getIntersections(offsetCurve).length === 0) {
+            var threshold = Math.min(Math.abs(offset) / 10, 1);
+            var midOffset = offsetCurve.getPointAt(0.5, true).getDistance(curve.getPointAt(0.5, true));
+            if (Math.abs(midOffset - Math.abs(offset)) > threshold) {
+                var subCurve = curve.divideAtTime(0.5);
+                if (subCurve != null) {
+                    return AdaptiveOffsetCurve(curve, offset).concat(AdaptiveOffsetCurve(subCurve, offset));
+                }
             }
         }
+        return [segment1, segment2];
     }
-    return [segment1, segment2];
-}
-/**
- * Create a round join segment between two adjacent segments.
- */
-function makeRoundJoin(segment1, segment2, originPoint, radius) {
-    var through = segment1.point.subtract(originPoint).add(segment2.point.subtract(originPoint))
-        .normalize(Math.abs(radius)).add(originPoint);
-    var arc = new paper.Path.Arc({ from: segment1.point, to: segment2.point, through: through, insert: false });
-    segment1.handleOut = arc.firstSegment.handleOut;
-    segment2.handleIn = arc.lastSegment.handleIn;
-    return arc.segments.length === 3 ? arc.segments[1] : null;
-}
-function det(p1, p2) {
-    return p1.x * p2.y - p1.y * p2.x;
-}
-/**
- * Get the intersection point of point based lines
- */
-function getPointLineIntersections(p1, p2, p3, p4) {
-    var l1 = p1.subtract(p2);
-    var l2 = p3.subtract(p4);
-    var dl1 = det(p1, p2);
-    var dl2 = det(p3, p4);
-    return new paper.Point(dl1 * l2.x - l1.x * dl2, dl1 * l2.y - l1.y * dl2).divide(det(l1, l2));
-}
-/**
- * Connect two adjacent bezier curve, each curve is represented by two segments,
- * create different types of joins or simply removal redundant segment.
- */
-function connectAdjacentBezier(segments1, segments2, origin, joinType, offset, limit) {
-    var curve1 = new paper.Curve(segments1[0], segments1[1]);
-    var curve2 = new paper.Curve(segments2[0], segments2[1]);
-    var intersection = curve1.getIntersections(curve2);
-    var distance = segments1[1].point.getDistance(segments2[0].point);
-    if (origin.isSmooth()) {
-        segments2[0].handleOut = segments2[0].handleOut.project(origin.handleOut);
-        segments2[0].handleIn = segments1[1].handleIn.project(origin.handleIn);
-        segments2[0].point = segments1[1].point.add(segments2[0].point).divide(2);
-        segments1.pop();
+    /**
+     * Create a round join segment between two adjacent segments.
+     */
+    function MakeRoundJoin(segment1, segment2, originPoint, radius) {
+        var through = segment1.point.subtract(originPoint).add(segment2.point.subtract(originPoint)).normalize(Math.abs(radius)).add(originPoint);
+        var arc = new paper.Path.Arc({ from: segment1.point, to: segment2.point, through: through, insert: false });
+        segment1.handleOut = arc.firstSegment.handleOut;
+        segment2.handleIn = arc.lastSegment.handleIn;
+        return arc.segments.length === 3 ? arc.segments[1] : null;
     }
-    else {
-        if (intersection.length === 0) {
-            if (distance > Math.abs(offset) * 0.1) {
-                // connect
-                switch (joinType) {
-                    case 'miter':
-                        var join = getPointLineIntersections(curve1.point2, curve1.point2.add(curve1.getTangentAtTime(1)), curve2.point1, curve2.point1.add(curve2.getTangentAtTime(0)));
-                        // prevent sharp angle
-                        var joinOffset = Math.max(join.getDistance(curve1.point2), join.getDistance(curve2.point1));
-                        if (joinOffset < Math.abs(offset) * limit) {
-                            segments1.push(new paper.Segment(join));
-                        }
-                        break;
-                    case 'round':
-                        var mid = makeRoundJoin(segments1[1], segments2[0], origin.point, offset);
-                        if (mid) {
-                            segments1.push(mid);
-                        }
-                        break;
-                }
-            }
-            else {
-                segments2[0].handleIn = segments1[1].handleIn;
-                segments1.pop();
-            }
+    function Det(p1, p2) {
+        return p1.x * p2.y - p1.y * p2.x;
+    }
+    /**
+     * Get the intersection point of two point
+     */
+    function Intersection(p1, p2, p3, p4) {
+        var l1 = p1.subtract(p2);
+        var l2 = p3.subtract(p4);
+        var dl1 = Det(p1, p2);
+        var dl2 = Det(p3, p4);
+        return new paper.Point(dl1 * l2.x - l1.x * dl2, dl1 * l2.y - l1.y * dl2).divide(Det(l1, l2));
+    }
+    /**
+     * Connect two adjacent bezier curve, each curve is represented by two segments, create different types of joins or simply removal redundant segment.
+     */
+    function ConnectAdjacentBezier(segments1, segments2, origin, join, offset, limit) {
+        var curve1 = new paper.Curve(segments1[0], segments1[1]);
+        var curve2 = new paper.Curve(segments2[0], segments2[1]);
+        var intersection = curve1.getIntersections(curve2);
+        var distance = segments1[1].point.getDistance(segments2[0].point);
+        if (origin.isSmooth()) {
+            segments2[0].handleOut = segments2[0].handleOut.project(origin.handleOut);
+            segments2[0].handleIn = segments1[1].handleIn.project(origin.handleIn);
+            segments2[0].point = segments1[1].point.add(segments2[0].point).divide(2);
+            segments1.pop();
         }
         else {
-            var second1 = curve1.divideAt(intersection[0]);
-            if (second1) {
-                var join = second1.segment1;
-                var second2 = curve2.divideAt(curve2.getIntersections(curve1)[0]);
-                join.handleOut = second2 ? second2.segment1.handleOut : segments2[0].handleOut;
-                segments1.pop();
-                segments2[0] = join;
+            if (intersection.length === 0) {
+                if (distance > Math.abs(offset) * 0.1) {
+                    // connect
+                    switch (join) {
+                        case 'miter':
+                            var join_1 = Intersection(curve1.point2, curve1.point2.add(curve1.getTangentAt(1, true)), curve2.point1, curve2.point1.add(curve2.getTangentAt(0, true)));
+                            // prevent sharp angle
+                            var joinOffset = Math.max(join_1.getDistance(curve1.point2), join_1.getDistance(curve2.point1));
+                            if (joinOffset < Math.abs(offset) * limit) {
+                                segments1.push(new paper.Segment(join_1));
+                            }
+                            break;
+                        case 'round':
+                            var mid = MakeRoundJoin(segments1[1], segments2[0], origin.point, offset);
+                            if (mid) {
+                                segments1.push(mid);
+                            }
+                            break;
+                        default: break;
+                    }
+                }
+                else {
+                    segments2[0].handleIn = segments1[1].handleIn;
+                    segments1.pop();
+                }
             }
             else {
-                segments2[0].handleIn = segments1[1].handleIn;
-                segments1.pop();
+                var second1 = curve1.divideAt(intersection[0]);
+                if (second1) {
+                    var join_2 = second1.segment1;
+                    var second2 = curve2.divideAt(curve2.getIntersections(curve1)[0]);
+                    join_2.handleOut = second2 ? second2.segment1.handleOut : segments2[0].handleOut;
+                    segments1.pop();
+                    segments2[0] = join_2;
+                }
+                else {
+                    segments2[0].handleIn = segments1[1].handleIn;
+                    segments1.pop();
+                }
             }
         }
     }
-}
-/**
- * Connect all the segments together.
- */
-function connectBeziers(rawSegments, join, source, offset, limit) {
-    var originSegments = source.segments;
-    var first = rawSegments[0].slice();
-    for (var i = 0; i < rawSegments.length - 1; ++i) {
-        connectAdjacentBezier(rawSegments[i], rawSegments[i + 1], originSegments[i + 1], join, offset, limit);
-    }
-    if (source.closed) {
-        connectAdjacentBezier(rawSegments[rawSegments.length - 1], first, originSegments[0], join, offset, limit);
-        rawSegments[0][0] = first[0];
-    }
-    return rawSegments;
-}
-function reduceSingleChildCompoundPath(path) {
-    if (path.children.length === 1) {
-        path = path.children[0];
-        path.remove(); // remove from parent, this is critical, or the style attributes will be ignored
+    Offsets.ConnectAdjacentBezier = ConnectAdjacentBezier;
+    /**
+     * Connect all the segments together.
+     */
+    function ConnectBeziers(rawSegments, join, source, offset, limit) {
+        var originSegments = source.segments;
+        var first = rawSegments[0].slice();
+        for (var i = 0; i < rawSegments.length - 1; ++i) {
+            ConnectAdjacentBezier(rawSegments[i], rawSegments[i + 1], originSegments[i + 1], join, offset, limit);
+        }
+        if (source.closed) {
+            ConnectAdjacentBezier(rawSegments[rawSegments.length - 1], first, originSegments[0], join, offset, limit);
+            rawSegments[0][0] = first[0];
+        }
+        return rawSegments;
     }
-    return path;
-}
-/** Normalize a path, always clockwise, non-self-intersection, ignore really small components, and no one-component compound path. */
-function normalize(path, areaThreshold) {
-    if (areaThreshold === void 0) { areaThreshold = 0.01; }
-    if (path.closed) {
-        var ignoreArea_1 = Math.abs(path.area * areaThreshold);
-        if (!path.clockwise) {
-            path.reverse();
+    function Decompound(path) {
+        if (path.children.length === 1) {
+            path = path.children[0];
+            path.remove(); // remove from parent, this is critical, or the style attributes will be ignored
         }
-        path = path.unite(path, { insert: false });
-        if (path instanceof paper.CompoundPath) {
-            path.children.filter(function (c) { return Math.abs(c.area) < ignoreArea_1; }).forEach(function (c) { return c.remove(); });
-            if (path.children.length === 1) {
-                return reduceSingleChildCompoundPath(path);
+        return path;
+    }
+    /** Normalize a path, always clockwise, non-self-intersection, ignore really small components, and no one-component compound path. */
+    function Normalize(path, areaThreshold) {
+        if (areaThreshold === void 0) { areaThreshold = 0.01; }
+        if (path.closed) {
+            var ignoreArea_1 = Math.abs(path.area * areaThreshold);
+            if (!path.clockwise) {
+                path.reverse();
+            }
+            path = path.unite(path, { insert: false });
+            if (path instanceof paper.CompoundPath) {
+                path.children.filter(function (c) { return Math.abs(c.area) < ignoreArea_1; }).forEach(function (c) { return c.remove(); });
+                if (path.children.length === 1) {
+                    return Decompound(path);
+                }
             }
         }
+        return path;
     }
-    return path;
-}
-function isSameDirection(partialPath, fullPath) {
-    var offset1 = partialPath.segments[0].location.offset;
-    var offset2 = partialPath.segments[Math.max(1, Math.floor(partialPath.segments.length / 2))].location.offset;
-    var sampleOffset = (offset1 + offset2) / 3;
-    var originOffset1 = fullPath.getNearestLocation(partialPath.getPointAt(sampleOffset)).offset;
-    var originOffset2 = fullPath.getNearestLocation(partialPath.getPointAt(2 * sampleOffset)).offset;
-    return originOffset1 < originOffset2;
-}
-/** Remove self intersection when offset is negative by point direction dectection. */
-function removeIntersection(path) {
-    if (path.closed) {
+    Offsets.Normalize = Normalize;
+    function IsSameDirection(partialPath, fullPath) {
+        var offset1 = partialPath.segments[0].location.offset;
+        var offset2 = partialPath.segments[Math.max(1, Math.floor(partialPath.segments.length / 2))].location.offset;
+        var sampleOffset = (offset1 + offset2) / 3;
+        var originOffset1 = fullPath.getNearestLocation(partialPath.getPointAt(sampleOffset)).offset;
+        var originOffset2 = fullPath.getNearestLocation(partialPath.getPointAt(2 * sampleOffset)).offset;
+        return originOffset1 < originOffset2;
+    }
+    Offsets.IsSameDirection = IsSameDirection;
+    /** Remove self intersection when offset is negative by point direction dectection. */
+    function RemoveIntersection(path) {
         var newPath = path.unite(path, { insert: false });
         if (newPath instanceof paper.CompoundPath) {
             newPath.children.filter(function (c) {
                 if (c.segments.length > 1) {
-                    return !isSameDirection(c, path);
+                    return !IsSameDirection(c, path);
                 }
                 else {
                     return true;
                 }
             }).forEach(function (c) { return c.remove(); });
-            return reduceSingleChildCompoundPath(newPath);
+            return Decompound(newPath);
         }
+        return path;
     }
-    return path;
-}
-function getSegments(path) {
-    if (path instanceof paper.CompoundPath) {
-        return path.children.map(function (c) { return c.segments; }).flat();
-    }
-    else {
-        return path.segments;
-    }
-}
-/**
- * Remove impossible segments in negative offset condition.
- */
-function removeOutsiders(newPath, path) {
-    var segments = getSegments(newPath).slice();
-    segments.forEach(function (segment) {
-        if (!path.contains(segment.point)) {
-            segment.remove();
+    Offsets.RemoveIntersection = RemoveIntersection;
+    function Segments(path) {
+        if (path instanceof paper.CompoundPath) {
+            return Arrayex.Flat(path.children.map(function (c) { return c.segments; }));
+        }
+        else {
+            return path.segments;
         }
-    });
-}
-function preparePath(path, offset) {
-    var source = path.clone({ insert: false });
-    source.reduce({});
-    if (!path.clockwise) {
-        source.reverse();
-        offset = -offset;
-    }
-    return [source, offset];
-}
-function offsetSimpleShape(path, offset, join, limit) {
-    var _a;
-    var source;
-    _a = preparePath(path, offset), source = _a[0], offset = _a[1];
-    var curves = source.curves.slice();
-    var offsetCurves = curves.map(function (curve) { return adaptiveOffsetCurve(curve, offset); }).flat();
-    var raws = [];
-    for (var i = 0; i < offsetCurves.length; i += 2) {
-        raws.push(offsetCurves.slice(i, i + 2));
     }
-    var segments = connectBeziers(raws, join, source, offset, limit).flat();
-    var newPath = removeIntersection(new paper.Path({ segments: segments, insert: false, closed: path.closed }));
-    newPath.reduce({});
-    if (source.closed && ((source.clockwise && offset < 0) || (!source.clockwise && offset > 0))) {
-        removeOutsiders(newPath, path);
+    /**
+     * Remove impossible segments in negative offset condition.
+     */
+    function RemoveOutsiders(offsetPath, path) {
+        var segments = Segments(offsetPath).slice();
+        segments.forEach(function (segment) {
+            if (!path.contains(segment.point)) {
+                segment.remove();
+            }
+        });
     }
-    // recovery path
-    if (source.clockwise !== path.clockwise) {
-        newPath.reverse();
+    function PreparePath(path, offset) {
+        var source = path.clone({ insert: false });
+        source.reduce();
+        if (!path.clockwise) {
+            source.reverse();
+            offset = -offset;
+        }
+        return [source, offset];
     }
-    return normalize(newPath);
-}
-function makeRoundCap(from, to, offset) {
-    var origin = from.point.add(to.point).divide(2);
-    var normal = to.point.subtract(from.point).rotate(-90, new paper.Point(0, 0)).normalize(offset);
-    var through = origin.add(normal);
-    var arc = new paper.Path.Arc({ from: from.point, to: to.point, through: through, insert: false });
-    return arc.segments;
-}
-function connectSide(outer, inner, offset, cap) {
-    if (outer instanceof paper.CompoundPath) {
-        var cs = outer.children.map(function (c) { return ({ c: c, a: Math.abs(c.area) }); });
-        cs = cs.sort(function (c1, c2) { return c2.a - c1.a; });
-        outer = cs[0].c;
+    function OffsetSimpleShape(path, offset, join, limit) {
+        var _a;
+        var source;
+        _a = PreparePath(path, offset), source = _a[0], offset = _a[1];
+        var curves = source.curves.slice();
+        var raws = Arrayex.Divide(Arrayex.Flat(curves.map(function (curve) { return AdaptiveOffsetCurve(curve, offset); })), 2);
+        var segments = Arrayex.Flat(ConnectBeziers(raws, join, source, offset, limit));
+        var offsetPath = RemoveIntersection(new paper.Path({ segments: segments, insert: false, closed: path.closed }));
+        offsetPath.reduce();
+        if (source.closed && ((source.clockwise && offset < 0) || (!source.clockwise && offset > 0))) {
+            RemoveOutsiders(offsetPath, path);
+        }
+        // recovery path
+        if (source.clockwise !== path.clockwise) {
+            offsetPath.reverse();
+        }
+        return Normalize(offsetPath);
     }
-    var oSegments = outer.segments.slice();
-    var iSegments = inner.segments.slice();
-    switch (cap) {
-        case 'round':
-            var heads = makeRoundCap(iSegments[iSegments.length - 1], oSegments[0], offset);
-            var tails = makeRoundCap(oSegments[oSegments.length - 1], iSegments[0], offset);
-            var result = new paper.Path({ segments: heads.concat(oSegments, tails, iSegments), closed: true, insert: false });
-            result.reduce({});
-            return result;
-        default: return new paper.Path({ segments: oSegments.concat(iSegments), closed: true, insert: false });
+    Offsets.OffsetSimpleShape = OffsetSimpleShape;
+    function MakeRoundCap(from, to, offset) {
+        var origin = from.point.add(to.point).divide(2);
+        var normal = to.point.subtract(from.point).rotate(-90).normalize(offset);
+        var through = origin.add(normal);
+        var arc = new paper.Path.Arc({ from: from.point, to: to.point, through: through, insert: false });
+        return arc.segments;
     }
-}
-function offsetSimpleStroke(path, offset, join, cap, limit) {
-    offset = path.clockwise ? offset : -offset;
-    var positiveOffset = offsetSimpleShape(path, offset, join, limit);
-    var negativeOffset = offsetSimpleShape(path, -offset, join, limit);
-    if (path.closed) {
-        return positiveOffset.subtract(negativeOffset, { insert: false });
+    function ConnectSide(outer, inner, offset, cap) {
+        if (outer instanceof paper.CompoundPath) {
+            var cs = outer.children.map(function (c) { return ({ c: c, a: Math.abs(c.area) }); });
+            cs = cs.sort(function (c1, c2) { return c2.a - c1.a; });
+            outer = cs[0].c;
+        }
+        var oSegments = outer.segments.slice();
+        var iSegments = inner.segments.slice();
+        switch (cap) {
+            case 'round':
+                var heads = MakeRoundCap(iSegments[iSegments.length - 1], oSegments[0], offset);
+                var tails = MakeRoundCap(oSegments[oSegments.length - 1], iSegments[0], offset);
+                var result = new paper.Path({ segments: heads.concat(oSegments, tails, iSegments), closed: true, insert: false });
+                result.reduce();
+                return result;
+            default: return new paper.Path({ segments: oSegments.concat(iSegments), closed: true, insert: false });
+        }
     }
-    else {
-        var inner = negativeOffset;
-        var holes = new Array();
-        if (negativeOffset instanceof paper.CompoundPath) {
-            holes = negativeOffset.children.filter(function (c) { return c.closed; });
-            holes.forEach(function (h) { return h.remove(); });
-            inner = negativeOffset.children[0];
+    function OffsetSimpleStroke(path, offset, join, cap, limit) {
+        offset = path.clockwise ? offset : -offset;
+        var positiveOffset = OffsetSimpleShape(path, offset, join, limit);
+        var negativeOffset = OffsetSimpleShape(path, -offset, join, limit);
+        if (path.closed) {
+            return positiveOffset.subtract(negativeOffset, { insert: false });
         }
-        inner.reverse();
-        var final = connectSide(positiveOffset, inner, offset, cap);
-        if (holes.length > 0) {
-            for (var _i = 0, holes_1 = holes; _i < holes_1.length; _i++) {
-                var hole = holes_1[_i];
-                final = final.subtract(hole, { insert: false });
+        else {
+            var inner = negativeOffset;
+            var holes = new Array();
+            if (negativeOffset instanceof paper.CompoundPath) {
+                holes = negativeOffset.children.filter(function (c) { return c.closed; });
+                holes.forEach(function (h) { return h.remove(); });
+                inner = negativeOffset.children[0];
+            }
+            inner.reverse();
+            var final = ConnectSide(positiveOffset, inner, offset, cap);
+            if (holes.length > 0) {
+                for (var _i = 0, holes_1 = holes; _i < holes_1.length; _i++) {
+                    var hole = holes_1[_i];
+                    final = final.subtract(hole, { insert: false });
+                }
             }
+            return final;
         }
-        return final;
-    }
-}
-function getNonSelfItersectionPath(path) {
-    if (path.closed) {
-        return path.unite(path, { insert: false });
     }
-    return path;
-}
-function offsetPath(path, offset, join, limit) {
-    var nonSIPath = getNonSelfItersectionPath(path);
+    Offsets.OffsetSimpleStroke = OffsetSimpleStroke;
+})(Offsets || (Offsets = {}));
+function OffsetPath(path, offset, join, limit) {
+    var nonSIPath = path.unite(path, { insert: false });
     var result = nonSIPath;
     if (nonSIPath instanceof paper.Path) {
-        result = offsetSimpleShape(nonSIPath, offset, join, limit);
+        result = Offsets.OffsetSimpleShape(nonSIPath, offset, join, limit);
     }
     else {
-        var offsetParts = nonSIPath.children.map(function (c) {
+        var children = Arrayex.Flat(nonSIPath.children.map(function (c) {
             if (c.segments.length > 1) {
-                if (!isSameDirection(c, path)) {
+                if (!Offsets.IsSameDirection(c, path)) {
                     c.reverse();
                 }
-                var offseted = offsetSimpleShape(c, offset, join, limit);
-                offseted = normalize(offseted);
+                var offseted = Offsets.OffsetSimpleShape(c, offset, join, limit);
+                offseted = Offsets.Normalize(offseted);
                 if (offseted.clockwise !== c.clockwise) {
                     offseted.reverse();
                 }
@@ -325,24 +322,23 @@ function offsetPath(path, offset, join, limit) {
             else {
                 return null;
             }
-        });
-        var children = offsetParts.flat().filter(function (c) { return !!c; });
+        }), false);
         result = new paper.CompoundPath({ children: children, insert: false });
     }
     result.copyAttributes(nonSIPath, false);
     result.remove();
     return result;
 }
-function offsetStroke(path, offset, join, cap, limit) {
-    var nonSIPath = getNonSelfItersectionPath(path);
+function OffsetStroke(path, offset, join, cap, limit) {
+    var nonSIPath = path.unite(path, { insert: false });
     var result = nonSIPath;
     if (nonSIPath instanceof paper.Path) {
-        result = offsetSimpleStroke(nonSIPath, offset, join, cap, limit);
+        result = Offsets.OffsetSimpleStroke(nonSIPath, offset, join, cap, limit);
     }
     else {
-        var children = nonSIPath.children.flatMap(function (c) {
-            return offsetSimpleStroke(c, offset, join, cap, limit);
-        });
+        var children = Arrayex.Flat(nonSIPath.children.map(function (c) {
+            return Offsets.OffsetSimpleStroke(c, offset, join, cap, limit);
+        }));
         result = children.reduce(function (c1, c2) { return c1.unite(c2, { insert: false }); });
     }
     result.strokeWidth = 0;
@@ -353,51 +349,42 @@ function offsetStroke(path, offset, join, cap, limit) {
     return result;
 }
 
-var PaperOffset = /** @class */ (function () {
-    function PaperOffset() {
+function PrototypedOffset(path, offset, options) {
+    options = options || {};
+    var offsetPath = OffsetPath(path, offset, options.join || 'miter', options.limit || 10);
+    if (options.insert === undefined) {
+        options.insert = true;
     }
-    PaperOffset.offset = function (path, offset, options) {
-        options = options || {};
-        var newPath = offsetPath(path, offset, options.join || 'miter', options.limit || 10);
-        if (options.insert === undefined) {
-            options.insert = true;
-        }
-        if (options.insert) {
-            (path.parent || paper.project.activeLayer).addChild(newPath);
-        }
-        return newPath;
-    };
-    PaperOffset.offsetStroke = function (path, offset, options) {
-        options = options || {};
-        var newPath = offsetStroke(path, offset, options.join || 'miter', options.cap || 'butt', options.limit || 10);
-        if (options.insert === undefined) {
-            options.insert = true;
-        }
-        if (options.insert) {
-            (path.parent || paper.project.activeLayer).addChild(newPath);
-        }
-        return newPath;
-    };
-    return PaperOffset;
-}());
-/**
- * @deprecated EXTEND existing paper module is not recommend anymore
- */
-function ExtendPaperJs(paperNs) {
-    paperNs.Path.prototype.offset = function (offset, options) {
-        return PaperOffset.offset(this, offset, options);
+    if (options.insert) {
+        (path.parent || paper.project.activeLayer).addChild(offsetPath);
+    }
+    return offsetPath;
+}
+function PrototypedOffsetStroke(path, offset, options) {
+    options = options || {};
+    var offsetPath = OffsetStroke(path, offset, options.join || 'miter', options.cap || 'butt', options.limit || 10);
+    if (options.insert === undefined) {
+        options.insert = true;
+    }
+    if (options.insert) {
+        (path.parent || paper.project.activeLayer).addChild(offsetPath);
+    }
+    return offsetPath;
+}
+function ExtendPaperJs(paper) {
+    paper.Path.prototype.offset = function (offset, options) {
+        return PrototypedOffset(this, offset, options);
     };
-    paperNs.Path.prototype.offsetStroke = function (offset, options) {
-        return PaperOffset.offsetStroke(this, offset, options);
+    paper.Path.prototype.offsetStroke = function (offset, options) {
+        return PrototypedOffsetStroke(this, offset, options);
     };
-    paperNs.CompoundPath.prototype.offset = function (offset, options) {
-        return PaperOffset.offset(this, offset, options);
+    paper.CompoundPath.prototype.offset = function (offset, options) {
+        return PrototypedOffset(this, offset, options);
     };
-    paperNs.CompoundPath.prototype.offsetStroke = function (offset, options) {
-        return PaperOffset.offsetStroke(this, offset, options);
+    paper.CompoundPath.prototype.offsetStroke = function (offset, options) {
+        return PrototypedOffsetStroke(this, offset, options);
     };
 }
 
 export default ExtendPaperJs;
-export { PaperOffset };
 //# sourceMappingURL=index.es5.js.map
diff --git a/node_modules/paperjs-offset/dist/index.es5.js.map b/node_modules/paperjs-offset/dist/index.es5.js.map
index 786a1ed..d37628c 100644
--- a/node_modules/paperjs-offset/dist/index.es5.js.map
+++ b/node_modules/paperjs-offset/dist/index.es5.js.map
@@ -1 +1 @@
-{"version":3,"file":"index.es5.js","sources":["../src/offset_core.ts","../src/index.ts"],"sourcesContent":["import paper from 'paper';\n\nexport type StrokeJoinType = 'miter' | 'bevel' | 'round';\nexport type StrokeCapType = 'round' | 'butt';\nexport type PathType = paper.Path | paper.CompoundPath;\n\ntype HandleType = 'handleIn' | 'handleOut';\n\n/**\n * Offset the start/terminal segment of a bezier curve\n * @param segment segment to offset\n * @param curve curve to offset\n * @param handleNormal the normal of the the line formed of two handles\n * @param offset offset value\n */\nfunction offsetSegment(segment: paper.Segment, curve: paper.Curve, handleNormal: paper.Point, offset: number) {\n  const isFirst = segment.curve === curve;\n  // get offset vector\n  const offsetVector = (curve.getNormalAtTime(isFirst ? 0 : 1)).multiply(offset);\n  // get offset point\n  const point = segment.point.add(offsetVector);\n  const newSegment = new paper.Segment(point);\n  // handleOut for start segment & handleIn for terminal segment\n  const handle = (isFirst ? 'handleOut' : 'handleIn') as HandleType;\n  newSegment[handle] = segment[handle]!.add(handleNormal.subtract(offsetVector).divide(2));\n  return newSegment;\n}\n\n/**\n * Adaptive offset a curve by repeatly apply the approximation proposed by Tiller and Hanson.\n * @param curve curve to offset\n * @param offset offset value\n */\nfunction adaptiveOffsetCurve(curve: paper.Curve, offset: number): paper.Segment[] {\n  const hNormal = (new paper.Curve(curve.segment1.handleOut!.add(curve.segment1.point), new paper.Point(0, 0),\n    new paper.Point(0, 0), curve.segment2.handleIn!.add(curve.segment2.point))).getNormalAtTime(0.5).multiply(offset);\n  const segment1 = offsetSegment(curve.segment1, curve, hNormal, offset);\n  const segment2 = offsetSegment(curve.segment2, curve, hNormal, offset);\n  // divide && re-offset\n  const offsetCurve = new paper.Curve(segment1, segment2);\n  // if the offset curve is not self intersected, divide it\n  if (offsetCurve.getIntersections(offsetCurve).length === 0) {\n    const threshold = Math.min(Math.abs(offset) / 10, 1);\n    const midOffset = offsetCurve.getPointAtTime(0.5).getDistance(curve.getPointAtTime(0.5));\n    if (Math.abs(midOffset - Math.abs(offset)) > threshold) {\n      const subCurve = curve.divideAtTime(0.5);\n      if (subCurve != null) {\n        return [...adaptiveOffsetCurve(curve, offset), ...adaptiveOffsetCurve(subCurve, offset)];\n      }\n    }\n  }\n  return [segment1, segment2];\n}\n\n/**\n * Create a round join segment between two adjacent segments.\n */\nfunction makeRoundJoin(segment1: paper.Segment, segment2: paper.Segment, originPoint: paper.Point, radius: number) {\n  const through = segment1.point.subtract(originPoint).add(segment2.point.subtract(originPoint))\n    .normalize(Math.abs(radius)).add(originPoint);\n  const arc = new paper.Path.Arc({ from: segment1.point, to: segment2.point, through, insert: false });\n  segment1.handleOut = arc.firstSegment.handleOut;\n  segment2.handleIn = arc.lastSegment.handleIn;\n  return arc.segments.length === 3 ? arc.segments[1] : null;\n}\n\nfunction det(p1: paper.Point, p2: paper.Point) {\n  return p1.x * p2.y - p1.y * p2.x;\n}\n\n/**\n * Get the intersection point of point based lines\n */\nfunction getPointLineIntersections(p1: paper.Point, p2: paper.Point, p3: paper.Point, p4: paper.Point) {\n  const l1 = p1.subtract(p2);\n  const l2 = p3.subtract(p4);\n  const dl1 = det(p1, p2);\n  const dl2 = det(p3, p4);\n  return new paper.Point(dl1 * l2.x - l1.x * dl2, dl1 * l2.y - l1.y * dl2).divide(det(l1, l2));\n}\n\n/**\n * Connect two adjacent bezier curve, each curve is represented by two segments,\n * create different types of joins or simply removal redundant segment.\n */\nfunction connectAdjacentBezier(segments1: paper.Segment[], segments2: paper.Segment[], origin: paper.Segment, joinType: StrokeJoinType, offset: number, limit: number) {\n  const curve1 = new paper.Curve(segments1[0], segments1[1]);\n  const curve2 = new paper.Curve(segments2[0], segments2[1]);\n  const intersection = curve1.getIntersections(curve2);\n  const distance = segments1[1].point.getDistance(segments2[0].point);\n  if (origin.isSmooth()) {\n    segments2[0].handleOut = segments2[0].handleOut!.project(origin.handleOut!);\n    segments2[0].handleIn = segments1[1].handleIn!.project(origin.handleIn!);\n    segments2[0].point = segments1[1].point.add(segments2[0].point).divide(2);\n    segments1.pop();\n  } else {\n    if (intersection.length === 0) {\n      if (distance > Math.abs(offset) * 0.1) {\n        // connect\n        switch (joinType) {\n          case 'miter':\n            const join = getPointLineIntersections(curve1.point2, curve1.point2.add(curve1.getTangentAtTime(1)),\n              curve2.point1, curve2.point1.add(curve2.getTangentAtTime(0)));\n            // prevent sharp angle\n            const joinOffset = Math.max(join.getDistance(curve1.point2), join.getDistance(curve2.point1));\n            if (joinOffset < Math.abs(offset) * limit) {\n              segments1.push(new paper.Segment(join));\n            }\n            break;\n          case 'round':\n            const mid = makeRoundJoin(segments1[1], segments2[0], origin.point, offset);\n            if (mid) {\n              segments1.push(mid);\n            }\n            break;\n          default: break;\n        }\n      } else {\n        segments2[0].handleIn = segments1[1].handleIn;\n        segments1.pop();\n      }\n    } else {\n      const second1 = curve1.divideAt(intersection[0]);\n      if (second1) {\n        const join = second1.segment1;\n        const second2 = curve2.divideAt(curve2.getIntersections(curve1)[0]);\n        join.handleOut = second2 ? second2.segment1.handleOut : segments2[0].handleOut;\n        segments1.pop();\n        segments2[0] = join;\n      } else {\n        segments2[0].handleIn = segments1[1].handleIn;\n        segments1.pop();\n      }\n    }\n  }\n}\n\n/**\n * Connect all the segments together.\n */\nfunction connectBeziers(rawSegments: paper.Segment[][], join: StrokeJoinType, source: paper.Path, offset: number, limit: number) {\n  const originSegments = source.segments;\n  const first = rawSegments[0].slice();\n  for (let i = 0; i < rawSegments.length - 1; ++i) {\n    connectAdjacentBezier(rawSegments[i], rawSegments[i + 1], originSegments[i + 1], join, offset, limit);\n  }\n  if (source.closed) {\n    connectAdjacentBezier(rawSegments[rawSegments.length - 1], first, originSegments[0], join, offset, limit);\n    rawSegments[0][0] = first[0];\n  }\n  return rawSegments;\n}\n\nfunction reduceSingleChildCompoundPath(path: PathType) {\n  if (path.children.length === 1) {\n    path = path.children[0] as paper.Path;\n    path.remove(); // remove from parent, this is critical, or the style attributes will be ignored\n  }\n  return path;\n}\n\n/** Normalize a path, always clockwise, non-self-intersection, ignore really small components, and no one-component compound path. */\nfunction normalize(path: PathType, areaThreshold = 0.01) {\n  if (path.closed) {\n    const ignoreArea = Math.abs(path.area * areaThreshold);\n    if (!path.clockwise) {\n      path.reverse();\n    }\n    path = path.unite(path, { insert: false }) as PathType;\n    if (path instanceof paper.CompoundPath) {\n      path.children.filter((c) => Math.abs((c as PathType).area) < ignoreArea).forEach((c) => c.remove());\n      if (path.children.length === 1) {\n        return reduceSingleChildCompoundPath(path);\n      }\n    }\n  }\n  return path;\n}\n\nfunction isSameDirection(partialPath: paper.Path, fullPath: PathType) {\n  const offset1 = partialPath.segments[0].location.offset;\n  const offset2 = partialPath.segments[Math.max(1, Math.floor(partialPath.segments.length / 2))].location.offset;\n  const sampleOffset = (offset1 + offset2) / 3;\n  const originOffset1 = fullPath.getNearestLocation(partialPath.getPointAt(sampleOffset)).offset;\n  const originOffset2 = fullPath.getNearestLocation(partialPath.getPointAt(2 * sampleOffset)).offset;\n  return originOffset1 < originOffset2;\n}\n\n/** Remove self intersection when offset is negative by point direction dectection. */\nfunction removeIntersection(path: PathType) {\n  if (path.closed) {\n    const newPath = path.unite(path, { insert: false }) as PathType;\n    if (newPath instanceof paper.CompoundPath) {\n      (newPath.children as paper.Path[]).filter((c) => {\n        if (c.segments.length > 1) {\n          return !isSameDirection(c, path);\n        } else {\n          return true;\n        }\n      }).forEach((c) => c.remove());\n      return reduceSingleChildCompoundPath(newPath);\n    }\n  }\n  return path;\n}\n\nfunction getSegments(path: PathType) {\n  if (path instanceof paper.CompoundPath) {\n    return path.children.map((c) => (c as paper.Path).segments).flat();\n  } else {\n    return (path as paper.Path).segments;\n  }\n}\n\n/**\n * Remove impossible segments in negative offset condition.\n */\nfunction removeOutsiders(newPath: PathType, path: PathType) {\n  const segments = getSegments(newPath).slice();\n  segments.forEach((segment) => {\n    if (!path.contains(segment.point)) {\n      segment.remove();\n    }\n  });\n}\n\nfunction preparePath(path: paper.Path, offset: number): [paper.Path, number] {\n  const source = path.clone({ insert: false }) as paper.Path;\n  source.reduce({});\n  if (!path.clockwise) {\n    source.reverse();\n    offset = -offset;\n  }\n  return [source, offset];\n}\n\nfunction offsetSimpleShape(path: paper.Path, offset: number, join: StrokeJoinType, limit: number): PathType {\n  let source: paper.Path;\n  [source, offset] = preparePath(path, offset);\n  const curves = source.curves.slice();\n  const offsetCurves = curves.map((curve) => adaptiveOffsetCurve(curve, offset)).flat();\n  const raws: paper.Segment[][] = [];\n  for (let i = 0; i < offsetCurves.length; i += 2) {\n    raws.push(offsetCurves.slice(i, i + 2));\n  }\n  const segments = connectBeziers(raws, join, source, offset, limit).flat();\n  const newPath = removeIntersection(new paper.Path({ segments, insert: false, closed: path.closed }));\n  newPath.reduce({});\n  if (source.closed && ((source.clockwise && offset < 0) || (!source.clockwise && offset > 0))) {\n    removeOutsiders(newPath, path);\n  }\n  // recovery path\n  if (source.clockwise !== path.clockwise) {\n    newPath.reverse();\n  }\n  return normalize(newPath);\n}\n\nfunction makeRoundCap(from: paper.Segment, to: paper.Segment, offset: number) {\n  const origin = from.point.add(to.point).divide(2);\n  const normal = to.point.subtract(from.point).rotate(-90, new paper.Point(0, 0)).normalize(offset);\n  const through = origin.add(normal);\n  const arc = new paper.Path.Arc({ from: from.point, to: to.point, through, insert: false });\n  return arc.segments;\n}\n\nfunction connectSide(outer: PathType, inner: paper.Path, offset: number, cap: StrokeCapType): paper.Path {\n  if (outer instanceof paper.CompoundPath) {\n    let cs = outer.children.map((c) => ({ c, a: Math.abs((c as paper.Path).area) }));\n    cs = cs.sort((c1, c2) => c2.a - c1.a);\n    outer = cs[0].c as paper.Path;\n  }\n  const oSegments = (outer as paper.Path).segments.slice();\n  const iSegments = inner.segments.slice();\n  switch (cap) {\n    case 'round':\n      const heads = makeRoundCap(iSegments[iSegments.length - 1], oSegments[0], offset);\n      const tails = makeRoundCap(oSegments[oSegments.length - 1], iSegments[0], offset);\n      const result = new paper.Path({ segments: [...heads, ...oSegments, ...tails, ...iSegments], closed: true, insert: false });\n      result.reduce({});\n      return result;\n    default: return new paper.Path({ segments: [...oSegments, ...iSegments], closed: true, insert: false });\n  }\n}\n\nfunction offsetSimpleStroke(path: paper.Path, offset: number, join: StrokeJoinType, cap: StrokeCapType, limit: number): PathType {\n  offset = path.clockwise ? offset : -offset;\n  const positiveOffset = offsetSimpleShape(path, offset, join, limit);\n  const negativeOffset = offsetSimpleShape(path, -offset, join, limit);\n  if (path.closed) {\n    return positiveOffset.subtract(negativeOffset, { insert: false }) as PathType;\n  } else {\n    let inner = negativeOffset;\n    let holes = new Array<paper.Path>();\n    if (negativeOffset instanceof paper.CompoundPath) {\n      holes = negativeOffset.children.filter((c) => (c as paper.Path).closed) as paper.Path[];\n      holes.forEach((h) => h.remove());\n      inner = negativeOffset.children[0] as paper.Path;\n    }\n    inner.reverse();\n    let final = connectSide(positiveOffset, inner as paper.Path, offset, cap) as PathType;\n    if (holes.length > 0) {\n      for (const hole of holes) {\n        final = final.subtract(hole, { insert: false }) as PathType;\n      }\n    }\n    return final;\n  }\n}\n\nfunction getNonSelfItersectionPath(path: PathType) {\n  if (path.closed) {\n    return path.unite(path, { insert: false }) as PathType;\n  }\n  return path;\n}\n\nexport function offsetPath(path: PathType, offset: number, join: StrokeJoinType, limit: number): PathType {\n  const nonSIPath = getNonSelfItersectionPath(path);\n  let result = nonSIPath;\n  if (nonSIPath instanceof paper.Path) {\n    result = offsetSimpleShape(nonSIPath, offset, join, limit);\n  } else {\n    const offsetParts = (nonSIPath.children as paper.Path[]).map((c) => {\n      if (c.segments.length > 1) {\n        if (!isSameDirection(c, path)) {\n          c.reverse();\n        }\n        let offseted = offsetSimpleShape(c, offset, join, limit);\n        offseted = normalize(offseted);\n        if (offseted.clockwise !== c.clockwise) {\n          offseted.reverse();\n        }\n        if (offseted instanceof paper.CompoundPath) {\n          offseted.applyMatrix = true;\n          return offseted.children;\n        } else {\n          return offseted;\n        }\n      } else {\n        return null;\n      }\n    });\n    const children = offsetParts.flat().filter((c) => !!c) as paper.Item[];\n    result = new paper.CompoundPath({ children, insert: false });\n  }\n  result.copyAttributes(nonSIPath, false);\n  result.remove();\n  return result;\n}\n\nexport function offsetStroke(path: PathType, offset: number, join: StrokeJoinType, cap: StrokeCapType, limit: number): PathType {\n  const nonSIPath = getNonSelfItersectionPath(path);\n  let result = nonSIPath;\n  if (nonSIPath instanceof paper.Path) {\n    result = offsetSimpleStroke(nonSIPath, offset, join, cap, limit);\n  } else {\n    const children = (nonSIPath.children as paper.Path[]).flatMap((c) => {\n      return offsetSimpleStroke(c, offset, join, cap, limit);\n    });\n    result = children.reduce((c1, c2) => c1.unite(c2, { insert: false }) as PathType);\n  }\n  result.strokeWidth = 0;\n  result.fillColor = nonSIPath.strokeColor;\n  result.shadowBlur = nonSIPath.shadowBlur;\n  result.shadowColor = nonSIPath.shadowColor;\n  result.shadowOffset = nonSIPath.shadowOffset;\n  return result;\n}\n","import paper from 'paper';\nimport { StrokeJoinType, PathType, StrokeCapType, offsetPath, offsetStroke } from './offset_core';\n\nexport interface OffsetOptions {\n  join?: StrokeJoinType;\n  cap?: StrokeCapType;\n  limit?: number;\n  insert?: boolean;\n}\n\nexport class PaperOffset {\n  public static offset(path: PathType, offset: number, options?: OffsetOptions): PathType {\n    options = options || {};\n    const newPath = offsetPath(path, offset, options.join || 'miter', options.limit || 10);\n    if (options.insert === undefined) {\n      options.insert = true;\n    }\n    if (options.insert) {\n      (path.parent || paper.project.activeLayer).addChild(newPath);\n    }\n    return newPath;\n  }\n\n  public static offsetStroke(path: PathType, offset: number, options?: OffsetOptions): PathType {\n    options = options || {};\n    const newPath = offsetStroke(path, offset, options.join || 'miter', options.cap || 'butt', options.limit || 10);\n    if (options.insert === undefined) {\n      options.insert = true;\n    }\n    if (options.insert) {\n      (path.parent || paper.project.activeLayer).addChild(newPath);\n    }\n    return newPath;\n  }\n}\n\n/**\n * @deprecated EXTEND existing paper module is not recommend anymore\n */\nexport default function ExtendPaperJs(paperNs: any) {\n  paperNs.Path.prototype.offset = function(offset: number, options?: OffsetOptions) {\n    return PaperOffset.offset(this, offset, options);\n  };\n\n  paperNs.Path.prototype.offsetStroke = function(offset: number, options?: OffsetOptions) {\n    return PaperOffset.offsetStroke(this, offset, options);\n  };\n\n  paperNs.CompoundPath.prototype.offset = function(offset: number, options?: OffsetOptions) {\n    return PaperOffset.offset(this, offset, options);\n  };\n\n  paperNs.CompoundPath.prototype.offsetStroke = function(offset: number, options?: OffsetOptions) {\n    return PaperOffset.offsetStroke(this, offset, options);\n  };\n}\n"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"index.es5.js","sources":["../src/Offset.ts","../src/index.ts"],"sourcesContent":["import paper, { Point } from 'paper'\nimport { Arrayex } from 'arrayex'\n\ntype HandleType = 'handleIn' | 'handleOut'\nexport type StrokeJoinType = 'miter' | 'bevel' | 'round'\nexport type StrokeCapType = 'round' | 'butt'\nexport type PathType = paper.Path | paper.CompoundPath\n\nnamespace Offsets {\n  /**\n   * Offset the start/terminal segment of a bezier curve\n   * @param segment segment to offset\n   * @param curve curve to offset\n   * @param handleNormal the normal of the the line formed of two handles\n   * @param offset offset value\n   */\n  function OffsetSegment(segment: paper.Segment, curve: paper.Curve, handleNormal: paper.Point, offset: number) {\n    let isFirst = segment.curve === curve\n    // get offset vector\n    let offsetVector = (curve.getNormalAt(isFirst ? 0 : 1, true)).multiply(offset)\n    // get offset point\n    let point = segment.point.add(offsetVector)\n    let newSegment = new paper.Segment(point)\n    // handleOut for start segment & handleIn for terminal segment\n    let handle = (isFirst ? 'handleOut' : 'handleIn') as HandleType\n    newSegment[handle] = segment[handle]!.add(handleNormal.subtract(offsetVector).divide(2))\n    return newSegment\n  }\n\n  /**\n   * Adaptive offset a curve by repeatly apply the approximation proposed by Tiller and Hanson.\n   * @param curve curve to offset\n   * @param offset offset value\n   */\n  function AdaptiveOffsetCurve(curve: paper.Curve, offset: number): Array<paper.Segment> {\n    offset\n    let hNormal = (new paper.Curve(curve.segment1.handleOut!.add(curve.segment1.point), new paper.Point(0, 0), new paper.Point(0, 0), curve.segment2.handleIn!.add(curve.segment2.point))).getNormalAt(0.5, true).multiply(offset)\n    let segment1 = OffsetSegment(curve.segment1, curve, hNormal, offset)\n    let segment2 = OffsetSegment(curve.segment2, curve, hNormal, offset)\n    // divide && re-offset\n    let offsetCurve = new paper.Curve(segment1, segment2)\n    // if the offset curve is not self intersected, divide it\n    if (offsetCurve.getIntersections(offsetCurve).length === 0) {\n      let threshold = Math.min(Math.abs(offset) / 10, 1)\n      let midOffset = offsetCurve.getPointAt(0.5, true).getDistance(curve.getPointAt(0.5, true))\n      if (Math.abs(midOffset - Math.abs(offset)) > threshold) {\n        let subCurve = curve.divideAtTime(0.5)\n        if (subCurve != null) {\n          return [...AdaptiveOffsetCurve(curve, offset), ...AdaptiveOffsetCurve(subCurve, offset)]\n        }\n      }\n    }\n    return [segment1, segment2]\n  }\n\n  /**\n   * Create a round join segment between two adjacent segments.\n   */\n  function MakeRoundJoin(segment1: paper.Segment, segment2: paper.Segment, originPoint: paper.Point, radius: number) {\n    let through = segment1.point.subtract(originPoint).add(segment2.point.subtract(originPoint)).normalize(Math.abs(radius)).add(originPoint)\n    let arc = new paper.Path.Arc({ from: segment1.point, to: segment2.point, through, insert: false })\n    segment1.handleOut = arc.firstSegment.handleOut\n    segment2.handleIn = arc.lastSegment.handleIn\n    return arc.segments.length === 3 ? arc.segments[1] : null\n  }\n\n  function Det(p1: paper.Point, p2: paper.Point) {\n    return p1.x * p2.y - p1.y * p2.x\n  }\n\n  /**\n   * Get the intersection point of two point\n   */\n  function Intersection(p1: paper.Point, p2: paper.Point, p3: paper.Point, p4: paper.Point) {\n    let l1 = p1.subtract(p2)\n    let l2 = p3.subtract(p4)\n    let dl1 = Det(p1, p2)\n    let dl2 = Det(p3, p4)\n    return new paper.Point(dl1 * l2.x - l1.x * dl2, dl1 * l2.y - l1.y * dl2).divide(Det(l1, l2))\n  }\n\n  /**\n   * Connect two adjacent bezier curve, each curve is represented by two segments, create different types of joins or simply removal redundant segment.\n   */\n  export function ConnectAdjacentBezier(segments1: Array<paper.Segment>, segments2: Array<paper.Segment>, origin: paper.Segment, join: StrokeJoinType, offset: number, limit: number) {\n    let curve1 = new paper.Curve(segments1[0], segments1[1])\n    let curve2 = new paper.Curve(segments2[0], segments2[1])\n    let intersection = curve1.getIntersections(curve2)\n    let distance = segments1[1].point.getDistance(segments2[0].point)\n    if (origin.isSmooth()) {\n      segments2[0].handleOut = segments2[0].handleOut!.project(origin.handleOut!)\n      segments2[0].handleIn = segments1[1].handleIn!.project(origin.handleIn!)\n      segments2[0].point = segments1[1].point.add(segments2[0].point).divide(2)\n      segments1.pop()\n    } else {\n      if (intersection.length === 0) {\n        if (distance > Math.abs(offset) * 0.1) {\n          // connect\n          switch (join) {\n            case 'miter':\n              let join = Intersection(curve1.point2, curve1.point2.add(curve1.getTangentAt(1, true)), curve2.point1, curve2.point1.add(curve2.getTangentAt(0, true)))\n              // prevent sharp angle\n              let joinOffset = Math.max(join.getDistance(curve1.point2), join.getDistance(curve2.point1))\n              if (joinOffset < Math.abs(offset) * limit) {\n                segments1.push(new paper.Segment(join))\n              }\n              break\n            case 'round':\n              let mid = MakeRoundJoin(segments1[1], segments2[0], origin.point, offset)\n              if (mid) {\n                segments1.push(mid)\n              }\n              break\n            default: break\n          }\n        } else {\n          segments2[0].handleIn = segments1[1].handleIn\n          segments1.pop()\n        }\n      } else {\n        let second1 = curve1.divideAt(intersection[0])\n        if (second1) {\n          let join = second1.segment1\n          let second2 = curve2.divideAt(curve2.getIntersections(curve1)[0])\n          join.handleOut = second2 ? second2.segment1.handleOut : segments2[0].handleOut\n          segments1.pop()\n          segments2[0] = join\n        } else {\n          segments2[0].handleIn = segments1[1].handleIn\n          segments1.pop()\n        }\n      }\n    }\n  }\n\n  /**\n   * Connect all the segments together.\n   */\n  function ConnectBeziers(rawSegments: Array<Array<paper.Segment>>, join: StrokeJoinType, source: paper.Path, offset: number, limit: number) {\n    let originSegments = source.segments\n    let first = rawSegments[0].slice()\n    for (let i = 0; i < rawSegments.length - 1; ++i) {\n      ConnectAdjacentBezier(rawSegments[i], rawSegments[i + 1], originSegments[i + 1], join, offset, limit)\n    }\n    if (source.closed) {\n      ConnectAdjacentBezier(rawSegments[rawSegments.length - 1], first, originSegments[0], join, offset, limit)\n      rawSegments[0][0] = first[0]\n    }\n    return rawSegments\n  }\n\n  function Decompound(path: PathType) {\n    if (path.children.length === 1) {\n      path = path.children[0] as paper.Path\n      path.remove() // remove from parent, this is critical, or the style attributes will be ignored\n    }\n    return path\n  }\n\n  /** Normalize a path, always clockwise, non-self-intersection, ignore really small components, and no one-component compound path. */\n  export function Normalize(path: PathType, areaThreshold = 0.01) {\n    if (path.closed) {\n      let ignoreArea = Math.abs(path.area * areaThreshold)\n      if (!path.clockwise) {\n        path.reverse()\n      }\n      path = path.unite(path, { insert: false }) as PathType\n      if (path instanceof paper.CompoundPath) {\n        path.children.filter(c => Math.abs((c as PathType).area) < ignoreArea).forEach(c => c.remove())\n        if (path.children.length === 1) {\n          return Decompound(path)\n        }\n      }\n    }\n    return path\n  }\n\n  export function IsSameDirection(partialPath: paper.Path, fullPath: PathType) {\n    let offset1 = partialPath.segments[0].location.offset\n    let offset2 = partialPath.segments[Math.max(1, Math.floor(partialPath.segments.length / 2))].location.offset\n    let sampleOffset = (offset1 + offset2) / 3\n    let originOffset1 = fullPath.getNearestLocation(partialPath.getPointAt(sampleOffset)).offset\n    let originOffset2 = fullPath.getNearestLocation(partialPath.getPointAt(2 * sampleOffset)).offset\n    return originOffset1 < originOffset2\n  }\n\n  /** Remove self intersection when offset is negative by point direction dectection. */\n  export function RemoveIntersection(path: PathType) {\n    let newPath = path.unite(path, { insert: false }) as PathType\n    if (newPath instanceof paper.CompoundPath) {\n      (newPath.children as Array<paper.Path>).filter(c => {\n        if (c.segments.length > 1) {\n          return !IsSameDirection(c, path)\n        } else {\n          return true\n        }\n      }).forEach(c => c.remove())\n      return Decompound(newPath)\n    }\n    return path\n  }\n\n  function Segments(path: PathType) {\n    if (path instanceof paper.CompoundPath) {\n      return Arrayex.Flat<paper.Segment>(path.children.map(c => (c as paper.Path).segments))\n    } else {\n      return (path as paper.Path).segments\n    }\n  }\n\n  /**\n   * Remove impossible segments in negative offset condition.\n   */\n  function RemoveOutsiders(offsetPath: PathType, path: PathType) {\n    let segments = Segments(offsetPath).slice()\n    segments.forEach(segment => {\n      if (!path.contains(segment.point)) {\n        segment.remove()\n      }\n    })\n  }\n\n  function PreparePath(path: paper.Path, offset: number): [paper.Path, number] {\n    let source = path.clone({ insert: false }) as paper.Path\n    source.reduce()\n    if (!path.clockwise) {\n      source.reverse()\n      offset = -offset\n    }\n    return [source, offset]\n  }\n\n  export function OffsetSimpleShape(path: paper.Path, offset: number, join: StrokeJoinType, limit: number): PathType {\n    let source: paper.Path\n    [source, offset] = PreparePath(path, offset)\n    let curves = source.curves.slice()\n    let raws = Arrayex.Divide(Arrayex.Flat<paper.Segment>(curves.map(curve => AdaptiveOffsetCurve(curve, offset))), 2)\n    let segments = Arrayex.Flat(ConnectBeziers(raws, join, source, offset, limit))\n    let offsetPath = RemoveIntersection(new paper.Path({ segments, insert: false, closed: path.closed }))\n    offsetPath.reduce()\n    if (source.closed && ((source.clockwise && offset < 0) || (!source.clockwise && offset > 0))) {\n      RemoveOutsiders(offsetPath, path)\n    }\n    // recovery path\n    if (source.clockwise !== path.clockwise) {\n      offsetPath.reverse()\n    }\n    return Normalize(offsetPath)\n  }\n\n  function MakeRoundCap(from: paper.Segment, to: paper.Segment, offset: number) {\n    let origin = from.point.add(to.point).divide(2)\n    let normal = to.point.subtract(from.point).rotate(-90).normalize(offset)\n    let through = origin.add(normal)\n    let arc = new paper.Path.Arc({ from: from.point, to: to.point, through, insert: false })\n    return arc.segments\n  }\n\n  function ConnectSide(outer: PathType, inner: paper.Path, offset: number, cap: StrokeCapType): paper.Path {\n    if (outer instanceof paper.CompoundPath) {\n      let cs = outer.children.map(c => ({ c, a: Math.abs((c as paper.Path).area) }))\n      cs = cs.sort((c1, c2) => c2.a - c1.a)\n      outer = cs[0].c as paper.Path\n    }\n    let oSegments = (outer as paper.Path).segments.slice()\n    let iSegments = inner.segments.slice()\n    switch (cap) {\n      case 'round':\n        let heads = MakeRoundCap(iSegments[iSegments.length - 1], oSegments[0], offset)\n        let tails = MakeRoundCap(oSegments[oSegments.length - 1], iSegments[0], offset)\n        let result = new paper.Path({ segments: [...heads, ...oSegments, ...tails, ...iSegments], closed: true, insert: false })\n        result.reduce()\n        return result\n      default: return new paper.Path({ segments: [...oSegments, ...iSegments], closed: true, insert: false })\n    }\n  }\n\n  export function OffsetSimpleStroke(path: paper.Path, offset: number, join: StrokeJoinType, cap: StrokeCapType, limit: number): PathType {\n    offset = path.clockwise ? offset : -offset\n    let positiveOffset = OffsetSimpleShape(path, offset, join, limit)\n    let negativeOffset = OffsetSimpleShape(path, -offset, join, limit)\n    if (path.closed) {\n      return positiveOffset.subtract(negativeOffset, { insert: false }) as PathType\n    } else {\n      let inner = negativeOffset\n      let holes = new Array<paper.Path>()\n      if (negativeOffset instanceof paper.CompoundPath) {\n        holes = negativeOffset.children.filter(c => (c as paper.Path).closed) as Array<paper.Path>\n        holes.forEach(h => h.remove())\n        inner = negativeOffset.children[0] as paper.Path\n      }\n      inner.reverse()\n      let final = ConnectSide(positiveOffset, inner as paper.Path, offset, cap) as PathType\n      if (holes.length > 0) {\n        for(let hole of holes) {\n          final = final.subtract(hole, { insert: false }) as PathType\n        }\n      }\n      return final\n    }\n  }\n}\n\nexport function OffsetPath(path: PathType, offset: number, join: StrokeJoinType, limit: number) {\n  let nonSIPath = path.unite(path, { insert: false }) as PathType\n  let result = nonSIPath\n  if (nonSIPath instanceof paper.Path) {\n    result = Offsets.OffsetSimpleShape(nonSIPath, offset, join, limit)\n  } else {\n    let children = Arrayex.Flat((nonSIPath.children as Array<paper.Path>).map(c => {\n      if (c.segments.length > 1) {\n        if (!Offsets.IsSameDirection(c, path)) {\n          c.reverse()\n        }\n        let offseted = Offsets.OffsetSimpleShape(c, offset, join, limit)\n        offseted = Offsets.Normalize(offseted)\n        if (offseted.clockwise !== c.clockwise) {\n          offseted.reverse()\n        }\n        if (offseted instanceof paper.CompoundPath) {\n          offseted.applyMatrix = true\n          return offseted.children\n        } else {\n          return offseted\n        }\n      } else {\n        return null\n      }\n    }), false)\n    result = new paper.CompoundPath({ children, insert: false })\n  }\n  result.copyAttributes(nonSIPath, false)\n  result.remove()\n  return result\n}\n\nexport function OffsetStroke(path: PathType, offset: number, join: StrokeJoinType, cap: StrokeCapType, limit: number) {\n  let nonSIPath = path.unite(path, { insert: false }) as PathType\n  let result = nonSIPath as PathType\n  if (nonSIPath instanceof paper.Path) {\n    result = Offsets.OffsetSimpleStroke(nonSIPath, offset, join, cap, limit)\n  } else {\n    let children = Arrayex.Flat((nonSIPath.children as Array<paper.Path>).map(c => {\n      return Offsets.OffsetSimpleStroke(c, offset, join, cap, limit)\n    }))\n    result = children.reduce((c1, c2) => c1.unite(c2, { insert: false }) as PathType)\n  }\n  result.strokeWidth = 0\n  result.fillColor = nonSIPath.strokeColor\n  result.shadowBlur = nonSIPath.shadowBlur\n  result.shadowColor = nonSIPath.shadowColor\n  result.shadowOffset = nonSIPath.shadowOffset\n  return result\n}\n","import paper from 'paper'\r\nimport { OffsetPath, StrokeJoinType, PathType, StrokeCapType, OffsetStroke } from './Offset'\r\n\r\nexport interface OffsetOptions {\r\n  join?: StrokeJoinType,\r\n  cap?: StrokeCapType,\r\n  limit?: number,\r\n  insert?: boolean,\r\n}\r\n\r\ndeclare module 'paper' {\r\n  interface Path {\r\n    offset(offset: number, options?: OffsetOptions): PathType\r\n    offsetStroke(offset: number, options?: OffsetOptions): PathType | paper.Group\r\n  }\r\n\r\n  interface CompoundPath {\r\n    offset(offset: number, options?: OffsetOptions): PathType\r\n    offsetStroke(offset: number, options?: OffsetOptions): PathType | paper.Group\r\n  }\r\n}\r\n\r\nfunction PrototypedOffset(path: PathType, offset: number, options?: OffsetOptions) {\r\n  options = options || {}\r\n  let offsetPath = OffsetPath(path, offset, options.join || 'miter', options.limit || 10)\r\n  if (options.insert === undefined) {\r\n    options.insert = true\r\n  }\r\n  if (options.insert) {\r\n    (path.parent || paper.project.activeLayer).addChild(offsetPath)\r\n  }\r\n  return offsetPath\r\n}\r\n\r\nfunction PrototypedOffsetStroke(path: PathType, offset: number, options?: OffsetOptions) {\r\n  options = options || {}\r\n  let offsetPath = OffsetStroke(path, offset, options.join || 'miter', options.cap || 'butt', options.limit || 10)\r\n  if (options.insert === undefined) {\r\n    options.insert = true\r\n  }\r\n  if (options.insert) {\r\n    (path.parent || paper.project.activeLayer).addChild(offsetPath)\r\n  }\r\n  return offsetPath\r\n}\r\n\r\nexport default function ExtendPaperJs(paper: any) {\r\n  paper.Path.prototype.offset = function(offset: number, options?: OffsetOptions) {\r\n    return PrototypedOffset(this, offset, options)\r\n  }\r\n\r\n  paper.Path.prototype.offsetStroke = function (offset: number, options?: OffsetOptions) {\r\n    return PrototypedOffsetStroke(this, offset, options)\r\n  }\r\n\r\n  paper.CompoundPath.prototype.offset = function(offset: number, options?: OffsetOptions) {\r\n    return PrototypedOffset(this, offset, options)\r\n  }\r\n\r\n  paper.CompoundPath.prototype.offsetStroke = function (offset: number, options?: OffsetOptions) {\r\n    return PrototypedOffsetStroke(this, offset, options)\r\n  }\r\n}\r\n"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/paperjs-offset/dist/index.umd.js b/node_modules/paperjs-offset/dist/index.umd.js
index cc2a94b..ebc59fc 100644
--- a/node_modules/paperjs-offset/dist/index.umd.js
+++ b/node_modules/paperjs-offset/dist/index.umd.js
@@ -1,322 +1,318 @@
 (function (global, factory) {
-  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('paper')) :
-  typeof define === 'function' && define.amd ? define(['exports', 'paper'], factory) :
-  (global = global || self, factory(global.paperjsOffset = {}, global.paper));
-}(this, (function (exports, paper) { 'use strict';
+  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('paper'), require('arrayex')) :
+  typeof define === 'function' && define.amd ? define(['paper', 'arrayex'], factory) :
+  (global = global || self, global.paperjsOffset = factory(global.paper, global.arrayex));
+}(this, function (paper, arrayex) { 'use strict';
 
-  paper = paper && Object.prototype.hasOwnProperty.call(paper, 'default') ? paper['default'] : paper;
+  paper = paper && paper.hasOwnProperty('default') ? paper['default'] : paper;
 
-  /**
-   * Offset the start/terminal segment of a bezier curve
-   * @param segment segment to offset
-   * @param curve curve to offset
-   * @param handleNormal the normal of the the line formed of two handles
-   * @param offset offset value
-   */
-  function offsetSegment(segment, curve, handleNormal, offset) {
-      var isFirst = segment.curve === curve;
-      // get offset vector
-      var offsetVector = (curve.getNormalAtTime(isFirst ? 0 : 1)).multiply(offset);
-      // get offset point
-      var point = segment.point.add(offsetVector);
-      var newSegment = new paper.Segment(point);
-      // handleOut for start segment & handleIn for terminal segment
-      var handle = (isFirst ? 'handleOut' : 'handleIn');
-      newSegment[handle] = segment[handle].add(handleNormal.subtract(offsetVector).divide(2));
-      return newSegment;
-  }
-  /**
-   * Adaptive offset a curve by repeatly apply the approximation proposed by Tiller and Hanson.
-   * @param curve curve to offset
-   * @param offset offset value
-   */
-  function adaptiveOffsetCurve(curve, offset) {
-      var hNormal = (new paper.Curve(curve.segment1.handleOut.add(curve.segment1.point), new paper.Point(0, 0), new paper.Point(0, 0), curve.segment2.handleIn.add(curve.segment2.point))).getNormalAtTime(0.5).multiply(offset);
-      var segment1 = offsetSegment(curve.segment1, curve, hNormal, offset);
-      var segment2 = offsetSegment(curve.segment2, curve, hNormal, offset);
-      // divide && re-offset
-      var offsetCurve = new paper.Curve(segment1, segment2);
-      // if the offset curve is not self intersected, divide it
-      if (offsetCurve.getIntersections(offsetCurve).length === 0) {
-          var threshold = Math.min(Math.abs(offset) / 10, 1);
-          var midOffset = offsetCurve.getPointAtTime(0.5).getDistance(curve.getPointAtTime(0.5));
-          if (Math.abs(midOffset - Math.abs(offset)) > threshold) {
-              var subCurve = curve.divideAtTime(0.5);
-              if (subCurve != null) {
-                  return adaptiveOffsetCurve(curve, offset).concat(adaptiveOffsetCurve(subCurve, offset));
+  var Offsets;
+  (function (Offsets) {
+      /**
+       * Offset the start/terminal segment of a bezier curve
+       * @param segment segment to offset
+       * @param curve curve to offset
+       * @param handleNormal the normal of the the line formed of two handles
+       * @param offset offset value
+       */
+      function OffsetSegment(segment, curve, handleNormal, offset) {
+          var isFirst = segment.curve === curve;
+          // get offset vector
+          var offsetVector = (curve.getNormalAt(isFirst ? 0 : 1, true)).multiply(offset);
+          // get offset point
+          var point = segment.point.add(offsetVector);
+          var newSegment = new paper.Segment(point);
+          // handleOut for start segment & handleIn for terminal segment
+          var handle = (isFirst ? 'handleOut' : 'handleIn');
+          newSegment[handle] = segment[handle].add(handleNormal.subtract(offsetVector).divide(2));
+          return newSegment;
+      }
+      /**
+       * Adaptive offset a curve by repeatly apply the approximation proposed by Tiller and Hanson.
+       * @param curve curve to offset
+       * @param offset offset value
+       */
+      function AdaptiveOffsetCurve(curve, offset) {
+          var hNormal = (new paper.Curve(curve.segment1.handleOut.add(curve.segment1.point), new paper.Point(0, 0), new paper.Point(0, 0), curve.segment2.handleIn.add(curve.segment2.point))).getNormalAt(0.5, true).multiply(offset);
+          var segment1 = OffsetSegment(curve.segment1, curve, hNormal, offset);
+          var segment2 = OffsetSegment(curve.segment2, curve, hNormal, offset);
+          // divide && re-offset
+          var offsetCurve = new paper.Curve(segment1, segment2);
+          // if the offset curve is not self intersected, divide it
+          if (offsetCurve.getIntersections(offsetCurve).length === 0) {
+              var threshold = Math.min(Math.abs(offset) / 10, 1);
+              var midOffset = offsetCurve.getPointAt(0.5, true).getDistance(curve.getPointAt(0.5, true));
+              if (Math.abs(midOffset - Math.abs(offset)) > threshold) {
+                  var subCurve = curve.divideAtTime(0.5);
+                  if (subCurve != null) {
+                      return AdaptiveOffsetCurve(curve, offset).concat(AdaptiveOffsetCurve(subCurve, offset));
+                  }
               }
           }
+          return [segment1, segment2];
       }
-      return [segment1, segment2];
-  }
-  /**
-   * Create a round join segment between two adjacent segments.
-   */
-  function makeRoundJoin(segment1, segment2, originPoint, radius) {
-      var through = segment1.point.subtract(originPoint).add(segment2.point.subtract(originPoint))
-          .normalize(Math.abs(radius)).add(originPoint);
-      var arc = new paper.Path.Arc({ from: segment1.point, to: segment2.point, through: through, insert: false });
-      segment1.handleOut = arc.firstSegment.handleOut;
-      segment2.handleIn = arc.lastSegment.handleIn;
-      return arc.segments.length === 3 ? arc.segments[1] : null;
-  }
-  function det(p1, p2) {
-      return p1.x * p2.y - p1.y * p2.x;
-  }
-  /**
-   * Get the intersection point of point based lines
-   */
-  function getPointLineIntersections(p1, p2, p3, p4) {
-      var l1 = p1.subtract(p2);
-      var l2 = p3.subtract(p4);
-      var dl1 = det(p1, p2);
-      var dl2 = det(p3, p4);
-      return new paper.Point(dl1 * l2.x - l1.x * dl2, dl1 * l2.y - l1.y * dl2).divide(det(l1, l2));
-  }
-  /**
-   * Connect two adjacent bezier curve, each curve is represented by two segments,
-   * create different types of joins or simply removal redundant segment.
-   */
-  function connectAdjacentBezier(segments1, segments2, origin, joinType, offset, limit) {
-      var curve1 = new paper.Curve(segments1[0], segments1[1]);
-      var curve2 = new paper.Curve(segments2[0], segments2[1]);
-      var intersection = curve1.getIntersections(curve2);
-      var distance = segments1[1].point.getDistance(segments2[0].point);
-      if (origin.isSmooth()) {
-          segments2[0].handleOut = segments2[0].handleOut.project(origin.handleOut);
-          segments2[0].handleIn = segments1[1].handleIn.project(origin.handleIn);
-          segments2[0].point = segments1[1].point.add(segments2[0].point).divide(2);
-          segments1.pop();
+      /**
+       * Create a round join segment between two adjacent segments.
+       */
+      function MakeRoundJoin(segment1, segment2, originPoint, radius) {
+          var through = segment1.point.subtract(originPoint).add(segment2.point.subtract(originPoint)).normalize(Math.abs(radius)).add(originPoint);
+          var arc = new paper.Path.Arc({ from: segment1.point, to: segment2.point, through: through, insert: false });
+          segment1.handleOut = arc.firstSegment.handleOut;
+          segment2.handleIn = arc.lastSegment.handleIn;
+          return arc.segments.length === 3 ? arc.segments[1] : null;
       }
-      else {
-          if (intersection.length === 0) {
-              if (distance > Math.abs(offset) * 0.1) {
-                  // connect
-                  switch (joinType) {
-                      case 'miter':
-                          var join = getPointLineIntersections(curve1.point2, curve1.point2.add(curve1.getTangentAtTime(1)), curve2.point1, curve2.point1.add(curve2.getTangentAtTime(0)));
-                          // prevent sharp angle
-                          var joinOffset = Math.max(join.getDistance(curve1.point2), join.getDistance(curve2.point1));
-                          if (joinOffset < Math.abs(offset) * limit) {
-                              segments1.push(new paper.Segment(join));
-                          }
-                          break;
-                      case 'round':
-                          var mid = makeRoundJoin(segments1[1], segments2[0], origin.point, offset);
-                          if (mid) {
-                              segments1.push(mid);
-                          }
-                          break;
-                  }
-              }
-              else {
-                  segments2[0].handleIn = segments1[1].handleIn;
-                  segments1.pop();
-              }
+      function Det(p1, p2) {
+          return p1.x * p2.y - p1.y * p2.x;
+      }
+      /**
+       * Get the intersection point of two point
+       */
+      function Intersection(p1, p2, p3, p4) {
+          var l1 = p1.subtract(p2);
+          var l2 = p3.subtract(p4);
+          var dl1 = Det(p1, p2);
+          var dl2 = Det(p3, p4);
+          return new paper.Point(dl1 * l2.x - l1.x * dl2, dl1 * l2.y - l1.y * dl2).divide(Det(l1, l2));
+      }
+      /**
+       * Connect two adjacent bezier curve, each curve is represented by two segments, create different types of joins or simply removal redundant segment.
+       */
+      function ConnectAdjacentBezier(segments1, segments2, origin, join, offset, limit) {
+          var curve1 = new paper.Curve(segments1[0], segments1[1]);
+          var curve2 = new paper.Curve(segments2[0], segments2[1]);
+          var intersection = curve1.getIntersections(curve2);
+          var distance = segments1[1].point.getDistance(segments2[0].point);
+          if (origin.isSmooth()) {
+              segments2[0].handleOut = segments2[0].handleOut.project(origin.handleOut);
+              segments2[0].handleIn = segments1[1].handleIn.project(origin.handleIn);
+              segments2[0].point = segments1[1].point.add(segments2[0].point).divide(2);
+              segments1.pop();
           }
           else {
-              var second1 = curve1.divideAt(intersection[0]);
-              if (second1) {
-                  var join = second1.segment1;
-                  var second2 = curve2.divideAt(curve2.getIntersections(curve1)[0]);
-                  join.handleOut = second2 ? second2.segment1.handleOut : segments2[0].handleOut;
-                  segments1.pop();
-                  segments2[0] = join;
+              if (intersection.length === 0) {
+                  if (distance > Math.abs(offset) * 0.1) {
+                      // connect
+                      switch (join) {
+                          case 'miter':
+                              var join_1 = Intersection(curve1.point2, curve1.point2.add(curve1.getTangentAt(1, true)), curve2.point1, curve2.point1.add(curve2.getTangentAt(0, true)));
+                              // prevent sharp angle
+                              var joinOffset = Math.max(join_1.getDistance(curve1.point2), join_1.getDistance(curve2.point1));
+                              if (joinOffset < Math.abs(offset) * limit) {
+                                  segments1.push(new paper.Segment(join_1));
+                              }
+                              break;
+                          case 'round':
+                              var mid = MakeRoundJoin(segments1[1], segments2[0], origin.point, offset);
+                              if (mid) {
+                                  segments1.push(mid);
+                              }
+                              break;
+                          default: break;
+                      }
+                  }
+                  else {
+                      segments2[0].handleIn = segments1[1].handleIn;
+                      segments1.pop();
+                  }
               }
               else {
-                  segments2[0].handleIn = segments1[1].handleIn;
-                  segments1.pop();
+                  var second1 = curve1.divideAt(intersection[0]);
+                  if (second1) {
+                      var join_2 = second1.segment1;
+                      var second2 = curve2.divideAt(curve2.getIntersections(curve1)[0]);
+                      join_2.handleOut = second2 ? second2.segment1.handleOut : segments2[0].handleOut;
+                      segments1.pop();
+                      segments2[0] = join_2;
+                  }
+                  else {
+                      segments2[0].handleIn = segments1[1].handleIn;
+                      segments1.pop();
+                  }
               }
           }
       }
-  }
-  /**
-   * Connect all the segments together.
-   */
-  function connectBeziers(rawSegments, join, source, offset, limit) {
-      var originSegments = source.segments;
-      var first = rawSegments[0].slice();
-      for (var i = 0; i < rawSegments.length - 1; ++i) {
-          connectAdjacentBezier(rawSegments[i], rawSegments[i + 1], originSegments[i + 1], join, offset, limit);
-      }
-      if (source.closed) {
-          connectAdjacentBezier(rawSegments[rawSegments.length - 1], first, originSegments[0], join, offset, limit);
-          rawSegments[0][0] = first[0];
-      }
-      return rawSegments;
-  }
-  function reduceSingleChildCompoundPath(path) {
-      if (path.children.length === 1) {
-          path = path.children[0];
-          path.remove(); // remove from parent, this is critical, or the style attributes will be ignored
+      Offsets.ConnectAdjacentBezier = ConnectAdjacentBezier;
+      /**
+       * Connect all the segments together.
+       */
+      function ConnectBeziers(rawSegments, join, source, offset, limit) {
+          var originSegments = source.segments;
+          var first = rawSegments[0].slice();
+          for (var i = 0; i < rawSegments.length - 1; ++i) {
+              ConnectAdjacentBezier(rawSegments[i], rawSegments[i + 1], originSegments[i + 1], join, offset, limit);
+          }
+          if (source.closed) {
+              ConnectAdjacentBezier(rawSegments[rawSegments.length - 1], first, originSegments[0], join, offset, limit);
+              rawSegments[0][0] = first[0];
+          }
+          return rawSegments;
       }
-      return path;
-  }
-  /** Normalize a path, always clockwise, non-self-intersection, ignore really small components, and no one-component compound path. */
-  function normalize(path, areaThreshold) {
-      if (areaThreshold === void 0) { areaThreshold = 0.01; }
-      if (path.closed) {
-          var ignoreArea_1 = Math.abs(path.area * areaThreshold);
-          if (!path.clockwise) {
-              path.reverse();
+      function Decompound(path) {
+          if (path.children.length === 1) {
+              path = path.children[0];
+              path.remove(); // remove from parent, this is critical, or the style attributes will be ignored
           }
-          path = path.unite(path, { insert: false });
-          if (path instanceof paper.CompoundPath) {
-              path.children.filter(function (c) { return Math.abs(c.area) < ignoreArea_1; }).forEach(function (c) { return c.remove(); });
-              if (path.children.length === 1) {
-                  return reduceSingleChildCompoundPath(path);
+          return path;
+      }
+      /** Normalize a path, always clockwise, non-self-intersection, ignore really small components, and no one-component compound path. */
+      function Normalize(path, areaThreshold) {
+          if (areaThreshold === void 0) { areaThreshold = 0.01; }
+          if (path.closed) {
+              var ignoreArea_1 = Math.abs(path.area * areaThreshold);
+              if (!path.clockwise) {
+                  path.reverse();
+              }
+              path = path.unite(path, { insert: false });
+              if (path instanceof paper.CompoundPath) {
+                  path.children.filter(function (c) { return Math.abs(c.area) < ignoreArea_1; }).forEach(function (c) { return c.remove(); });
+                  if (path.children.length === 1) {
+                      return Decompound(path);
+                  }
               }
           }
+          return path;
       }
-      return path;
-  }
-  function isSameDirection(partialPath, fullPath) {
-      var offset1 = partialPath.segments[0].location.offset;
-      var offset2 = partialPath.segments[Math.max(1, Math.floor(partialPath.segments.length / 2))].location.offset;
-      var sampleOffset = (offset1 + offset2) / 3;
-      var originOffset1 = fullPath.getNearestLocation(partialPath.getPointAt(sampleOffset)).offset;
-      var originOffset2 = fullPath.getNearestLocation(partialPath.getPointAt(2 * sampleOffset)).offset;
-      return originOffset1 < originOffset2;
-  }
-  /** Remove self intersection when offset is negative by point direction dectection. */
-  function removeIntersection(path) {
-      if (path.closed) {
+      Offsets.Normalize = Normalize;
+      function IsSameDirection(partialPath, fullPath) {
+          var offset1 = partialPath.segments[0].location.offset;
+          var offset2 = partialPath.segments[Math.max(1, Math.floor(partialPath.segments.length / 2))].location.offset;
+          var sampleOffset = (offset1 + offset2) / 3;
+          var originOffset1 = fullPath.getNearestLocation(partialPath.getPointAt(sampleOffset)).offset;
+          var originOffset2 = fullPath.getNearestLocation(partialPath.getPointAt(2 * sampleOffset)).offset;
+          return originOffset1 < originOffset2;
+      }
+      Offsets.IsSameDirection = IsSameDirection;
+      /** Remove self intersection when offset is negative by point direction dectection. */
+      function RemoveIntersection(path) {
           var newPath = path.unite(path, { insert: false });
           if (newPath instanceof paper.CompoundPath) {
               newPath.children.filter(function (c) {
                   if (c.segments.length > 1) {
-                      return !isSameDirection(c, path);
+                      return !IsSameDirection(c, path);
                   }
                   else {
                       return true;
                   }
               }).forEach(function (c) { return c.remove(); });
-              return reduceSingleChildCompoundPath(newPath);
+              return Decompound(newPath);
           }
+          return path;
       }
-      return path;
-  }
-  function getSegments(path) {
-      if (path instanceof paper.CompoundPath) {
-          return path.children.map(function (c) { return c.segments; }).flat();
-      }
-      else {
-          return path.segments;
-      }
-  }
-  /**
-   * Remove impossible segments in negative offset condition.
-   */
-  function removeOutsiders(newPath, path) {
-      var segments = getSegments(newPath).slice();
-      segments.forEach(function (segment) {
-          if (!path.contains(segment.point)) {
-              segment.remove();
+      Offsets.RemoveIntersection = RemoveIntersection;
+      function Segments(path) {
+          if (path instanceof paper.CompoundPath) {
+              return arrayex.Arrayex.Flat(path.children.map(function (c) { return c.segments; }));
+          }
+          else {
+              return path.segments;
           }
-      });
-  }
-  function preparePath(path, offset) {
-      var source = path.clone({ insert: false });
-      source.reduce({});
-      if (!path.clockwise) {
-          source.reverse();
-          offset = -offset;
-      }
-      return [source, offset];
-  }
-  function offsetSimpleShape(path, offset, join, limit) {
-      var _a;
-      var source;
-      _a = preparePath(path, offset), source = _a[0], offset = _a[1];
-      var curves = source.curves.slice();
-      var offsetCurves = curves.map(function (curve) { return adaptiveOffsetCurve(curve, offset); }).flat();
-      var raws = [];
-      for (var i = 0; i < offsetCurves.length; i += 2) {
-          raws.push(offsetCurves.slice(i, i + 2));
       }
-      var segments = connectBeziers(raws, join, source, offset, limit).flat();
-      var newPath = removeIntersection(new paper.Path({ segments: segments, insert: false, closed: path.closed }));
-      newPath.reduce({});
-      if (source.closed && ((source.clockwise && offset < 0) || (!source.clockwise && offset > 0))) {
-          removeOutsiders(newPath, path);
+      /**
+       * Remove impossible segments in negative offset condition.
+       */
+      function RemoveOutsiders(offsetPath, path) {
+          var segments = Segments(offsetPath).slice();
+          segments.forEach(function (segment) {
+              if (!path.contains(segment.point)) {
+                  segment.remove();
+              }
+          });
       }
-      // recovery path
-      if (source.clockwise !== path.clockwise) {
-          newPath.reverse();
+      function PreparePath(path, offset) {
+          var source = path.clone({ insert: false });
+          source.reduce();
+          if (!path.clockwise) {
+              source.reverse();
+              offset = -offset;
+          }
+          return [source, offset];
       }
-      return normalize(newPath);
-  }
-  function makeRoundCap(from, to, offset) {
-      var origin = from.point.add(to.point).divide(2);
-      var normal = to.point.subtract(from.point).rotate(-90, new paper.Point(0, 0)).normalize(offset);
-      var through = origin.add(normal);
-      var arc = new paper.Path.Arc({ from: from.point, to: to.point, through: through, insert: false });
-      return arc.segments;
-  }
-  function connectSide(outer, inner, offset, cap) {
-      if (outer instanceof paper.CompoundPath) {
-          var cs = outer.children.map(function (c) { return ({ c: c, a: Math.abs(c.area) }); });
-          cs = cs.sort(function (c1, c2) { return c2.a - c1.a; });
-          outer = cs[0].c;
+      function OffsetSimpleShape(path, offset, join, limit) {
+          var _a;
+          var source;
+          _a = PreparePath(path, offset), source = _a[0], offset = _a[1];
+          var curves = source.curves.slice();
+          var raws = arrayex.Arrayex.Divide(arrayex.Arrayex.Flat(curves.map(function (curve) { return AdaptiveOffsetCurve(curve, offset); })), 2);
+          var segments = arrayex.Arrayex.Flat(ConnectBeziers(raws, join, source, offset, limit));
+          var offsetPath = RemoveIntersection(new paper.Path({ segments: segments, insert: false, closed: path.closed }));
+          offsetPath.reduce();
+          if (source.closed && ((source.clockwise && offset < 0) || (!source.clockwise && offset > 0))) {
+              RemoveOutsiders(offsetPath, path);
+          }
+          // recovery path
+          if (source.clockwise !== path.clockwise) {
+              offsetPath.reverse();
+          }
+          return Normalize(offsetPath);
       }
-      var oSegments = outer.segments.slice();
-      var iSegments = inner.segments.slice();
-      switch (cap) {
-          case 'round':
-              var heads = makeRoundCap(iSegments[iSegments.length - 1], oSegments[0], offset);
-              var tails = makeRoundCap(oSegments[oSegments.length - 1], iSegments[0], offset);
-              var result = new paper.Path({ segments: heads.concat(oSegments, tails, iSegments), closed: true, insert: false });
-              result.reduce({});
-              return result;
-          default: return new paper.Path({ segments: oSegments.concat(iSegments), closed: true, insert: false });
+      Offsets.OffsetSimpleShape = OffsetSimpleShape;
+      function MakeRoundCap(from, to, offset) {
+          var origin = from.point.add(to.point).divide(2);
+          var normal = to.point.subtract(from.point).rotate(-90).normalize(offset);
+          var through = origin.add(normal);
+          var arc = new paper.Path.Arc({ from: from.point, to: to.point, through: through, insert: false });
+          return arc.segments;
       }
-  }
-  function offsetSimpleStroke(path, offset, join, cap, limit) {
-      offset = path.clockwise ? offset : -offset;
-      var positiveOffset = offsetSimpleShape(path, offset, join, limit);
-      var negativeOffset = offsetSimpleShape(path, -offset, join, limit);
-      if (path.closed) {
-          return positiveOffset.subtract(negativeOffset, { insert: false });
+      function ConnectSide(outer, inner, offset, cap) {
+          if (outer instanceof paper.CompoundPath) {
+              var cs = outer.children.map(function (c) { return ({ c: c, a: Math.abs(c.area) }); });
+              cs = cs.sort(function (c1, c2) { return c2.a - c1.a; });
+              outer = cs[0].c;
+          }
+          var oSegments = outer.segments.slice();
+          var iSegments = inner.segments.slice();
+          switch (cap) {
+              case 'round':
+                  var heads = MakeRoundCap(iSegments[iSegments.length - 1], oSegments[0], offset);
+                  var tails = MakeRoundCap(oSegments[oSegments.length - 1], iSegments[0], offset);
+                  var result = new paper.Path({ segments: heads.concat(oSegments, tails, iSegments), closed: true, insert: false });
+                  result.reduce();
+                  return result;
+              default: return new paper.Path({ segments: oSegments.concat(iSegments), closed: true, insert: false });
+          }
       }
-      else {
-          var inner = negativeOffset;
-          var holes = new Array();
-          if (negativeOffset instanceof paper.CompoundPath) {
-              holes = negativeOffset.children.filter(function (c) { return c.closed; });
-              holes.forEach(function (h) { return h.remove(); });
-              inner = negativeOffset.children[0];
+      function OffsetSimpleStroke(path, offset, join, cap, limit) {
+          offset = path.clockwise ? offset : -offset;
+          var positiveOffset = OffsetSimpleShape(path, offset, join, limit);
+          var negativeOffset = OffsetSimpleShape(path, -offset, join, limit);
+          if (path.closed) {
+              return positiveOffset.subtract(negativeOffset, { insert: false });
           }
-          inner.reverse();
-          var final = connectSide(positiveOffset, inner, offset, cap);
-          if (holes.length > 0) {
-              for (var _i = 0, holes_1 = holes; _i < holes_1.length; _i++) {
-                  var hole = holes_1[_i];
-                  final = final.subtract(hole, { insert: false });
+          else {
+              var inner = negativeOffset;
+              var holes = new Array();
+              if (negativeOffset instanceof paper.CompoundPath) {
+                  holes = negativeOffset.children.filter(function (c) { return c.closed; });
+                  holes.forEach(function (h) { return h.remove(); });
+                  inner = negativeOffset.children[0];
               }
+              inner.reverse();
+              var final = ConnectSide(positiveOffset, inner, offset, cap);
+              if (holes.length > 0) {
+                  for (var _i = 0, holes_1 = holes; _i < holes_1.length; _i++) {
+                      var hole = holes_1[_i];
+                      final = final.subtract(hole, { insert: false });
+                  }
+              }
+              return final;
           }
-          return final;
       }
-  }
-  function getNonSelfItersectionPath(path) {
-      if (path.closed) {
-          return path.unite(path, { insert: false });
-      }
-      return path;
-  }
-  function offsetPath(path, offset, join, limit) {
-      var nonSIPath = getNonSelfItersectionPath(path);
+      Offsets.OffsetSimpleStroke = OffsetSimpleStroke;
+  })(Offsets || (Offsets = {}));
+  function OffsetPath(path, offset, join, limit) {
+      var nonSIPath = path.unite(path, { insert: false });
       var result = nonSIPath;
       if (nonSIPath instanceof paper.Path) {
-          result = offsetSimpleShape(nonSIPath, offset, join, limit);
+          result = Offsets.OffsetSimpleShape(nonSIPath, offset, join, limit);
       }
       else {
-          var offsetParts = nonSIPath.children.map(function (c) {
+          var children = arrayex.Arrayex.Flat(nonSIPath.children.map(function (c) {
               if (c.segments.length > 1) {
-                  if (!isSameDirection(c, path)) {
+                  if (!Offsets.IsSameDirection(c, path)) {
                       c.reverse();
                   }
-                  var offseted = offsetSimpleShape(c, offset, join, limit);
-                  offseted = normalize(offseted);
+                  var offseted = Offsets.OffsetSimpleShape(c, offset, join, limit);
+                  offseted = Offsets.Normalize(offseted);
                   if (offseted.clockwise !== c.clockwise) {
                       offseted.reverse();
                   }
@@ -331,24 +327,23 @@
               else {
                   return null;
               }
-          });
-          var children = offsetParts.flat().filter(function (c) { return !!c; });
+          }), false);
           result = new paper.CompoundPath({ children: children, insert: false });
       }
       result.copyAttributes(nonSIPath, false);
       result.remove();
       return result;
   }
-  function offsetStroke(path, offset, join, cap, limit) {
-      var nonSIPath = getNonSelfItersectionPath(path);
+  function OffsetStroke(path, offset, join, cap, limit) {
+      var nonSIPath = path.unite(path, { insert: false });
       var result = nonSIPath;
       if (nonSIPath instanceof paper.Path) {
-          result = offsetSimpleStroke(nonSIPath, offset, join, cap, limit);
+          result = Offsets.OffsetSimpleStroke(nonSIPath, offset, join, cap, limit);
       }
       else {
-          var children = nonSIPath.children.flatMap(function (c) {
-              return offsetSimpleStroke(c, offset, join, cap, limit);
-          });
+          var children = arrayex.Arrayex.Flat(nonSIPath.children.map(function (c) {
+              return Offsets.OffsetSimpleStroke(c, offset, join, cap, limit);
+          }));
           result = children.reduce(function (c1, c2) { return c1.unite(c2, { insert: false }); });
       }
       result.strokeWidth = 0;
@@ -359,55 +354,44 @@
       return result;
   }
 
-  var PaperOffset = /** @class */ (function () {
-      function PaperOffset() {
+  function PrototypedOffset(path, offset, options) {
+      options = options || {};
+      var offsetPath = OffsetPath(path, offset, options.join || 'miter', options.limit || 10);
+      if (options.insert === undefined) {
+          options.insert = true;
       }
-      PaperOffset.offset = function (path, offset, options) {
-          options = options || {};
-          var newPath = offsetPath(path, offset, options.join || 'miter', options.limit || 10);
-          if (options.insert === undefined) {
-              options.insert = true;
-          }
-          if (options.insert) {
-              (path.parent || paper.project.activeLayer).addChild(newPath);
-          }
-          return newPath;
-      };
-      PaperOffset.offsetStroke = function (path, offset, options) {
-          options = options || {};
-          var newPath = offsetStroke(path, offset, options.join || 'miter', options.cap || 'butt', options.limit || 10);
-          if (options.insert === undefined) {
-              options.insert = true;
-          }
-          if (options.insert) {
-              (path.parent || paper.project.activeLayer).addChild(newPath);
-          }
-          return newPath;
-      };
-      return PaperOffset;
-  }());
-  /**
-   * @deprecated EXTEND existing paper module is not recommend anymore
-   */
-  function ExtendPaperJs(paperNs) {
-      paperNs.Path.prototype.offset = function (offset, options) {
-          return PaperOffset.offset(this, offset, options);
+      if (options.insert) {
+          (path.parent || paper.project.activeLayer).addChild(offsetPath);
+      }
+      return offsetPath;
+  }
+  function PrototypedOffsetStroke(path, offset, options) {
+      options = options || {};
+      var offsetPath = OffsetStroke(path, offset, options.join || 'miter', options.cap || 'butt', options.limit || 10);
+      if (options.insert === undefined) {
+          options.insert = true;
+      }
+      if (options.insert) {
+          (path.parent || paper.project.activeLayer).addChild(offsetPath);
+      }
+      return offsetPath;
+  }
+  function ExtendPaperJs(paper) {
+      paper.Path.prototype.offset = function (offset, options) {
+          return PrototypedOffset(this, offset, options);
       };
-      paperNs.Path.prototype.offsetStroke = function (offset, options) {
-          return PaperOffset.offsetStroke(this, offset, options);
+      paper.Path.prototype.offsetStroke = function (offset, options) {
+          return PrototypedOffsetStroke(this, offset, options);
       };
-      paperNs.CompoundPath.prototype.offset = function (offset, options) {
-          return PaperOffset.offset(this, offset, options);
+      paper.CompoundPath.prototype.offset = function (offset, options) {
+          return PrototypedOffset(this, offset, options);
       };
-      paperNs.CompoundPath.prototype.offsetStroke = function (offset, options) {
-          return PaperOffset.offsetStroke(this, offset, options);
+      paper.CompoundPath.prototype.offsetStroke = function (offset, options) {
+          return PrototypedOffsetStroke(this, offset, options);
       };
   }
 
-  exports.PaperOffset = PaperOffset;
-  exports.default = ExtendPaperJs;
-
-  Object.defineProperty(exports, '__esModule', { value: true });
+  return ExtendPaperJs;
 
-})));
+}));
 //# sourceMappingURL=index.umd.js.map
diff --git a/node_modules/paperjs-offset/dist/index.umd.js.map b/node_modules/paperjs-offset/dist/index.umd.js.map
index f46a718..074e31e 100644
--- a/node_modules/paperjs-offset/dist/index.umd.js.map
+++ b/node_modules/paperjs-offset/dist/index.umd.js.map
@@ -1 +1 @@
-{"version":3,"file":"index.umd.js","sources":["../src/offset_core.ts","../src/index.ts"],"sourcesContent":["import paper from 'paper';\n\nexport type StrokeJoinType = 'miter' | 'bevel' | 'round';\nexport type StrokeCapType = 'round' | 'butt';\nexport type PathType = paper.Path | paper.CompoundPath;\n\ntype HandleType = 'handleIn' | 'handleOut';\n\n/**\n * Offset the start/terminal segment of a bezier curve\n * @param segment segment to offset\n * @param curve curve to offset\n * @param handleNormal the normal of the the line formed of two handles\n * @param offset offset value\n */\nfunction offsetSegment(segment: paper.Segment, curve: paper.Curve, handleNormal: paper.Point, offset: number) {\n  const isFirst = segment.curve === curve;\n  // get offset vector\n  const offsetVector = (curve.getNormalAtTime(isFirst ? 0 : 1)).multiply(offset);\n  // get offset point\n  const point = segment.point.add(offsetVector);\n  const newSegment = new paper.Segment(point);\n  // handleOut for start segment & handleIn for terminal segment\n  const handle = (isFirst ? 'handleOut' : 'handleIn') as HandleType;\n  newSegment[handle] = segment[handle]!.add(handleNormal.subtract(offsetVector).divide(2));\n  return newSegment;\n}\n\n/**\n * Adaptive offset a curve by repeatly apply the approximation proposed by Tiller and Hanson.\n * @param curve curve to offset\n * @param offset offset value\n */\nfunction adaptiveOffsetCurve(curve: paper.Curve, offset: number): paper.Segment[] {\n  const hNormal = (new paper.Curve(curve.segment1.handleOut!.add(curve.segment1.point), new paper.Point(0, 0),\n    new paper.Point(0, 0), curve.segment2.handleIn!.add(curve.segment2.point))).getNormalAtTime(0.5).multiply(offset);\n  const segment1 = offsetSegment(curve.segment1, curve, hNormal, offset);\n  const segment2 = offsetSegment(curve.segment2, curve, hNormal, offset);\n  // divide && re-offset\n  const offsetCurve = new paper.Curve(segment1, segment2);\n  // if the offset curve is not self intersected, divide it\n  if (offsetCurve.getIntersections(offsetCurve).length === 0) {\n    const threshold = Math.min(Math.abs(offset) / 10, 1);\n    const midOffset = offsetCurve.getPointAtTime(0.5).getDistance(curve.getPointAtTime(0.5));\n    if (Math.abs(midOffset - Math.abs(offset)) > threshold) {\n      const subCurve = curve.divideAtTime(0.5);\n      if (subCurve != null) {\n        return [...adaptiveOffsetCurve(curve, offset), ...adaptiveOffsetCurve(subCurve, offset)];\n      }\n    }\n  }\n  return [segment1, segment2];\n}\n\n/**\n * Create a round join segment between two adjacent segments.\n */\nfunction makeRoundJoin(segment1: paper.Segment, segment2: paper.Segment, originPoint: paper.Point, radius: number) {\n  const through = segment1.point.subtract(originPoint).add(segment2.point.subtract(originPoint))\n    .normalize(Math.abs(radius)).add(originPoint);\n  const arc = new paper.Path.Arc({ from: segment1.point, to: segment2.point, through, insert: false });\n  segment1.handleOut = arc.firstSegment.handleOut;\n  segment2.handleIn = arc.lastSegment.handleIn;\n  return arc.segments.length === 3 ? arc.segments[1] : null;\n}\n\nfunction det(p1: paper.Point, p2: paper.Point) {\n  return p1.x * p2.y - p1.y * p2.x;\n}\n\n/**\n * Get the intersection point of point based lines\n */\nfunction getPointLineIntersections(p1: paper.Point, p2: paper.Point, p3: paper.Point, p4: paper.Point) {\n  const l1 = p1.subtract(p2);\n  const l2 = p3.subtract(p4);\n  const dl1 = det(p1, p2);\n  const dl2 = det(p3, p4);\n  return new paper.Point(dl1 * l2.x - l1.x * dl2, dl1 * l2.y - l1.y * dl2).divide(det(l1, l2));\n}\n\n/**\n * Connect two adjacent bezier curve, each curve is represented by two segments,\n * create different types of joins or simply removal redundant segment.\n */\nfunction connectAdjacentBezier(segments1: paper.Segment[], segments2: paper.Segment[], origin: paper.Segment, joinType: StrokeJoinType, offset: number, limit: number) {\n  const curve1 = new paper.Curve(segments1[0], segments1[1]);\n  const curve2 = new paper.Curve(segments2[0], segments2[1]);\n  const intersection = curve1.getIntersections(curve2);\n  const distance = segments1[1].point.getDistance(segments2[0].point);\n  if (origin.isSmooth()) {\n    segments2[0].handleOut = segments2[0].handleOut!.project(origin.handleOut!);\n    segments2[0].handleIn = segments1[1].handleIn!.project(origin.handleIn!);\n    segments2[0].point = segments1[1].point.add(segments2[0].point).divide(2);\n    segments1.pop();\n  } else {\n    if (intersection.length === 0) {\n      if (distance > Math.abs(offset) * 0.1) {\n        // connect\n        switch (joinType) {\n          case 'miter':\n            const join = getPointLineIntersections(curve1.point2, curve1.point2.add(curve1.getTangentAtTime(1)),\n              curve2.point1, curve2.point1.add(curve2.getTangentAtTime(0)));\n            // prevent sharp angle\n            const joinOffset = Math.max(join.getDistance(curve1.point2), join.getDistance(curve2.point1));\n            if (joinOffset < Math.abs(offset) * limit) {\n              segments1.push(new paper.Segment(join));\n            }\n            break;\n          case 'round':\n            const mid = makeRoundJoin(segments1[1], segments2[0], origin.point, offset);\n            if (mid) {\n              segments1.push(mid);\n            }\n            break;\n          default: break;\n        }\n      } else {\n        segments2[0].handleIn = segments1[1].handleIn;\n        segments1.pop();\n      }\n    } else {\n      const second1 = curve1.divideAt(intersection[0]);\n      if (second1) {\n        const join = second1.segment1;\n        const second2 = curve2.divideAt(curve2.getIntersections(curve1)[0]);\n        join.handleOut = second2 ? second2.segment1.handleOut : segments2[0].handleOut;\n        segments1.pop();\n        segments2[0] = join;\n      } else {\n        segments2[0].handleIn = segments1[1].handleIn;\n        segments1.pop();\n      }\n    }\n  }\n}\n\n/**\n * Connect all the segments together.\n */\nfunction connectBeziers(rawSegments: paper.Segment[][], join: StrokeJoinType, source: paper.Path, offset: number, limit: number) {\n  const originSegments = source.segments;\n  const first = rawSegments[0].slice();\n  for (let i = 0; i < rawSegments.length - 1; ++i) {\n    connectAdjacentBezier(rawSegments[i], rawSegments[i + 1], originSegments[i + 1], join, offset, limit);\n  }\n  if (source.closed) {\n    connectAdjacentBezier(rawSegments[rawSegments.length - 1], first, originSegments[0], join, offset, limit);\n    rawSegments[0][0] = first[0];\n  }\n  return rawSegments;\n}\n\nfunction reduceSingleChildCompoundPath(path: PathType) {\n  if (path.children.length === 1) {\n    path = path.children[0] as paper.Path;\n    path.remove(); // remove from parent, this is critical, or the style attributes will be ignored\n  }\n  return path;\n}\n\n/** Normalize a path, always clockwise, non-self-intersection, ignore really small components, and no one-component compound path. */\nfunction normalize(path: PathType, areaThreshold = 0.01) {\n  if (path.closed) {\n    const ignoreArea = Math.abs(path.area * areaThreshold);\n    if (!path.clockwise) {\n      path.reverse();\n    }\n    path = path.unite(path, { insert: false }) as PathType;\n    if (path instanceof paper.CompoundPath) {\n      path.children.filter((c) => Math.abs((c as PathType).area) < ignoreArea).forEach((c) => c.remove());\n      if (path.children.length === 1) {\n        return reduceSingleChildCompoundPath(path);\n      }\n    }\n  }\n  return path;\n}\n\nfunction isSameDirection(partialPath: paper.Path, fullPath: PathType) {\n  const offset1 = partialPath.segments[0].location.offset;\n  const offset2 = partialPath.segments[Math.max(1, Math.floor(partialPath.segments.length / 2))].location.offset;\n  const sampleOffset = (offset1 + offset2) / 3;\n  const originOffset1 = fullPath.getNearestLocation(partialPath.getPointAt(sampleOffset)).offset;\n  const originOffset2 = fullPath.getNearestLocation(partialPath.getPointAt(2 * sampleOffset)).offset;\n  return originOffset1 < originOffset2;\n}\n\n/** Remove self intersection when offset is negative by point direction dectection. */\nfunction removeIntersection(path: PathType) {\n  if (path.closed) {\n    const newPath = path.unite(path, { insert: false }) as PathType;\n    if (newPath instanceof paper.CompoundPath) {\n      (newPath.children as paper.Path[]).filter((c) => {\n        if (c.segments.length > 1) {\n          return !isSameDirection(c, path);\n        } else {\n          return true;\n        }\n      }).forEach((c) => c.remove());\n      return reduceSingleChildCompoundPath(newPath);\n    }\n  }\n  return path;\n}\n\nfunction getSegments(path: PathType) {\n  if (path instanceof paper.CompoundPath) {\n    return path.children.map((c) => (c as paper.Path).segments).flat();\n  } else {\n    return (path as paper.Path).segments;\n  }\n}\n\n/**\n * Remove impossible segments in negative offset condition.\n */\nfunction removeOutsiders(newPath: PathType, path: PathType) {\n  const segments = getSegments(newPath).slice();\n  segments.forEach((segment) => {\n    if (!path.contains(segment.point)) {\n      segment.remove();\n    }\n  });\n}\n\nfunction preparePath(path: paper.Path, offset: number): [paper.Path, number] {\n  const source = path.clone({ insert: false }) as paper.Path;\n  source.reduce({});\n  if (!path.clockwise) {\n    source.reverse();\n    offset = -offset;\n  }\n  return [source, offset];\n}\n\nfunction offsetSimpleShape(path: paper.Path, offset: number, join: StrokeJoinType, limit: number): PathType {\n  let source: paper.Path;\n  [source, offset] = preparePath(path, offset);\n  const curves = source.curves.slice();\n  const offsetCurves = curves.map((curve) => adaptiveOffsetCurve(curve, offset)).flat();\n  const raws: paper.Segment[][] = [];\n  for (let i = 0; i < offsetCurves.length; i += 2) {\n    raws.push(offsetCurves.slice(i, i + 2));\n  }\n  const segments = connectBeziers(raws, join, source, offset, limit).flat();\n  const newPath = removeIntersection(new paper.Path({ segments, insert: false, closed: path.closed }));\n  newPath.reduce({});\n  if (source.closed && ((source.clockwise && offset < 0) || (!source.clockwise && offset > 0))) {\n    removeOutsiders(newPath, path);\n  }\n  // recovery path\n  if (source.clockwise !== path.clockwise) {\n    newPath.reverse();\n  }\n  return normalize(newPath);\n}\n\nfunction makeRoundCap(from: paper.Segment, to: paper.Segment, offset: number) {\n  const origin = from.point.add(to.point).divide(2);\n  const normal = to.point.subtract(from.point).rotate(-90, new paper.Point(0, 0)).normalize(offset);\n  const through = origin.add(normal);\n  const arc = new paper.Path.Arc({ from: from.point, to: to.point, through, insert: false });\n  return arc.segments;\n}\n\nfunction connectSide(outer: PathType, inner: paper.Path, offset: number, cap: StrokeCapType): paper.Path {\n  if (outer instanceof paper.CompoundPath) {\n    let cs = outer.children.map((c) => ({ c, a: Math.abs((c as paper.Path).area) }));\n    cs = cs.sort((c1, c2) => c2.a - c1.a);\n    outer = cs[0].c as paper.Path;\n  }\n  const oSegments = (outer as paper.Path).segments.slice();\n  const iSegments = inner.segments.slice();\n  switch (cap) {\n    case 'round':\n      const heads = makeRoundCap(iSegments[iSegments.length - 1], oSegments[0], offset);\n      const tails = makeRoundCap(oSegments[oSegments.length - 1], iSegments[0], offset);\n      const result = new paper.Path({ segments: [...heads, ...oSegments, ...tails, ...iSegments], closed: true, insert: false });\n      result.reduce({});\n      return result;\n    default: return new paper.Path({ segments: [...oSegments, ...iSegments], closed: true, insert: false });\n  }\n}\n\nfunction offsetSimpleStroke(path: paper.Path, offset: number, join: StrokeJoinType, cap: StrokeCapType, limit: number): PathType {\n  offset = path.clockwise ? offset : -offset;\n  const positiveOffset = offsetSimpleShape(path, offset, join, limit);\n  const negativeOffset = offsetSimpleShape(path, -offset, join, limit);\n  if (path.closed) {\n    return positiveOffset.subtract(negativeOffset, { insert: false }) as PathType;\n  } else {\n    let inner = negativeOffset;\n    let holes = new Array<paper.Path>();\n    if (negativeOffset instanceof paper.CompoundPath) {\n      holes = negativeOffset.children.filter((c) => (c as paper.Path).closed) as paper.Path[];\n      holes.forEach((h) => h.remove());\n      inner = negativeOffset.children[0] as paper.Path;\n    }\n    inner.reverse();\n    let final = connectSide(positiveOffset, inner as paper.Path, offset, cap) as PathType;\n    if (holes.length > 0) {\n      for (const hole of holes) {\n        final = final.subtract(hole, { insert: false }) as PathType;\n      }\n    }\n    return final;\n  }\n}\n\nfunction getNonSelfItersectionPath(path: PathType) {\n  if (path.closed) {\n    return path.unite(path, { insert: false }) as PathType;\n  }\n  return path;\n}\n\nexport function offsetPath(path: PathType, offset: number, join: StrokeJoinType, limit: number): PathType {\n  const nonSIPath = getNonSelfItersectionPath(path);\n  let result = nonSIPath;\n  if (nonSIPath instanceof paper.Path) {\n    result = offsetSimpleShape(nonSIPath, offset, join, limit);\n  } else {\n    const offsetParts = (nonSIPath.children as paper.Path[]).map((c) => {\n      if (c.segments.length > 1) {\n        if (!isSameDirection(c, path)) {\n          c.reverse();\n        }\n        let offseted = offsetSimpleShape(c, offset, join, limit);\n        offseted = normalize(offseted);\n        if (offseted.clockwise !== c.clockwise) {\n          offseted.reverse();\n        }\n        if (offseted instanceof paper.CompoundPath) {\n          offseted.applyMatrix = true;\n          return offseted.children;\n        } else {\n          return offseted;\n        }\n      } else {\n        return null;\n      }\n    });\n    const children = offsetParts.flat().filter((c) => !!c) as paper.Item[];\n    result = new paper.CompoundPath({ children, insert: false });\n  }\n  result.copyAttributes(nonSIPath, false);\n  result.remove();\n  return result;\n}\n\nexport function offsetStroke(path: PathType, offset: number, join: StrokeJoinType, cap: StrokeCapType, limit: number): PathType {\n  const nonSIPath = getNonSelfItersectionPath(path);\n  let result = nonSIPath;\n  if (nonSIPath instanceof paper.Path) {\n    result = offsetSimpleStroke(nonSIPath, offset, join, cap, limit);\n  } else {\n    const children = (nonSIPath.children as paper.Path[]).flatMap((c) => {\n      return offsetSimpleStroke(c, offset, join, cap, limit);\n    });\n    result = children.reduce((c1, c2) => c1.unite(c2, { insert: false }) as PathType);\n  }\n  result.strokeWidth = 0;\n  result.fillColor = nonSIPath.strokeColor;\n  result.shadowBlur = nonSIPath.shadowBlur;\n  result.shadowColor = nonSIPath.shadowColor;\n  result.shadowOffset = nonSIPath.shadowOffset;\n  return result;\n}\n","import paper from 'paper';\nimport { StrokeJoinType, PathType, StrokeCapType, offsetPath, offsetStroke } from './offset_core';\n\nexport interface OffsetOptions {\n  join?: StrokeJoinType;\n  cap?: StrokeCapType;\n  limit?: number;\n  insert?: boolean;\n}\n\nexport class PaperOffset {\n  public static offset(path: PathType, offset: number, options?: OffsetOptions): PathType {\n    options = options || {};\n    const newPath = offsetPath(path, offset, options.join || 'miter', options.limit || 10);\n    if (options.insert === undefined) {\n      options.insert = true;\n    }\n    if (options.insert) {\n      (path.parent || paper.project.activeLayer).addChild(newPath);\n    }\n    return newPath;\n  }\n\n  public static offsetStroke(path: PathType, offset: number, options?: OffsetOptions): PathType {\n    options = options || {};\n    const newPath = offsetStroke(path, offset, options.join || 'miter', options.cap || 'butt', options.limit || 10);\n    if (options.insert === undefined) {\n      options.insert = true;\n    }\n    if (options.insert) {\n      (path.parent || paper.project.activeLayer).addChild(newPath);\n    }\n    return newPath;\n  }\n}\n\n/**\n * @deprecated EXTEND existing paper module is not recommend anymore\n */\nexport default function ExtendPaperJs(paperNs: any) {\n  paperNs.Path.prototype.offset = function(offset: number, options?: OffsetOptions) {\n    return PaperOffset.offset(this, offset, options);\n  };\n\n  paperNs.Path.prototype.offsetStroke = function(offset: number, options?: OffsetOptions) {\n    return PaperOffset.offsetStroke(this, offset, options);\n  };\n\n  paperNs.CompoundPath.prototype.offset = function(offset: number, options?: OffsetOptions) {\n    return PaperOffset.offset(this, offset, options);\n  };\n\n  paperNs.CompoundPath.prototype.offsetStroke = function(offset: number, options?: OffsetOptions) {\n    return PaperOffset.offsetStroke(this, offset, options);\n  };\n}\n"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"index.umd.js","sources":["../src/Offset.ts","../src/index.ts"],"sourcesContent":["import paper, { Point } from 'paper'\nimport { Arrayex } from 'arrayex'\n\ntype HandleType = 'handleIn' | 'handleOut'\nexport type StrokeJoinType = 'miter' | 'bevel' | 'round'\nexport type StrokeCapType = 'round' | 'butt'\nexport type PathType = paper.Path | paper.CompoundPath\n\nnamespace Offsets {\n  /**\n   * Offset the start/terminal segment of a bezier curve\n   * @param segment segment to offset\n   * @param curve curve to offset\n   * @param handleNormal the normal of the the line formed of two handles\n   * @param offset offset value\n   */\n  function OffsetSegment(segment: paper.Segment, curve: paper.Curve, handleNormal: paper.Point, offset: number) {\n    let isFirst = segment.curve === curve\n    // get offset vector\n    let offsetVector = (curve.getNormalAt(isFirst ? 0 : 1, true)).multiply(offset)\n    // get offset point\n    let point = segment.point.add(offsetVector)\n    let newSegment = new paper.Segment(point)\n    // handleOut for start segment & handleIn for terminal segment\n    let handle = (isFirst ? 'handleOut' : 'handleIn') as HandleType\n    newSegment[handle] = segment[handle]!.add(handleNormal.subtract(offsetVector).divide(2))\n    return newSegment\n  }\n\n  /**\n   * Adaptive offset a curve by repeatly apply the approximation proposed by Tiller and Hanson.\n   * @param curve curve to offset\n   * @param offset offset value\n   */\n  function AdaptiveOffsetCurve(curve: paper.Curve, offset: number): Array<paper.Segment> {\n    offset\n    let hNormal = (new paper.Curve(curve.segment1.handleOut!.add(curve.segment1.point), new paper.Point(0, 0), new paper.Point(0, 0), curve.segment2.handleIn!.add(curve.segment2.point))).getNormalAt(0.5, true).multiply(offset)\n    let segment1 = OffsetSegment(curve.segment1, curve, hNormal, offset)\n    let segment2 = OffsetSegment(curve.segment2, curve, hNormal, offset)\n    // divide && re-offset\n    let offsetCurve = new paper.Curve(segment1, segment2)\n    // if the offset curve is not self intersected, divide it\n    if (offsetCurve.getIntersections(offsetCurve).length === 0) {\n      let threshold = Math.min(Math.abs(offset) / 10, 1)\n      let midOffset = offsetCurve.getPointAt(0.5, true).getDistance(curve.getPointAt(0.5, true))\n      if (Math.abs(midOffset - Math.abs(offset)) > threshold) {\n        let subCurve = curve.divideAtTime(0.5)\n        if (subCurve != null) {\n          return [...AdaptiveOffsetCurve(curve, offset), ...AdaptiveOffsetCurve(subCurve, offset)]\n        }\n      }\n    }\n    return [segment1, segment2]\n  }\n\n  /**\n   * Create a round join segment between two adjacent segments.\n   */\n  function MakeRoundJoin(segment1: paper.Segment, segment2: paper.Segment, originPoint: paper.Point, radius: number) {\n    let through = segment1.point.subtract(originPoint).add(segment2.point.subtract(originPoint)).normalize(Math.abs(radius)).add(originPoint)\n    let arc = new paper.Path.Arc({ from: segment1.point, to: segment2.point, through, insert: false })\n    segment1.handleOut = arc.firstSegment.handleOut\n    segment2.handleIn = arc.lastSegment.handleIn\n    return arc.segments.length === 3 ? arc.segments[1] : null\n  }\n\n  function Det(p1: paper.Point, p2: paper.Point) {\n    return p1.x * p2.y - p1.y * p2.x\n  }\n\n  /**\n   * Get the intersection point of two point\n   */\n  function Intersection(p1: paper.Point, p2: paper.Point, p3: paper.Point, p4: paper.Point) {\n    let l1 = p1.subtract(p2)\n    let l2 = p3.subtract(p4)\n    let dl1 = Det(p1, p2)\n    let dl2 = Det(p3, p4)\n    return new paper.Point(dl1 * l2.x - l1.x * dl2, dl1 * l2.y - l1.y * dl2).divide(Det(l1, l2))\n  }\n\n  /**\n   * Connect two adjacent bezier curve, each curve is represented by two segments, create different types of joins or simply removal redundant segment.\n   */\n  export function ConnectAdjacentBezier(segments1: Array<paper.Segment>, segments2: Array<paper.Segment>, origin: paper.Segment, join: StrokeJoinType, offset: number, limit: number) {\n    let curve1 = new paper.Curve(segments1[0], segments1[1])\n    let curve2 = new paper.Curve(segments2[0], segments2[1])\n    let intersection = curve1.getIntersections(curve2)\n    let distance = segments1[1].point.getDistance(segments2[0].point)\n    if (origin.isSmooth()) {\n      segments2[0].handleOut = segments2[0].handleOut!.project(origin.handleOut!)\n      segments2[0].handleIn = segments1[1].handleIn!.project(origin.handleIn!)\n      segments2[0].point = segments1[1].point.add(segments2[0].point).divide(2)\n      segments1.pop()\n    } else {\n      if (intersection.length === 0) {\n        if (distance > Math.abs(offset) * 0.1) {\n          // connect\n          switch (join) {\n            case 'miter':\n              let join = Intersection(curve1.point2, curve1.point2.add(curve1.getTangentAt(1, true)), curve2.point1, curve2.point1.add(curve2.getTangentAt(0, true)))\n              // prevent sharp angle\n              let joinOffset = Math.max(join.getDistance(curve1.point2), join.getDistance(curve2.point1))\n              if (joinOffset < Math.abs(offset) * limit) {\n                segments1.push(new paper.Segment(join))\n              }\n              break\n            case 'round':\n              let mid = MakeRoundJoin(segments1[1], segments2[0], origin.point, offset)\n              if (mid) {\n                segments1.push(mid)\n              }\n              break\n            default: break\n          }\n        } else {\n          segments2[0].handleIn = segments1[1].handleIn\n          segments1.pop()\n        }\n      } else {\n        let second1 = curve1.divideAt(intersection[0])\n        if (second1) {\n          let join = second1.segment1\n          let second2 = curve2.divideAt(curve2.getIntersections(curve1)[0])\n          join.handleOut = second2 ? second2.segment1.handleOut : segments2[0].handleOut\n          segments1.pop()\n          segments2[0] = join\n        } else {\n          segments2[0].handleIn = segments1[1].handleIn\n          segments1.pop()\n        }\n      }\n    }\n  }\n\n  /**\n   * Connect all the segments together.\n   */\n  function ConnectBeziers(rawSegments: Array<Array<paper.Segment>>, join: StrokeJoinType, source: paper.Path, offset: number, limit: number) {\n    let originSegments = source.segments\n    let first = rawSegments[0].slice()\n    for (let i = 0; i < rawSegments.length - 1; ++i) {\n      ConnectAdjacentBezier(rawSegments[i], rawSegments[i + 1], originSegments[i + 1], join, offset, limit)\n    }\n    if (source.closed) {\n      ConnectAdjacentBezier(rawSegments[rawSegments.length - 1], first, originSegments[0], join, offset, limit)\n      rawSegments[0][0] = first[0]\n    }\n    return rawSegments\n  }\n\n  function Decompound(path: PathType) {\n    if (path.children.length === 1) {\n      path = path.children[0] as paper.Path\n      path.remove() // remove from parent, this is critical, or the style attributes will be ignored\n    }\n    return path\n  }\n\n  /** Normalize a path, always clockwise, non-self-intersection, ignore really small components, and no one-component compound path. */\n  export function Normalize(path: PathType, areaThreshold = 0.01) {\n    if (path.closed) {\n      let ignoreArea = Math.abs(path.area * areaThreshold)\n      if (!path.clockwise) {\n        path.reverse()\n      }\n      path = path.unite(path, { insert: false }) as PathType\n      if (path instanceof paper.CompoundPath) {\n        path.children.filter(c => Math.abs((c as PathType).area) < ignoreArea).forEach(c => c.remove())\n        if (path.children.length === 1) {\n          return Decompound(path)\n        }\n      }\n    }\n    return path\n  }\n\n  export function IsSameDirection(partialPath: paper.Path, fullPath: PathType) {\n    let offset1 = partialPath.segments[0].location.offset\n    let offset2 = partialPath.segments[Math.max(1, Math.floor(partialPath.segments.length / 2))].location.offset\n    let sampleOffset = (offset1 + offset2) / 3\n    let originOffset1 = fullPath.getNearestLocation(partialPath.getPointAt(sampleOffset)).offset\n    let originOffset2 = fullPath.getNearestLocation(partialPath.getPointAt(2 * sampleOffset)).offset\n    return originOffset1 < originOffset2\n  }\n\n  /** Remove self intersection when offset is negative by point direction dectection. */\n  export function RemoveIntersection(path: PathType) {\n    let newPath = path.unite(path, { insert: false }) as PathType\n    if (newPath instanceof paper.CompoundPath) {\n      (newPath.children as Array<paper.Path>).filter(c => {\n        if (c.segments.length > 1) {\n          return !IsSameDirection(c, path)\n        } else {\n          return true\n        }\n      }).forEach(c => c.remove())\n      return Decompound(newPath)\n    }\n    return path\n  }\n\n  function Segments(path: PathType) {\n    if (path instanceof paper.CompoundPath) {\n      return Arrayex.Flat<paper.Segment>(path.children.map(c => (c as paper.Path).segments))\n    } else {\n      return (path as paper.Path).segments\n    }\n  }\n\n  /**\n   * Remove impossible segments in negative offset condition.\n   */\n  function RemoveOutsiders(offsetPath: PathType, path: PathType) {\n    let segments = Segments(offsetPath).slice()\n    segments.forEach(segment => {\n      if (!path.contains(segment.point)) {\n        segment.remove()\n      }\n    })\n  }\n\n  function PreparePath(path: paper.Path, offset: number): [paper.Path, number] {\n    let source = path.clone({ insert: false }) as paper.Path\n    source.reduce()\n    if (!path.clockwise) {\n      source.reverse()\n      offset = -offset\n    }\n    return [source, offset]\n  }\n\n  export function OffsetSimpleShape(path: paper.Path, offset: number, join: StrokeJoinType, limit: number): PathType {\n    let source: paper.Path\n    [source, offset] = PreparePath(path, offset)\n    let curves = source.curves.slice()\n    let raws = Arrayex.Divide(Arrayex.Flat<paper.Segment>(curves.map(curve => AdaptiveOffsetCurve(curve, offset))), 2)\n    let segments = Arrayex.Flat(ConnectBeziers(raws, join, source, offset, limit))\n    let offsetPath = RemoveIntersection(new paper.Path({ segments, insert: false, closed: path.closed }))\n    offsetPath.reduce()\n    if (source.closed && ((source.clockwise && offset < 0) || (!source.clockwise && offset > 0))) {\n      RemoveOutsiders(offsetPath, path)\n    }\n    // recovery path\n    if (source.clockwise !== path.clockwise) {\n      offsetPath.reverse()\n    }\n    return Normalize(offsetPath)\n  }\n\n  function MakeRoundCap(from: paper.Segment, to: paper.Segment, offset: number) {\n    let origin = from.point.add(to.point).divide(2)\n    let normal = to.point.subtract(from.point).rotate(-90).normalize(offset)\n    let through = origin.add(normal)\n    let arc = new paper.Path.Arc({ from: from.point, to: to.point, through, insert: false })\n    return arc.segments\n  }\n\n  function ConnectSide(outer: PathType, inner: paper.Path, offset: number, cap: StrokeCapType): paper.Path {\n    if (outer instanceof paper.CompoundPath) {\n      let cs = outer.children.map(c => ({ c, a: Math.abs((c as paper.Path).area) }))\n      cs = cs.sort((c1, c2) => c2.a - c1.a)\n      outer = cs[0].c as paper.Path\n    }\n    let oSegments = (outer as paper.Path).segments.slice()\n    let iSegments = inner.segments.slice()\n    switch (cap) {\n      case 'round':\n        let heads = MakeRoundCap(iSegments[iSegments.length - 1], oSegments[0], offset)\n        let tails = MakeRoundCap(oSegments[oSegments.length - 1], iSegments[0], offset)\n        let result = new paper.Path({ segments: [...heads, ...oSegments, ...tails, ...iSegments], closed: true, insert: false })\n        result.reduce()\n        return result\n      default: return new paper.Path({ segments: [...oSegments, ...iSegments], closed: true, insert: false })\n    }\n  }\n\n  export function OffsetSimpleStroke(path: paper.Path, offset: number, join: StrokeJoinType, cap: StrokeCapType, limit: number): PathType {\n    offset = path.clockwise ? offset : -offset\n    let positiveOffset = OffsetSimpleShape(path, offset, join, limit)\n    let negativeOffset = OffsetSimpleShape(path, -offset, join, limit)\n    if (path.closed) {\n      return positiveOffset.subtract(negativeOffset, { insert: false }) as PathType\n    } else {\n      let inner = negativeOffset\n      let holes = new Array<paper.Path>()\n      if (negativeOffset instanceof paper.CompoundPath) {\n        holes = negativeOffset.children.filter(c => (c as paper.Path).closed) as Array<paper.Path>\n        holes.forEach(h => h.remove())\n        inner = negativeOffset.children[0] as paper.Path\n      }\n      inner.reverse()\n      let final = ConnectSide(positiveOffset, inner as paper.Path, offset, cap) as PathType\n      if (holes.length > 0) {\n        for(let hole of holes) {\n          final = final.subtract(hole, { insert: false }) as PathType\n        }\n      }\n      return final\n    }\n  }\n}\n\nexport function OffsetPath(path: PathType, offset: number, join: StrokeJoinType, limit: number) {\n  let nonSIPath = path.unite(path, { insert: false }) as PathType\n  let result = nonSIPath\n  if (nonSIPath instanceof paper.Path) {\n    result = Offsets.OffsetSimpleShape(nonSIPath, offset, join, limit)\n  } else {\n    let children = Arrayex.Flat((nonSIPath.children as Array<paper.Path>).map(c => {\n      if (c.segments.length > 1) {\n        if (!Offsets.IsSameDirection(c, path)) {\n          c.reverse()\n        }\n        let offseted = Offsets.OffsetSimpleShape(c, offset, join, limit)\n        offseted = Offsets.Normalize(offseted)\n        if (offseted.clockwise !== c.clockwise) {\n          offseted.reverse()\n        }\n        if (offseted instanceof paper.CompoundPath) {\n          offseted.applyMatrix = true\n          return offseted.children\n        } else {\n          return offseted\n        }\n      } else {\n        return null\n      }\n    }), false)\n    result = new paper.CompoundPath({ children, insert: false })\n  }\n  result.copyAttributes(nonSIPath, false)\n  result.remove()\n  return result\n}\n\nexport function OffsetStroke(path: PathType, offset: number, join: StrokeJoinType, cap: StrokeCapType, limit: number) {\n  let nonSIPath = path.unite(path, { insert: false }) as PathType\n  let result = nonSIPath as PathType\n  if (nonSIPath instanceof paper.Path) {\n    result = Offsets.OffsetSimpleStroke(nonSIPath, offset, join, cap, limit)\n  } else {\n    let children = Arrayex.Flat((nonSIPath.children as Array<paper.Path>).map(c => {\n      return Offsets.OffsetSimpleStroke(c, offset, join, cap, limit)\n    }))\n    result = children.reduce((c1, c2) => c1.unite(c2, { insert: false }) as PathType)\n  }\n  result.strokeWidth = 0\n  result.fillColor = nonSIPath.strokeColor\n  result.shadowBlur = nonSIPath.shadowBlur\n  result.shadowColor = nonSIPath.shadowColor\n  result.shadowOffset = nonSIPath.shadowOffset\n  return result\n}\n","import paper from 'paper'\r\nimport { OffsetPath, StrokeJoinType, PathType, StrokeCapType, OffsetStroke } from './Offset'\r\n\r\nexport interface OffsetOptions {\r\n  join?: StrokeJoinType,\r\n  cap?: StrokeCapType,\r\n  limit?: number,\r\n  insert?: boolean,\r\n}\r\n\r\ndeclare module 'paper' {\r\n  interface Path {\r\n    offset(offset: number, options?: OffsetOptions): PathType\r\n    offsetStroke(offset: number, options?: OffsetOptions): PathType | paper.Group\r\n  }\r\n\r\n  interface CompoundPath {\r\n    offset(offset: number, options?: OffsetOptions): PathType\r\n    offsetStroke(offset: number, options?: OffsetOptions): PathType | paper.Group\r\n  }\r\n}\r\n\r\nfunction PrototypedOffset(path: PathType, offset: number, options?: OffsetOptions) {\r\n  options = options || {}\r\n  let offsetPath = OffsetPath(path, offset, options.join || 'miter', options.limit || 10)\r\n  if (options.insert === undefined) {\r\n    options.insert = true\r\n  }\r\n  if (options.insert) {\r\n    (path.parent || paper.project.activeLayer).addChild(offsetPath)\r\n  }\r\n  return offsetPath\r\n}\r\n\r\nfunction PrototypedOffsetStroke(path: PathType, offset: number, options?: OffsetOptions) {\r\n  options = options || {}\r\n  let offsetPath = OffsetStroke(path, offset, options.join || 'miter', options.cap || 'butt', options.limit || 10)\r\n  if (options.insert === undefined) {\r\n    options.insert = true\r\n  }\r\n  if (options.insert) {\r\n    (path.parent || paper.project.activeLayer).addChild(offsetPath)\r\n  }\r\n  return offsetPath\r\n}\r\n\r\nexport default function ExtendPaperJs(paper: any) {\r\n  paper.Path.prototype.offset = function(offset: number, options?: OffsetOptions) {\r\n    return PrototypedOffset(this, offset, options)\r\n  }\r\n\r\n  paper.Path.prototype.offsetStroke = function (offset: number, options?: OffsetOptions) {\r\n    return PrototypedOffsetStroke(this, offset, options)\r\n  }\r\n\r\n  paper.CompoundPath.prototype.offset = function(offset: number, options?: OffsetOptions) {\r\n    return PrototypedOffset(this, offset, options)\r\n  }\r\n\r\n  paper.CompoundPath.prototype.offsetStroke = function (offset: number, options?: OffsetOptions) {\r\n    return PrototypedOffsetStroke(this, offset, options)\r\n  }\r\n}\r\n"],"names":["Arrayex"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/paperjs-offset/dist/lib/Offset.js b/node_modules/paperjs-offset/dist/lib/Offset.js
new file mode 100644
index 0000000..da2f4ba
--- /dev/null
+++ b/node_modules/paperjs-offset/dist/lib/Offset.js
@@ -0,0 +1,355 @@
+"use strict";
+Object.defineProperty(exports, "__esModule", { value: true });
+var paper_1 = require("paper");
+var arrayex_1 = require("arrayex");
+var Offsets;
+(function (Offsets) {
+    /**
+     * Offset the start/terminal segment of a bezier curve
+     * @param segment segment to offset
+     * @param curve curve to offset
+     * @param handleNormal the normal of the the line formed of two handles
+     * @param offset offset value
+     */
+    function OffsetSegment(segment, curve, handleNormal, offset) {
+        var isFirst = segment.curve === curve;
+        // get offset vector
+        var offsetVector = (curve.getNormalAt(isFirst ? 0 : 1, true)).multiply(offset);
+        // get offset point
+        var point = segment.point.add(offsetVector);
+        var newSegment = new paper_1.default.Segment(point);
+        // handleOut for start segment & handleIn for terminal segment
+        var handle = (isFirst ? 'handleOut' : 'handleIn');
+        newSegment[handle] = segment[handle].add(handleNormal.subtract(offsetVector).divide(2));
+        return newSegment;
+    }
+    /**
+     * Adaptive offset a curve by repeatly apply the approximation proposed by Tiller and Hanson.
+     * @param curve curve to offset
+     * @param offset offset value
+     */
+    function AdaptiveOffsetCurve(curve, offset) {
+        offset;
+        var hNormal = (new paper_1.default.Curve(curve.segment1.handleOut.add(curve.segment1.point), new paper_1.default.Point(0, 0), new paper_1.default.Point(0, 0), curve.segment2.handleIn.add(curve.segment2.point))).getNormalAt(0.5, true).multiply(offset);
+        var segment1 = OffsetSegment(curve.segment1, curve, hNormal, offset);
+        var segment2 = OffsetSegment(curve.segment2, curve, hNormal, offset);
+        // divide && re-offset
+        var offsetCurve = new paper_1.default.Curve(segment1, segment2);
+        // if the offset curve is not self intersected, divide it
+        if (offsetCurve.getIntersections(offsetCurve).length === 0) {
+            var threshold = Math.min(Math.abs(offset) / 10, 1);
+            var midOffset = offsetCurve.getPointAt(0.5, true).getDistance(curve.getPointAt(0.5, true));
+            if (Math.abs(midOffset - Math.abs(offset)) > threshold) {
+                var subCurve = curve.divideAtTime(0.5);
+                if (subCurve != null) {
+                    return AdaptiveOffsetCurve(curve, offset).concat(AdaptiveOffsetCurve(subCurve, offset));
+                }
+            }
+        }
+        return [segment1, segment2];
+    }
+    /**
+     * Create a round join segment between two adjacent segments.
+     */
+    function MakeRoundJoin(segment1, segment2, originPoint, radius) {
+        var through = segment1.point.subtract(originPoint).add(segment2.point.subtract(originPoint)).normalize(Math.abs(radius)).add(originPoint);
+        var arc = new paper_1.default.Path.Arc({ from: segment1.point, to: segment2.point, through: through, insert: false });
+        segment1.handleOut = arc.firstSegment.handleOut;
+        segment2.handleIn = arc.lastSegment.handleIn;
+        return arc.segments.length === 3 ? arc.segments[1] : null;
+    }
+    function Det(p1, p2) {
+        return p1.x * p2.y - p1.y * p2.x;
+    }
+    /**
+     * Get the intersection point of two point
+     */
+    function Intersection(p1, p2, p3, p4) {
+        var l1 = p1.subtract(p2);
+        var l2 = p3.subtract(p4);
+        var dl1 = Det(p1, p2);
+        var dl2 = Det(p3, p4);
+        return new paper_1.default.Point(dl1 * l2.x - l1.x * dl2, dl1 * l2.y - l1.y * dl2).divide(Det(l1, l2));
+    }
+    /**
+     * Connect two adjacent bezier curve, each curve is represented by two segments, create different types of joins or simply removal redundant segment.
+     */
+    function ConnectAdjacentBezier(segments1, segments2, origin, join, offset, limit) {
+        var curve1 = new paper_1.default.Curve(segments1[0], segments1[1]);
+        var curve2 = new paper_1.default.Curve(segments2[0], segments2[1]);
+        var intersection = curve1.getIntersections(curve2);
+        var distance = segments1[1].point.getDistance(segments2[0].point);
+        if (origin.isSmooth()) {
+            segments2[0].handleOut = segments2[0].handleOut.project(origin.handleOut);
+            segments2[0].handleIn = segments1[1].handleIn.project(origin.handleIn);
+            segments2[0].point = segments1[1].point.add(segments2[0].point).divide(2);
+            segments1.pop();
+        }
+        else {
+            if (intersection.length === 0) {
+                if (distance > Math.abs(offset) * 0.1) {
+                    // connect
+                    switch (join) {
+                        case 'miter':
+                            var join_1 = Intersection(curve1.point2, curve1.point2.add(curve1.getTangentAt(1, true)), curve2.point1, curve2.point1.add(curve2.getTangentAt(0, true)));
+                            // prevent sharp angle
+                            var joinOffset = Math.max(join_1.getDistance(curve1.point2), join_1.getDistance(curve2.point1));
+                            if (joinOffset < Math.abs(offset) * limit) {
+                                segments1.push(new paper_1.default.Segment(join_1));
+                            }
+                            break;
+                        case 'round':
+                            var mid = MakeRoundJoin(segments1[1], segments2[0], origin.point, offset);
+                            if (mid) {
+                                segments1.push(mid);
+                            }
+                            break;
+                        default: break;
+                    }
+                }
+                else {
+                    segments2[0].handleIn = segments1[1].handleIn;
+                    segments1.pop();
+                }
+            }
+            else {
+                var second1 = curve1.divideAt(intersection[0]);
+                if (second1) {
+                    var join_2 = second1.segment1;
+                    var second2 = curve2.divideAt(curve2.getIntersections(curve1)[0]);
+                    join_2.handleOut = second2 ? second2.segment1.handleOut : segments2[0].handleOut;
+                    segments1.pop();
+                    segments2[0] = join_2;
+                }
+                else {
+                    segments2[0].handleIn = segments1[1].handleIn;
+                    segments1.pop();
+                }
+            }
+        }
+    }
+    Offsets.ConnectAdjacentBezier = ConnectAdjacentBezier;
+    /**
+     * Connect all the segments together.
+     */
+    function ConnectBeziers(rawSegments, join, source, offset, limit) {
+        var originSegments = source.segments;
+        var first = rawSegments[0].slice();
+        for (var i = 0; i < rawSegments.length - 1; ++i) {
+            ConnectAdjacentBezier(rawSegments[i], rawSegments[i + 1], originSegments[i + 1], join, offset, limit);
+        }
+        if (source.closed) {
+            ConnectAdjacentBezier(rawSegments[rawSegments.length - 1], first, originSegments[0], join, offset, limit);
+            rawSegments[0][0] = first[0];
+        }
+        return rawSegments;
+    }
+    function Decompound(path) {
+        if (path.children.length === 1) {
+            path = path.children[0];
+            path.remove(); // remove from parent, this is critical, or the style attributes will be ignored
+        }
+        return path;
+    }
+    /** Normalize a path, always clockwise, non-self-intersection, ignore really small components, and no one-component compound path. */
+    function Normalize(path, areaThreshold) {
+        if (areaThreshold === void 0) { areaThreshold = 0.01; }
+        if (path.closed) {
+            var ignoreArea_1 = Math.abs(path.area * areaThreshold);
+            if (!path.clockwise) {
+                path.reverse();
+            }
+            path = path.unite(path, { insert: false });
+            if (path instanceof paper_1.default.CompoundPath) {
+                path.children.filter(function (c) { return Math.abs(c.area) < ignoreArea_1; }).forEach(function (c) { return c.remove(); });
+                if (path.children.length === 1) {
+                    return Decompound(path);
+                }
+            }
+        }
+        return path;
+    }
+    Offsets.Normalize = Normalize;
+    function IsSameDirection(partialPath, fullPath) {
+        var offset1 = partialPath.segments[0].location.offset;
+        var offset2 = partialPath.segments[Math.max(1, Math.floor(partialPath.segments.length / 2))].location.offset;
+        var sampleOffset = (offset1 + offset2) / 3;
+        var originOffset1 = fullPath.getNearestLocation(partialPath.getPointAt(sampleOffset)).offset;
+        var originOffset2 = fullPath.getNearestLocation(partialPath.getPointAt(2 * sampleOffset)).offset;
+        return originOffset1 < originOffset2;
+    }
+    Offsets.IsSameDirection = IsSameDirection;
+    /** Remove self intersection when offset is negative by point direction dectection. */
+    function RemoveIntersection(path) {
+        var newPath = path.unite(path, { insert: false });
+        if (newPath instanceof paper_1.default.CompoundPath) {
+            newPath.children.filter(function (c) {
+                if (c.segments.length > 1) {
+                    return !IsSameDirection(c, path);
+                }
+                else {
+                    return true;
+                }
+            }).forEach(function (c) { return c.remove(); });
+            return Decompound(newPath);
+        }
+        return path;
+    }
+    Offsets.RemoveIntersection = RemoveIntersection;
+    function Segments(path) {
+        if (path instanceof paper_1.default.CompoundPath) {
+            return arrayex_1.Arrayex.Flat(path.children.map(function (c) { return c.segments; }));
+        }
+        else {
+            return path.segments;
+        }
+    }
+    /**
+     * Remove impossible segments in negative offset condition.
+     */
+    function RemoveOutsiders(offsetPath, path) {
+        var segments = Segments(offsetPath).slice();
+        segments.forEach(function (segment) {
+            if (!path.contains(segment.point)) {
+                segment.remove();
+            }
+        });
+    }
+    function PreparePath(path, offset) {
+        var source = path.clone({ insert: false });
+        source.reduce();
+        if (!path.clockwise) {
+            source.reverse();
+            offset = -offset;
+        }
+        return [source, offset];
+    }
+    function OffsetSimpleShape(path, offset, join, limit) {
+        var _a;
+        var source;
+        _a = PreparePath(path, offset), source = _a[0], offset = _a[1];
+        var curves = source.curves.slice();
+        var raws = arrayex_1.Arrayex.Divide(arrayex_1.Arrayex.Flat(curves.map(function (curve) { return AdaptiveOffsetCurve(curve, offset); })), 2);
+        var segments = arrayex_1.Arrayex.Flat(ConnectBeziers(raws, join, source, offset, limit));
+        var offsetPath = RemoveIntersection(new paper_1.default.Path({ segments: segments, insert: false, closed: path.closed }));
+        offsetPath.reduce();
+        if (source.closed && ((source.clockwise && offset < 0) || (!source.clockwise && offset > 0))) {
+            RemoveOutsiders(offsetPath, path);
+        }
+        // recovery path
+        if (source.clockwise !== path.clockwise) {
+            offsetPath.reverse();
+        }
+        return Normalize(offsetPath);
+    }
+    Offsets.OffsetSimpleShape = OffsetSimpleShape;
+    function MakeRoundCap(from, to, offset) {
+        var origin = from.point.add(to.point).divide(2);
+        var normal = to.point.subtract(from.point).rotate(-90).normalize(offset);
+        var through = origin.add(normal);
+        var arc = new paper_1.default.Path.Arc({ from: from.point, to: to.point, through: through, insert: false });
+        return arc.segments;
+    }
+    function ConnectSide(outer, inner, offset, cap) {
+        if (outer instanceof paper_1.default.CompoundPath) {
+            var cs = outer.children.map(function (c) { return ({ c: c, a: Math.abs(c.area) }); });
+            cs = cs.sort(function (c1, c2) { return c2.a - c1.a; });
+            outer = cs[0].c;
+        }
+        var oSegments = outer.segments.slice();
+        var iSegments = inner.segments.slice();
+        switch (cap) {
+            case 'round':
+                var heads = MakeRoundCap(iSegments[iSegments.length - 1], oSegments[0], offset);
+                var tails = MakeRoundCap(oSegments[oSegments.length - 1], iSegments[0], offset);
+                var result = new paper_1.default.Path({ segments: heads.concat(oSegments, tails, iSegments), closed: true, insert: false });
+                result.reduce();
+                return result;
+            default: return new paper_1.default.Path({ segments: oSegments.concat(iSegments), closed: true, insert: false });
+        }
+    }
+    function OffsetSimpleStroke(path, offset, join, cap, limit) {
+        offset = path.clockwise ? offset : -offset;
+        var positiveOffset = OffsetSimpleShape(path, offset, join, limit);
+        var negativeOffset = OffsetSimpleShape(path, -offset, join, limit);
+        if (path.closed) {
+            return positiveOffset.subtract(negativeOffset, { insert: false });
+        }
+        else {
+            var inner = negativeOffset;
+            var holes = new Array();
+            if (negativeOffset instanceof paper_1.default.CompoundPath) {
+                holes = negativeOffset.children.filter(function (c) { return c.closed; });
+                holes.forEach(function (h) { return h.remove(); });
+                inner = negativeOffset.children[0];
+            }
+            inner.reverse();
+            var final = ConnectSide(positiveOffset, inner, offset, cap);
+            if (holes.length > 0) {
+                for (var _i = 0, holes_1 = holes; _i < holes_1.length; _i++) {
+                    var hole = holes_1[_i];
+                    final = final.subtract(hole, { insert: false });
+                }
+            }
+            return final;
+        }
+    }
+    Offsets.OffsetSimpleStroke = OffsetSimpleStroke;
+})(Offsets || (Offsets = {}));
+function OffsetPath(path, offset, join, limit) {
+    var nonSIPath = path.unite(path, { insert: false });
+    var result = nonSIPath;
+    if (nonSIPath instanceof paper_1.default.Path) {
+        result = Offsets.OffsetSimpleShape(nonSIPath, offset, join, limit);
+    }
+    else {
+        var children = arrayex_1.Arrayex.Flat(nonSIPath.children.map(function (c) {
+            if (c.segments.length > 1) {
+                if (!Offsets.IsSameDirection(c, path)) {
+                    c.reverse();
+                }
+                var offseted = Offsets.OffsetSimpleShape(c, offset, join, limit);
+                offseted = Offsets.Normalize(offseted);
+                if (offseted.clockwise !== c.clockwise) {
+                    offseted.reverse();
+                }
+                if (offseted instanceof paper_1.default.CompoundPath) {
+                    offseted.applyMatrix = true;
+                    return offseted.children;
+                }
+                else {
+                    return offseted;
+                }
+            }
+            else {
+                return null;
+            }
+        }), false);
+        result = new paper_1.default.CompoundPath({ children: children, insert: false });
+    }
+    result.copyAttributes(nonSIPath, false);
+    result.remove();
+    return result;
+}
+exports.OffsetPath = OffsetPath;
+function OffsetStroke(path, offset, join, cap, limit) {
+    var nonSIPath = path.unite(path, { insert: false });
+    var result = nonSIPath;
+    if (nonSIPath instanceof paper_1.default.Path) {
+        result = Offsets.OffsetSimpleStroke(nonSIPath, offset, join, cap, limit);
+    }
+    else {
+        var children = arrayex_1.Arrayex.Flat(nonSIPath.children.map(function (c) {
+            return Offsets.OffsetSimpleStroke(c, offset, join, cap, limit);
+        }));
+        result = children.reduce(function (c1, c2) { return c1.unite(c2, { insert: false }); });
+    }
+    result.strokeWidth = 0;
+    result.fillColor = nonSIPath.strokeColor;
+    result.shadowBlur = nonSIPath.shadowBlur;
+    result.shadowColor = nonSIPath.shadowColor;
+    result.shadowOffset = nonSIPath.shadowOffset;
+    return result;
+}
+exports.OffsetStroke = OffsetStroke;
+//# sourceMappingURL=Offset.js.map
\ No newline at end of file
diff --git a/node_modules/paperjs-offset/dist/lib/Offset.js.map b/node_modules/paperjs-offset/dist/lib/Offset.js.map
new file mode 100644
index 0000000..8dbd8ce
--- /dev/null
+++ b/node_modules/paperjs-offset/dist/lib/Offset.js.map
@@ -0,0 +1 @@
+{"version":3,"file":"Offset.js","sourceRoot":"","sources":["../../src/Offset.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/paperjs-offset/dist/lib/bundle.js b/node_modules/paperjs-offset/dist/lib/bundle.js
index 074a5ee..cf7e43a 100644
--- a/node_modules/paperjs-offset/dist/lib/bundle.js
+++ b/node_modules/paperjs-offset/dist/lib/bundle.js
@@ -3,8 +3,4 @@ Object.defineProperty(exports, "__esModule", { value: true });
 var paper_1 = require("paper");
 var index_1 = require("./index");
 index_1.default(paper_1.default);
-window.PaperOffset = {
-    offset: index_1.PaperOffset.offset,
-    offsetStroke: index_1.PaperOffset.offsetStroke,
-};
 //# sourceMappingURL=bundle.js.map
\ No newline at end of file
diff --git a/node_modules/paperjs-offset/dist/lib/bundle.js.map b/node_modules/paperjs-offset/dist/lib/bundle.js.map
index b192183..183e693 100644
--- a/node_modules/paperjs-offset/dist/lib/bundle.js.map
+++ b/node_modules/paperjs-offset/dist/lib/bundle.js.map
@@ -1 +1 @@
-{"version":3,"file":"bundle.js","sourceRoot":"","sources":["../../src/bundle.ts"],"names":[],"mappings":";;AAAA,+BAA0B;AAC1B,iCAAqD;AAErD,eAAa,CAAC,eAAK,CAAC,CAAC;AAWrB,MAAM,CAAC,WAAW,GAAG;IACnB,MAAM,EAAE,mBAAW,CAAC,MAAM;IAC1B,YAAY,EAAE,mBAAW,CAAC,YAAY;CACvC,CAAC"}
\ No newline at end of file
+{"version":3,"file":"bundle.js","sourceRoot":"","sources":["../../src/bundle.ts"],"names":[],"mappings":";;AAAA,+BAAyB;AACzB,iCAAmC;AAEnC,eAAa,CAAC,eAAK,CAAC,CAAA"}
\ No newline at end of file
diff --git a/node_modules/paperjs-offset/dist/lib/index.js b/node_modules/paperjs-offset/dist/lib/index.js
index 9305246..5fe087a 100644
--- a/node_modules/paperjs-offset/dist/lib/index.js
+++ b/node_modules/paperjs-offset/dist/lib/index.js
@@ -1,50 +1,41 @@
 "use strict";
 Object.defineProperty(exports, "__esModule", { value: true });
 var paper_1 = require("paper");
-var offset_core_1 = require("./offset_core");
-var PaperOffset = /** @class */ (function () {
-    function PaperOffset() {
+var Offset_1 = require("./Offset");
+function PrototypedOffset(path, offset, options) {
+    options = options || {};
+    var offsetPath = Offset_1.OffsetPath(path, offset, options.join || 'miter', options.limit || 10);
+    if (options.insert === undefined) {
+        options.insert = true;
     }
-    PaperOffset.offset = function (path, offset, options) {
-        options = options || {};
-        var newPath = offset_core_1.offsetPath(path, offset, options.join || 'miter', options.limit || 10);
-        if (options.insert === undefined) {
-            options.insert = true;
-        }
-        if (options.insert) {
-            (path.parent || paper_1.default.project.activeLayer).addChild(newPath);
-        }
-        return newPath;
-    };
-    PaperOffset.offsetStroke = function (path, offset, options) {
-        options = options || {};
-        var newPath = offset_core_1.offsetStroke(path, offset, options.join || 'miter', options.cap || 'butt', options.limit || 10);
-        if (options.insert === undefined) {
-            options.insert = true;
-        }
-        if (options.insert) {
-            (path.parent || paper_1.default.project.activeLayer).addChild(newPath);
-        }
-        return newPath;
-    };
-    return PaperOffset;
-}());
-exports.PaperOffset = PaperOffset;
-/**
- * @deprecated EXTEND existing paper module is not recommend anymore
- */
-function ExtendPaperJs(paperNs) {
-    paperNs.Path.prototype.offset = function (offset, options) {
-        return PaperOffset.offset(this, offset, options);
+    if (options.insert) {
+        (path.parent || paper_1.default.project.activeLayer).addChild(offsetPath);
+    }
+    return offsetPath;
+}
+function PrototypedOffsetStroke(path, offset, options) {
+    options = options || {};
+    var offsetPath = Offset_1.OffsetStroke(path, offset, options.join || 'miter', options.cap || 'butt', options.limit || 10);
+    if (options.insert === undefined) {
+        options.insert = true;
+    }
+    if (options.insert) {
+        (path.parent || paper_1.default.project.activeLayer).addChild(offsetPath);
+    }
+    return offsetPath;
+}
+function ExtendPaperJs(paper) {
+    paper.Path.prototype.offset = function (offset, options) {
+        return PrototypedOffset(this, offset, options);
     };
-    paperNs.Path.prototype.offsetStroke = function (offset, options) {
-        return PaperOffset.offsetStroke(this, offset, options);
+    paper.Path.prototype.offsetStroke = function (offset, options) {
+        return PrototypedOffsetStroke(this, offset, options);
     };
-    paperNs.CompoundPath.prototype.offset = function (offset, options) {
-        return PaperOffset.offset(this, offset, options);
+    paper.CompoundPath.prototype.offset = function (offset, options) {
+        return PrototypedOffset(this, offset, options);
     };
-    paperNs.CompoundPath.prototype.offsetStroke = function (offset, options) {
-        return PaperOffset.offsetStroke(this, offset, options);
+    paper.CompoundPath.prototype.offsetStroke = function (offset, options) {
+        return PrototypedOffsetStroke(this, offset, options);
     };
 }
 exports.default = ExtendPaperJs;
diff --git a/node_modules/paperjs-offset/dist/lib/index.js.map b/node_modules/paperjs-offset/dist/lib/index.js.map
index 036d98e..edd31d0 100644
--- a/node_modules/paperjs-offset/dist/lib/index.js.map
+++ b/node_modules/paperjs-offset/dist/lib/index.js.map
@@ -1 +1 @@
-{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":";;AAAA,+BAA0B;AAC1B,6CAAkG;AASlG;IAAA;IAwBA,CAAC;IAvBe,kBAAM,GAApB,UAAqB,IAAc,EAAE,MAAc,EAAE,OAAuB;QAC1E,OAAO,GAAG,OAAO,IAAI,EAAE,CAAC;QACxB,IAAM,OAAO,GAAG,wBAAU,CAAC,IAAI,EAAE,MAAM,EAAE,OAAO,CAAC,IAAI,IAAI,OAAO,EAAE,OAAO,CAAC,KAAK,IAAI,EAAE,CAAC,CAAC;QACvF,IAAI,OAAO,CAAC,MAAM,KAAK,SAAS,EAAE;YAChC,OAAO,CAAC,MAAM,GAAG,IAAI,CAAC;SACvB;QACD,IAAI,OAAO,CAAC,MAAM,EAAE;YAClB,CAAC,IAAI,CAAC,MAAM,IAAI,eAAK,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;SAC9D;QACD,OAAO,OAAO,CAAC;IACjB,CAAC;IAEa,wBAAY,GAA1B,UAA2B,IAAc,EAAE,MAAc,EAAE,OAAuB;QAChF,OAAO,GAAG,OAAO,IAAI,EAAE,CAAC;QACxB,IAAM,OAAO,GAAG,0BAAY,CAAC,IAAI,EAAE,MAAM,EAAE,OAAO,CAAC,IAAI,IAAI,OAAO,EAAE,OAAO,CAAC,GAAG,IAAI,MAAM,EAAE,OAAO,CAAC,KAAK,IAAI,EAAE,CAAC,CAAC;QAChH,IAAI,OAAO,CAAC,MAAM,KAAK,SAAS,EAAE;YAChC,OAAO,CAAC,MAAM,GAAG,IAAI,CAAC;SACvB;QACD,IAAI,OAAO,CAAC,MAAM,EAAE;YAClB,CAAC,IAAI,CAAC,MAAM,IAAI,eAAK,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC;SAC9D;QACD,OAAO,OAAO,CAAC;IACjB,CAAC;IACH,kBAAC;AAAD,CAAC,AAxBD,IAwBC;AAxBY,kCAAW;AA0BxB;;GAEG;AACH,SAAwB,aAAa,CAAC,OAAY;IAChD,OAAO,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,GAAG,UAAS,MAAc,EAAE,OAAuB;QAC9E,OAAO,WAAW,CAAC,MAAM,CAAC,IAAI,EAAE,MAAM,EAAE,OAAO,CAAC,CAAC;IACnD,CAAC,CAAC;IAEF,OAAO,CAAC,IAAI,CAAC,SAAS,CAAC,YAAY,GAAG,UAAS,MAAc,EAAE,OAAuB;QACpF,OAAO,WAAW,CAAC,YAAY,CAAC,IAAI,EAAE,MAAM,EAAE,OAAO,CAAC,CAAC;IACzD,CAAC,CAAC;IAEF,OAAO,CAAC,YAAY,CAAC,SAAS,CAAC,MAAM,GAAG,UAAS,MAAc,EAAE,OAAuB;QACtF,OAAO,WAAW,CAAC,MAAM,CAAC,IAAI,EAAE,MAAM,EAAE,OAAO,CAAC,CAAC;IACnD,CAAC,CAAC;IAEF,OAAO,CAAC,YAAY,CAAC,SAAS,CAAC,YAAY,GAAG,UAAS,MAAc,EAAE,OAAuB;QAC5F,OAAO,WAAW,CAAC,YAAY,CAAC,IAAI,EAAE,MAAM,EAAE,OAAO,CAAC,CAAC;IACzD,CAAC,CAAC;AACJ,CAAC;AAhBD,gCAgBC"}
\ No newline at end of file
+{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":";;AAAA,+BAAyB;AACzB,mCAA4F;AAqB5F,SAAS,gBAAgB,CAAC,IAAc,EAAE,MAAc,EAAE,OAAuB;IAC/E,OAAO,GAAG,OAAO,IAAI,EAAE,CAAA;IACvB,IAAI,UAAU,GAAG,mBAAU,CAAC,IAAI,EAAE,MAAM,EAAE,OAAO,CAAC,IAAI,IAAI,OAAO,EAAE,OAAO,CAAC,KAAK,IAAI,EAAE,CAAC,CAAA;IACvF,IAAI,OAAO,CAAC,MAAM,KAAK,SAAS,EAAE;QAChC,OAAO,CAAC,MAAM,GAAG,IAAI,CAAA;KACtB;IACD,IAAI,OAAO,CAAC,MAAM,EAAE;QAClB,CAAC,IAAI,CAAC,MAAM,IAAI,eAAK,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAA;KAChE;IACD,OAAO,UAAU,CAAA;AACnB,CAAC;AAED,SAAS,sBAAsB,CAAC,IAAc,EAAE,MAAc,EAAE,OAAuB;IACrF,OAAO,GAAG,OAAO,IAAI,EAAE,CAAA;IACvB,IAAI,UAAU,GAAG,qBAAY,CAAC,IAAI,EAAE,MAAM,EAAE,OAAO,CAAC,IAAI,IAAI,OAAO,EAAE,OAAO,CAAC,GAAG,IAAI,MAAM,EAAE,OAAO,CAAC,KAAK,IAAI,EAAE,CAAC,CAAA;IAChH,IAAI,OAAO,CAAC,MAAM,KAAK,SAAS,EAAE;QAChC,OAAO,CAAC,MAAM,GAAG,IAAI,CAAA;KACtB;IACD,IAAI,OAAO,CAAC,MAAM,EAAE;QAClB,CAAC,IAAI,CAAC,MAAM,IAAI,eAAK,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAA;KAChE;IACD,OAAO,UAAU,CAAA;AACnB,CAAC;AAED,SAAwB,aAAa,CAAC,KAAU;IAC9C,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,GAAG,UAAS,MAAc,EAAE,OAAuB;QAC5E,OAAO,gBAAgB,CAAC,IAAI,EAAE,MAAM,EAAE,OAAO,CAAC,CAAA;IAChD,CAAC,CAAA;IAED,KAAK,CAAC,IAAI,CAAC,SAAS,CAAC,YAAY,GAAG,UAAU,MAAc,EAAE,OAAuB;QACnF,OAAO,sBAAsB,CAAC,IAAI,EAAE,MAAM,EAAE,OAAO,CAAC,CAAA;IACtD,CAAC,CAAA;IAED,KAAK,CAAC,YAAY,CAAC,SAAS,CAAC,MAAM,GAAG,UAAS,MAAc,EAAE,OAAuB;QACpF,OAAO,gBAAgB,CAAC,IAAI,EAAE,MAAM,EAAE,OAAO,CAAC,CAAA;IAChD,CAAC,CAAA;IAED,KAAK,CAAC,YAAY,CAAC,SAAS,CAAC,YAAY,GAAG,UAAU,MAAc,EAAE,OAAuB;QAC3F,OAAO,sBAAsB,CAAC,IAAI,EAAE,MAAM,EAAE,OAAO,CAAC,CAAA;IACtD,CAAC,CAAA;AACH,CAAC;AAhBD,gCAgBC"}
\ No newline at end of file
diff --git a/node_modules/paperjs-offset/dist/lib/offset_core.js b/node_modules/paperjs-offset/dist/lib/offset_core.js
deleted file mode 100644
index 616c5e1..0000000
--- a/node_modules/paperjs-offset/dist/lib/offset_core.js
+++ /dev/null
@@ -1,359 +0,0 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
-var paper_1 = require("paper");
-/**
- * Offset the start/terminal segment of a bezier curve
- * @param segment segment to offset
- * @param curve curve to offset
- * @param handleNormal the normal of the the line formed of two handles
- * @param offset offset value
- */
-function offsetSegment(segment, curve, handleNormal, offset) {
-    var isFirst = segment.curve === curve;
-    // get offset vector
-    var offsetVector = (curve.getNormalAtTime(isFirst ? 0 : 1)).multiply(offset);
-    // get offset point
-    var point = segment.point.add(offsetVector);
-    var newSegment = new paper_1.default.Segment(point);
-    // handleOut for start segment & handleIn for terminal segment
-    var handle = (isFirst ? 'handleOut' : 'handleIn');
-    newSegment[handle] = segment[handle].add(handleNormal.subtract(offsetVector).divide(2));
-    return newSegment;
-}
-/**
- * Adaptive offset a curve by repeatly apply the approximation proposed by Tiller and Hanson.
- * @param curve curve to offset
- * @param offset offset value
- */
-function adaptiveOffsetCurve(curve, offset) {
-    var hNormal = (new paper_1.default.Curve(curve.segment1.handleOut.add(curve.segment1.point), new paper_1.default.Point(0, 0), new paper_1.default.Point(0, 0), curve.segment2.handleIn.add(curve.segment2.point))).getNormalAtTime(0.5).multiply(offset);
-    var segment1 = offsetSegment(curve.segment1, curve, hNormal, offset);
-    var segment2 = offsetSegment(curve.segment2, curve, hNormal, offset);
-    // divide && re-offset
-    var offsetCurve = new paper_1.default.Curve(segment1, segment2);
-    // if the offset curve is not self intersected, divide it
-    if (offsetCurve.getIntersections(offsetCurve).length === 0) {
-        var threshold = Math.min(Math.abs(offset) / 10, 1);
-        var midOffset = offsetCurve.getPointAtTime(0.5).getDistance(curve.getPointAtTime(0.5));
-        if (Math.abs(midOffset - Math.abs(offset)) > threshold) {
-            var subCurve = curve.divideAtTime(0.5);
-            if (subCurve != null) {
-                return adaptiveOffsetCurve(curve, offset).concat(adaptiveOffsetCurve(subCurve, offset));
-            }
-        }
-    }
-    return [segment1, segment2];
-}
-/**
- * Create a round join segment between two adjacent segments.
- */
-function makeRoundJoin(segment1, segment2, originPoint, radius) {
-    var through = segment1.point.subtract(originPoint).add(segment2.point.subtract(originPoint))
-        .normalize(Math.abs(radius)).add(originPoint);
-    var arc = new paper_1.default.Path.Arc({ from: segment1.point, to: segment2.point, through: through, insert: false });
-    segment1.handleOut = arc.firstSegment.handleOut;
-    segment2.handleIn = arc.lastSegment.handleIn;
-    return arc.segments.length === 3 ? arc.segments[1] : null;
-}
-function det(p1, p2) {
-    return p1.x * p2.y - p1.y * p2.x;
-}
-/**
- * Get the intersection point of point based lines
- */
-function getPointLineIntersections(p1, p2, p3, p4) {
-    var l1 = p1.subtract(p2);
-    var l2 = p3.subtract(p4);
-    var dl1 = det(p1, p2);
-    var dl2 = det(p3, p4);
-    return new paper_1.default.Point(dl1 * l2.x - l1.x * dl2, dl1 * l2.y - l1.y * dl2).divide(det(l1, l2));
-}
-/**
- * Connect two adjacent bezier curve, each curve is represented by two segments,
- * create different types of joins or simply removal redundant segment.
- */
-function connectAdjacentBezier(segments1, segments2, origin, joinType, offset, limit) {
-    var curve1 = new paper_1.default.Curve(segments1[0], segments1[1]);
-    var curve2 = new paper_1.default.Curve(segments2[0], segments2[1]);
-    var intersection = curve1.getIntersections(curve2);
-    var distance = segments1[1].point.getDistance(segments2[0].point);
-    if (origin.isSmooth()) {
-        segments2[0].handleOut = segments2[0].handleOut.project(origin.handleOut);
-        segments2[0].handleIn = segments1[1].handleIn.project(origin.handleIn);
-        segments2[0].point = segments1[1].point.add(segments2[0].point).divide(2);
-        segments1.pop();
-    }
-    else {
-        if (intersection.length === 0) {
-            if (distance > Math.abs(offset) * 0.1) {
-                // connect
-                switch (joinType) {
-                    case 'miter':
-                        var join = getPointLineIntersections(curve1.point2, curve1.point2.add(curve1.getTangentAtTime(1)), curve2.point1, curve2.point1.add(curve2.getTangentAtTime(0)));
-                        // prevent sharp angle
-                        var joinOffset = Math.max(join.getDistance(curve1.point2), join.getDistance(curve2.point1));
-                        if (joinOffset < Math.abs(offset) * limit) {
-                            segments1.push(new paper_1.default.Segment(join));
-                        }
-                        break;
-                    case 'round':
-                        var mid = makeRoundJoin(segments1[1], segments2[0], origin.point, offset);
-                        if (mid) {
-                            segments1.push(mid);
-                        }
-                        break;
-                    default: break;
-                }
-            }
-            else {
-                segments2[0].handleIn = segments1[1].handleIn;
-                segments1.pop();
-            }
-        }
-        else {
-            var second1 = curve1.divideAt(intersection[0]);
-            if (second1) {
-                var join = second1.segment1;
-                var second2 = curve2.divideAt(curve2.getIntersections(curve1)[0]);
-                join.handleOut = second2 ? second2.segment1.handleOut : segments2[0].handleOut;
-                segments1.pop();
-                segments2[0] = join;
-            }
-            else {
-                segments2[0].handleIn = segments1[1].handleIn;
-                segments1.pop();
-            }
-        }
-    }
-}
-/**
- * Connect all the segments together.
- */
-function connectBeziers(rawSegments, join, source, offset, limit) {
-    var originSegments = source.segments;
-    var first = rawSegments[0].slice();
-    for (var i = 0; i < rawSegments.length - 1; ++i) {
-        connectAdjacentBezier(rawSegments[i], rawSegments[i + 1], originSegments[i + 1], join, offset, limit);
-    }
-    if (source.closed) {
-        connectAdjacentBezier(rawSegments[rawSegments.length - 1], first, originSegments[0], join, offset, limit);
-        rawSegments[0][0] = first[0];
-    }
-    return rawSegments;
-}
-function reduceSingleChildCompoundPath(path) {
-    if (path.children.length === 1) {
-        path = path.children[0];
-        path.remove(); // remove from parent, this is critical, or the style attributes will be ignored
-    }
-    return path;
-}
-/** Normalize a path, always clockwise, non-self-intersection, ignore really small components, and no one-component compound path. */
-function normalize(path, areaThreshold) {
-    if (areaThreshold === void 0) { areaThreshold = 0.01; }
-    if (path.closed) {
-        var ignoreArea_1 = Math.abs(path.area * areaThreshold);
-        if (!path.clockwise) {
-            path.reverse();
-        }
-        path = path.unite(path, { insert: false });
-        if (path instanceof paper_1.default.CompoundPath) {
-            path.children.filter(function (c) { return Math.abs(c.area) < ignoreArea_1; }).forEach(function (c) { return c.remove(); });
-            if (path.children.length === 1) {
-                return reduceSingleChildCompoundPath(path);
-            }
-        }
-    }
-    return path;
-}
-function isSameDirection(partialPath, fullPath) {
-    var offset1 = partialPath.segments[0].location.offset;
-    var offset2 = partialPath.segments[Math.max(1, Math.floor(partialPath.segments.length / 2))].location.offset;
-    var sampleOffset = (offset1 + offset2) / 3;
-    var originOffset1 = fullPath.getNearestLocation(partialPath.getPointAt(sampleOffset)).offset;
-    var originOffset2 = fullPath.getNearestLocation(partialPath.getPointAt(2 * sampleOffset)).offset;
-    return originOffset1 < originOffset2;
-}
-/** Remove self intersection when offset is negative by point direction dectection. */
-function removeIntersection(path) {
-    if (path.closed) {
-        var newPath = path.unite(path, { insert: false });
-        if (newPath instanceof paper_1.default.CompoundPath) {
-            newPath.children.filter(function (c) {
-                if (c.segments.length > 1) {
-                    return !isSameDirection(c, path);
-                }
-                else {
-                    return true;
-                }
-            }).forEach(function (c) { return c.remove(); });
-            return reduceSingleChildCompoundPath(newPath);
-        }
-    }
-    return path;
-}
-function getSegments(path) {
-    if (path instanceof paper_1.default.CompoundPath) {
-        return path.children.map(function (c) { return c.segments; }).flat();
-    }
-    else {
-        return path.segments;
-    }
-}
-/**
- * Remove impossible segments in negative offset condition.
- */
-function removeOutsiders(newPath, path) {
-    var segments = getSegments(newPath).slice();
-    segments.forEach(function (segment) {
-        if (!path.contains(segment.point)) {
-            segment.remove();
-        }
-    });
-}
-function preparePath(path, offset) {
-    var source = path.clone({ insert: false });
-    source.reduce({});
-    if (!path.clockwise) {
-        source.reverse();
-        offset = -offset;
-    }
-    return [source, offset];
-}
-function offsetSimpleShape(path, offset, join, limit) {
-    var _a;
-    var source;
-    _a = preparePath(path, offset), source = _a[0], offset = _a[1];
-    var curves = source.curves.slice();
-    var offsetCurves = curves.map(function (curve) { return adaptiveOffsetCurve(curve, offset); }).flat();
-    var raws = [];
-    for (var i = 0; i < offsetCurves.length; i += 2) {
-        raws.push(offsetCurves.slice(i, i + 2));
-    }
-    var segments = connectBeziers(raws, join, source, offset, limit).flat();
-    var newPath = removeIntersection(new paper_1.default.Path({ segments: segments, insert: false, closed: path.closed }));
-    newPath.reduce({});
-    if (source.closed && ((source.clockwise && offset < 0) || (!source.clockwise && offset > 0))) {
-        removeOutsiders(newPath, path);
-    }
-    // recovery path
-    if (source.clockwise !== path.clockwise) {
-        newPath.reverse();
-    }
-    return normalize(newPath);
-}
-function makeRoundCap(from, to, offset) {
-    var origin = from.point.add(to.point).divide(2);
-    var normal = to.point.subtract(from.point).rotate(-90, new paper_1.default.Point(0, 0)).normalize(offset);
-    var through = origin.add(normal);
-    var arc = new paper_1.default.Path.Arc({ from: from.point, to: to.point, through: through, insert: false });
-    return arc.segments;
-}
-function connectSide(outer, inner, offset, cap) {
-    if (outer instanceof paper_1.default.CompoundPath) {
-        var cs = outer.children.map(function (c) { return ({ c: c, a: Math.abs(c.area) }); });
-        cs = cs.sort(function (c1, c2) { return c2.a - c1.a; });
-        outer = cs[0].c;
-    }
-    var oSegments = outer.segments.slice();
-    var iSegments = inner.segments.slice();
-    switch (cap) {
-        case 'round':
-            var heads = makeRoundCap(iSegments[iSegments.length - 1], oSegments[0], offset);
-            var tails = makeRoundCap(oSegments[oSegments.length - 1], iSegments[0], offset);
-            var result = new paper_1.default.Path({ segments: heads.concat(oSegments, tails, iSegments), closed: true, insert: false });
-            result.reduce({});
-            return result;
-        default: return new paper_1.default.Path({ segments: oSegments.concat(iSegments), closed: true, insert: false });
-    }
-}
-function offsetSimpleStroke(path, offset, join, cap, limit) {
-    offset = path.clockwise ? offset : -offset;
-    var positiveOffset = offsetSimpleShape(path, offset, join, limit);
-    var negativeOffset = offsetSimpleShape(path, -offset, join, limit);
-    if (path.closed) {
-        return positiveOffset.subtract(negativeOffset, { insert: false });
-    }
-    else {
-        var inner = negativeOffset;
-        var holes = new Array();
-        if (negativeOffset instanceof paper_1.default.CompoundPath) {
-            holes = negativeOffset.children.filter(function (c) { return c.closed; });
-            holes.forEach(function (h) { return h.remove(); });
-            inner = negativeOffset.children[0];
-        }
-        inner.reverse();
-        var final = connectSide(positiveOffset, inner, offset, cap);
-        if (holes.length > 0) {
-            for (var _i = 0, holes_1 = holes; _i < holes_1.length; _i++) {
-                var hole = holes_1[_i];
-                final = final.subtract(hole, { insert: false });
-            }
-        }
-        return final;
-    }
-}
-function getNonSelfItersectionPath(path) {
-    if (path.closed) {
-        return path.unite(path, { insert: false });
-    }
-    return path;
-}
-function offsetPath(path, offset, join, limit) {
-    var nonSIPath = getNonSelfItersectionPath(path);
-    var result = nonSIPath;
-    if (nonSIPath instanceof paper_1.default.Path) {
-        result = offsetSimpleShape(nonSIPath, offset, join, limit);
-    }
-    else {
-        var offsetParts = nonSIPath.children.map(function (c) {
-            if (c.segments.length > 1) {
-                if (!isSameDirection(c, path)) {
-                    c.reverse();
-                }
-                var offseted = offsetSimpleShape(c, offset, join, limit);
-                offseted = normalize(offseted);
-                if (offseted.clockwise !== c.clockwise) {
-                    offseted.reverse();
-                }
-                if (offseted instanceof paper_1.default.CompoundPath) {
-                    offseted.applyMatrix = true;
-                    return offseted.children;
-                }
-                else {
-                    return offseted;
-                }
-            }
-            else {
-                return null;
-            }
-        });
-        var children = offsetParts.flat().filter(function (c) { return !!c; });
-        result = new paper_1.default.CompoundPath({ children: children, insert: false });
-    }
-    result.copyAttributes(nonSIPath, false);
-    result.remove();
-    return result;
-}
-exports.offsetPath = offsetPath;
-function offsetStroke(path, offset, join, cap, limit) {
-    var nonSIPath = getNonSelfItersectionPath(path);
-    var result = nonSIPath;
-    if (nonSIPath instanceof paper_1.default.Path) {
-        result = offsetSimpleStroke(nonSIPath, offset, join, cap, limit);
-    }
-    else {
-        var children = nonSIPath.children.flatMap(function (c) {
-            return offsetSimpleStroke(c, offset, join, cap, limit);
-        });
-        result = children.reduce(function (c1, c2) { return c1.unite(c2, { insert: false }); });
-    }
-    result.strokeWidth = 0;
-    result.fillColor = nonSIPath.strokeColor;
-    result.shadowBlur = nonSIPath.shadowBlur;
-    result.shadowColor = nonSIPath.shadowColor;
-    result.shadowOffset = nonSIPath.shadowOffset;
-    return result;
-}
-exports.offsetStroke = offsetStroke;
-//# sourceMappingURL=offset_core.js.map
\ No newline at end of file
diff --git a/node_modules/paperjs-offset/dist/lib/offset_core.js.map b/node_modules/paperjs-offset/dist/lib/offset_core.js.map
deleted file mode 100644
index 1c71cb6..0000000
--- a/node_modules/paperjs-offset/dist/lib/offset_core.js.map
+++ /dev/null
@@ -1 +0,0 @@
-{"version":3,"file":"offset_core.js","sourceRoot":"","sources":["../../src/offset_core.ts"],"names":[],"mappings":";;AAAA,+BAA0B;AAQ1B;;;;;;GAMG;AACH,SAAS,aAAa,CAAC,OAAsB,EAAE,KAAkB,EAAE,YAAyB,EAAE,MAAc;IAC1G,IAAM,OAAO,GAAG,OAAO,CAAC,KAAK,KAAK,KAAK,CAAC;IACxC,oBAAoB;IACpB,IAAM,YAAY,GAAG,CAAC,KAAK,CAAC,eAAe,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;IAC/E,mBAAmB;IACnB,IAAM,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;IAC9C,IAAM,UAAU,GAAG,IAAI,eAAK,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;IAC5C,8DAA8D;IAC9D,IAAM,MAAM,GAAG,CAAC,OAAO,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,UAAU,CAAe,CAAC;IAClE,UAAU,CAAC,MAAM,CAAC,GAAG,OAAO,CAAC,MAAM,CAAE,CAAC,GAAG,CAAC,YAAY,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;IACzF,OAAO,UAAU,CAAC;AACpB,CAAC;AAED;;;;GAIG;AACH,SAAS,mBAAmB,CAAC,KAAkB,EAAE,MAAc;IAC7D,IAAM,OAAO,GAAG,CAAC,IAAI,eAAK,CAAC,KAAK,CAAC,KAAK,CAAC,QAAQ,CAAC,SAAU,CAAC,GAAG,CAAC,KAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE,IAAI,eAAK,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,EACzG,IAAI,eAAK,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,KAAK,CAAC,QAAQ,CAAC,QAAS,CAAC,GAAG,CAAC,KAAK,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;IACpH,IAAM,QAAQ,GAAG,aAAa,CAAC,KAAK,CAAC,QAAQ,EAAE,KAAK,EAAE,OAAO,EAAE,MAAM,CAAC,CAAC;IACvE,IAAM,QAAQ,GAAG,aAAa,CAAC,KAAK,CAAC,QAAQ,EAAE,KAAK,EAAE,OAAO,EAAE,MAAM,CAAC,CAAC;IACvE,sBAAsB;IACtB,IAAM,WAAW,GAAG,IAAI,eAAK,CAAC,KAAK,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;IACxD,yDAAyD;IACzD,IAAI,WAAW,CAAC,gBAAgB,CAAC,WAAW,CAAC,CAAC,MAAM,KAAK,CAAC,EAAE;QAC1D,IAAM,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC,CAAC;QACrD,IAAM,SAAS,GAAG,WAAW,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC,WAAW,CAAC,KAAK,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC,CAAC;QACzF,IAAI,IAAI,CAAC,GAAG,CAAC,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,GAAG,SAAS,EAAE;YACtD,IAAM,QAAQ,GAAG,KAAK,CAAC,YAAY,CAAC,GAAG,CAAC,CAAC;YACzC,IAAI,QAAQ,IAAI,IAAI,EAAE;gBACpB,OAAW,mBAAmB,CAAC,KAAK,EAAE,MAAM,CAAC,QAAK,mBAAmB,CAAC,QAAQ,EAAE,MAAM,CAAC,EAAE;aAC1F;SACF;KACF;IACD,OAAO,CAAC,QAAQ,EAAE,QAAQ,CAAC,CAAC;AAC9B,CAAC;AAED;;GAEG;AACH,SAAS,aAAa,CAAC,QAAuB,EAAE,QAAuB,EAAE,WAAwB,EAAE,MAAc;IAC/G,IAAM,OAAO,GAAG,QAAQ,CAAC,KAAK,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC,GAAG,CAAC,QAAQ,CAAC,KAAK,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC;SAC3F,SAAS,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;IAChD,IAAM,GAAG,GAAG,IAAI,eAAK,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,IAAI,EAAE,QAAQ,CAAC,KAAK,EAAE,EAAE,EAAE,QAAQ,CAAC,KAAK,EAAE,OAAO,SAAA,EAAE,MAAM,EAAE,KAAK,EAAE,CAAC,CAAC;IACrG,QAAQ,CAAC,SAAS,GAAG,GAAG,CAAC,YAAY,CAAC,SAAS,CAAC;IAChD,QAAQ,CAAC,QAAQ,GAAG,GAAG,CAAC,WAAW,CAAC,QAAQ,CAAC;IAC7C,OAAO,GAAG,CAAC,QAAQ,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;AAC5D,CAAC;AAED,SAAS,GAAG,CAAC,EAAe,EAAE,EAAe;IAC3C,OAAO,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC;AACnC,CAAC;AAED;;GAEG;AACH,SAAS,yBAAyB,CAAC,EAAe,EAAE,EAAe,EAAE,EAAe,EAAE,EAAe;IACnG,IAAM,EAAE,GAAG,EAAE,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;IAC3B,IAAM,EAAE,GAAG,EAAE,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;IAC3B,IAAM,GAAG,GAAG,GAAG,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;IACxB,IAAM,GAAG,GAAG,GAAG,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;IACxB,OAAO,IAAI,eAAK,CAAC,KAAK,CAAC,GAAG,GAAG,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,GAAG,GAAG,EAAE,GAAG,GAAG,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC;AAC/F,CAAC;AAED;;;GAGG;AACH,SAAS,qBAAqB,CAAC,SAA0B,EAAE,SAA0B,EAAE,MAAqB,EAAE,QAAwB,EAAE,MAAc,EAAE,KAAa;IACnK,IAAM,MAAM,GAAG,IAAI,eAAK,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;IAC3D,IAAM,MAAM,GAAG,IAAI,eAAK,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC;IAC3D,IAAM,YAAY,GAAG,MAAM,CAAC,gBAAgB,CAAC,MAAM,CAAC,CAAC;IACrD,IAAM,QAAQ,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,WAAW,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;IACpE,IAAI,MAAM,CAAC,QAAQ,EAAE,EAAE;QACrB,SAAS,CAAC,CAAC,CAAC,CAAC,SAAS,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC,SAAU,CAAC,OAAO,CAAC,MAAM,CAAC,SAAU,CAAC,CAAC;QAC5E,SAAS,CAAC,CAAC,CAAC,CAAC,QAAQ,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC,QAAS,CAAC,OAAO,CAAC,MAAM,CAAC,QAAS,CAAC,CAAC;QACzE,SAAS,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;QAC1E,SAAS,CAAC,GAAG,EAAE,CAAC;KACjB;SAAM;QACL,IAAI,YAAY,CAAC,MAAM,KAAK,CAAC,EAAE;YAC7B,IAAI,QAAQ,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,GAAG,EAAE;gBACrC,UAAU;gBACV,QAAQ,QAAQ,EAAE;oBAChB,KAAK,OAAO;wBACV,IAAM,IAAI,GAAG,yBAAyB,CAAC,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,EACjG,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;wBAChE,sBAAsB;wBACtB,IAAM,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,MAAM,CAAC,EAAE,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;wBAC9F,IAAI,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,KAAK,EAAE;4BACzC,SAAS,CAAC,IAAI,CAAC,IAAI,eAAK,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC;yBACzC;wBACD,MAAM;oBACR,KAAK,OAAO;wBACV,IAAM,GAAG,GAAG,aAAa,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,KAAK,EAAE,MAAM,CAAC,CAAC;wBAC5E,IAAI,GAAG,EAAE;4BACP,SAAS,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;yBACrB;wBACD,MAAM;oBACR,OAAO,CAAC,CAAC,MAAM;iBAChB;aACF;iBAAM;gBACL,SAAS,CAAC,CAAC,CAAC,CAAC,QAAQ,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC;gBAC9C,SAAS,CAAC,GAAG,EAAE,CAAC;aACjB;SACF;aAAM;YACL,IAAM,OAAO,GAAG,MAAM,CAAC,QAAQ,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC,CAAC;YACjD,IAAI,OAAO,EAAE;gBACX,IAAM,IAAI,GAAG,OAAO,CAAC,QAAQ,CAAC;gBAC9B,IAAM,OAAO,GAAG,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,gBAAgB,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;gBACpE,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;gBAC/E,SAAS,CAAC,GAAG,EAAE,CAAC;gBAChB,SAAS,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;aACrB;iBAAM;gBACL,SAAS,CAAC,CAAC,CAAC,CAAC,QAAQ,GAAG,SAAS,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC;gBAC9C,SAAS,CAAC,GAAG,EAAE,CAAC;aACjB;SACF;KACF;AACH,CAAC;AAED;;GAEG;AACH,SAAS,cAAc,CAAC,WAA8B,EAAE,IAAoB,EAAE,MAAkB,EAAE,MAAc,EAAE,KAAa;IAC7H,IAAM,cAAc,GAAG,MAAM,CAAC,QAAQ,CAAC;IACvC,IAAM,KAAK,GAAG,WAAW,CAAC,CAAC,CAAC,CAAC,KAAK,EAAE,CAAC;IACrC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,WAAW,CAAC,MAAM,GAAG,CAAC,EAAE,EAAE,CAAC,EAAE;QAC/C,qBAAqB,CAAC,WAAW,CAAC,CAAC,CAAC,EAAE,WAAW,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,cAAc,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC;KACvG;IACD,IAAI,MAAM,CAAC,MAAM,EAAE;QACjB,qBAAqB,CAAC,WAAW,CAAC,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC,EAAE,KAAK,EAAE,cAAc,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC;QAC1G,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;KAC9B;IACD,OAAO,WAAW,CAAC;AACrB,CAAC;AAED,SAAS,6BAA6B,CAAC,IAAc;IACnD,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE;QAC9B,IAAI,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAe,CAAC;QACtC,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC,gFAAgF;KAChG;IACD,OAAO,IAAI,CAAC;AACd,CAAC;AAED,qIAAqI;AACrI,SAAS,SAAS,CAAC,IAAc,EAAE,aAAoB;IAApB,8BAAA,EAAA,oBAAoB;IACrD,IAAI,IAAI,CAAC,MAAM,EAAE;QACf,IAAM,YAAU,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,GAAG,aAAa,CAAC,CAAC;QACvD,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;YACnB,IAAI,CAAC,OAAO,EAAE,CAAC;SAChB;QACD,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,EAAE,MAAM,EAAE,KAAK,EAAE,CAAa,CAAC;QACvD,IAAI,IAAI,YAAY,eAAK,CAAC,YAAY,EAAE;YACtC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,UAAC,CAAC,IAAK,OAAA,IAAI,CAAC,GAAG,CAAE,CAAc,CAAC,IAAI,CAAC,GAAG,YAAU,EAA3C,CAA2C,CAAC,CAAC,OAAO,CAAC,UAAC,CAAC,IAAK,OAAA,CAAC,CAAC,MAAM,EAAE,EAAV,CAAU,CAAC,CAAC;YACpG,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,KAAK,CAAC,EAAE;gBAC9B,OAAO,6BAA6B,CAAC,IAAI,CAAC,CAAC;aAC5C;SACF;KACF;IACD,OAAO,IAAI,CAAC;AACd,CAAC;AAED,SAAS,eAAe,CAAC,WAAuB,EAAE,QAAkB;IAClE,IAAM,OAAO,GAAG,WAAW,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC;IACxD,IAAM,OAAO,GAAG,WAAW,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,WAAW,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC;IAC/G,IAAM,YAAY,GAAG,CAAC,OAAO,GAAG,OAAO,CAAC,GAAG,CAAC,CAAC;IAC7C,IAAM,aAAa,GAAG,QAAQ,CAAC,kBAAkB,CAAC,WAAW,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC,CAAC,MAAM,CAAC;IAC/F,IAAM,aAAa,GAAG,QAAQ,CAAC,kBAAkB,CAAC,WAAW,CAAC,UAAU,CAAC,CAAC,GAAG,YAAY,CAAC,CAAC,CAAC,MAAM,CAAC;IACnG,OAAO,aAAa,GAAG,aAAa,CAAC;AACvC,CAAC;AAED,sFAAsF;AACtF,SAAS,kBAAkB,CAAC,IAAc;IACxC,IAAI,IAAI,CAAC,MAAM,EAAE;QACf,IAAM,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,EAAE,MAAM,EAAE,KAAK,EAAE,CAAa,CAAC;QAChE,IAAI,OAAO,YAAY,eAAK,CAAC,YAAY,EAAE;YACxC,OAAO,CAAC,QAAyB,CAAC,MAAM,CAAC,UAAC,CAAC;gBAC1C,IAAI,CAAC,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE;oBACzB,OAAO,CAAC,eAAe,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;iBAClC;qBAAM;oBACL,OAAO,IAAI,CAAC;iBACb;YACH,CAAC,CAAC,CAAC,OAAO,CAAC,UAAC,CAAC,IAAK,OAAA,CAAC,CAAC,MAAM,EAAE,EAAV,CAAU,CAAC,CAAC;YAC9B,OAAO,6BAA6B,CAAC,OAAO,CAAC,CAAC;SAC/C;KACF;IACD,OAAO,IAAI,CAAC;AACd,CAAC;AAED,SAAS,WAAW,CAAC,IAAc;IACjC,IAAI,IAAI,YAAY,eAAK,CAAC,YAAY,EAAE;QACtC,OAAO,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,UAAC,CAAC,IAAK,OAAC,CAAgB,CAAC,QAAQ,EAA1B,CAA0B,CAAC,CAAC,IAAI,EAAE,CAAC;KACpE;SAAM;QACL,OAAQ,IAAmB,CAAC,QAAQ,CAAC;KACtC;AACH,CAAC;AAED;;GAEG;AACH,SAAS,eAAe,CAAC,OAAiB,EAAE,IAAc;IACxD,IAAM,QAAQ,GAAG,WAAW,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,CAAC;IAC9C,QAAQ,CAAC,OAAO,CAAC,UAAC,OAAO;QACvB,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;YACjC,OAAO,CAAC,MAAM,EAAE,CAAC;SAClB;IACH,CAAC,CAAC,CAAC;AACL,CAAC;AAED,SAAS,WAAW,CAAC,IAAgB,EAAE,MAAc;IACnD,IAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,EAAE,MAAM,EAAE,KAAK,EAAE,CAAe,CAAC;IAC3D,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;IAClB,IAAI,CAAC,IAAI,CAAC,SAAS,EAAE;QACnB,MAAM,CAAC,OAAO,EAAE,CAAC;QACjB,MAAM,GAAG,CAAC,MAAM,CAAC;KAClB;IACD,OAAO,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;AAC1B,CAAC;AAED,SAAS,iBAAiB,CAAC,IAAgB,EAAE,MAAc,EAAE,IAAoB,EAAE,KAAa;;IAC9F,IAAI,MAAkB,CAAC;IACvB,8BAA4C,EAA3C,cAAM,EAAE,cAAM,CAA8B;IAC7C,IAAM,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC;IACrC,IAAM,YAAY,GAAG,MAAM,CAAC,GAAG,CAAC,UAAC,KAAK,IAAK,OAAA,mBAAmB,CAAC,KAAK,EAAE,MAAM,CAAC,EAAlC,CAAkC,CAAC,CAAC,IAAI,EAAE,CAAC;IACtF,IAAM,IAAI,GAAsB,EAAE,CAAC;IACnC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,YAAY,CAAC,MAAM,EAAE,CAAC,IAAI,CAAC,EAAE;QAC/C,IAAI,CAAC,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;KACzC;IACD,IAAM,QAAQ,GAAG,cAAc,CAAC,IAAI,EAAE,IAAI,EAAE,MAAM,EAAE,MAAM,EAAE,KAAK,CAAC,CAAC,IAAI,EAAE,CAAC;IAC1E,IAAM,OAAO,GAAG,kBAAkB,CAAC,IAAI,eAAK,CAAC,IAAI,CAAC,EAAE,QAAQ,UAAA,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,IAAI,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;IACrG,OAAO,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;IACnB,IAAI,MAAM,CAAC,MAAM,IAAI,CAAC,CAAC,MAAM,CAAC,SAAS,IAAI,MAAM,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC,MAAM,CAAC,SAAS,IAAI,MAAM,GAAG,CAAC,CAAC,CAAC,EAAE;QAC5F,eAAe,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;KAChC;IACD,gBAAgB;IAChB,IAAI,MAAM,CAAC,SAAS,KAAK,IAAI,CAAC,SAAS,EAAE;QACvC,OAAO,CAAC,OAAO,EAAE,CAAC;KACnB;IACD,OAAO,SAAS,CAAC,OAAO,CAAC,CAAC;AAC5B,CAAC;AAED,SAAS,YAAY,CAAC,IAAmB,EAAE,EAAiB,EAAE,MAAc;IAC1E,IAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;IAClD,IAAM,MAAM,GAAG,EAAE,CAAC,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,MAAM,CAAC,CAAC,EAAE,EAAE,IAAI,eAAK,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC;IAClG,IAAM,OAAO,GAAG,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;IACnC,IAAM,GAAG,GAAG,IAAI,eAAK,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,IAAI,EAAE,IAAI,CAAC,KAAK,EAAE,EAAE,EAAE,EAAE,CAAC,KAAK,EAAE,OAAO,SAAA,EAAE,MAAM,EAAE,KAAK,EAAE,CAAC,CAAC;IAC3F,OAAO,GAAG,CAAC,QAAQ,CAAC;AACtB,CAAC;AAED,SAAS,WAAW,CAAC,KAAe,EAAE,KAAiB,EAAE,MAAc,EAAE,GAAkB;IACzF,IAAI,KAAK,YAAY,eAAK,CAAC,YAAY,EAAE;QACvC,IAAI,EAAE,GAAG,KAAK,CAAC,QAAQ,CAAC,GAAG,CAAC,UAAC,CAAC,IAAK,OAAA,CAAC,EAAE,CAAC,GAAA,EAAE,CAAC,EAAE,IAAI,CAAC,GAAG,CAAE,CAAgB,CAAC,IAAI,CAAC,EAAE,CAAC,EAA5C,CAA4C,CAAC,CAAC;QACjF,EAAE,GAAG,EAAE,CAAC,IAAI,CAAC,UAAC,EAAE,EAAE,EAAE,IAAK,OAAA,EAAE,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,EAAX,CAAW,CAAC,CAAC;QACtC,KAAK,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC,CAAe,CAAC;KAC/B;IACD,IAAM,SAAS,GAAI,KAAoB,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC;IACzD,IAAM,SAAS,GAAG,KAAK,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC;IACzC,QAAQ,GAAG,EAAE;QACX,KAAK,OAAO;YACV,IAAM,KAAK,GAAG,YAAY,CAAC,SAAS,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC;YAClF,IAAM,KAAK,GAAG,YAAY,CAAC,SAAS,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC,CAAC,EAAE,MAAM,CAAC,CAAC;YAClF,IAAM,MAAM,GAAG,IAAI,eAAK,CAAC,IAAI,CAAC,EAAE,QAAQ,EAAM,KAAK,QAAK,SAAS,EAAK,KAAK,EAAK,SAAS,CAAC,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,CAAC,CAAC;YAC3H,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;YAClB,OAAO,MAAM,CAAC;QAChB,OAAO,CAAC,CAAC,OAAO,IAAI,eAAK,CAAC,IAAI,CAAC,EAAE,QAAQ,EAAM,SAAS,QAAK,SAAS,CAAC,EAAE,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,CAAC,CAAC;KACzG;AACH,CAAC;AAED,SAAS,kBAAkB,CAAC,IAAgB,EAAE,MAAc,EAAE,IAAoB,EAAE,GAAkB,EAAE,KAAa;IACnH,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;IAC3C,IAAM,cAAc,GAAG,iBAAiB,CAAC,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;IACpE,IAAM,cAAc,GAAG,iBAAiB,CAAC,IAAI,EAAE,CAAC,MAAM,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;IACrE,IAAI,IAAI,CAAC,MAAM,EAAE;QACf,OAAO,cAAc,CAAC,QAAQ,CAAC,cAAc,EAAE,EAAE,MAAM,EAAE,KAAK,EAAE,CAAa,CAAC;KAC/E;SAAM;QACL,IAAI,KAAK,GAAG,cAAc,CAAC;QAC3B,IAAI,KAAK,GAAG,IAAI,KAAK,EAAc,CAAC;QACpC,IAAI,cAAc,YAAY,eAAK,CAAC,YAAY,EAAE;YAChD,KAAK,GAAG,cAAc,CAAC,QAAQ,CAAC,MAAM,CAAC,UAAC,CAAC,IAAK,OAAC,CAAgB,CAAC,MAAM,EAAxB,CAAwB,CAAiB,CAAC;YACxF,KAAK,CAAC,OAAO,CAAC,UAAC,CAAC,IAAK,OAAA,CAAC,CAAC,MAAM,EAAE,EAAV,CAAU,CAAC,CAAC;YACjC,KAAK,GAAG,cAAc,CAAC,QAAQ,CAAC,CAAC,CAAe,CAAC;SAClD;QACD,KAAK,CAAC,OAAO,EAAE,CAAC;QAChB,IAAI,KAAK,GAAG,WAAW,CAAC,cAAc,EAAE,KAAmB,EAAE,MAAM,EAAE,GAAG,CAAa,CAAC;QACtF,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,EAAE;YACpB,KAAmB,UAAK,EAAL,eAAK,EAAL,mBAAK,EAAL,IAAK,EAAE;gBAArB,IAAM,IAAI,cAAA;gBACb,KAAK,GAAG,KAAK,CAAC,QAAQ,CAAC,IAAI,EAAE,EAAE,MAAM,EAAE,KAAK,EAAE,CAAa,CAAC;aAC7D;SACF;QACD,OAAO,KAAK,CAAC;KACd;AACH,CAAC;AAED,SAAS,yBAAyB,CAAC,IAAc;IAC/C,IAAI,IAAI,CAAC,MAAM,EAAE;QACf,OAAO,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,EAAE,MAAM,EAAE,KAAK,EAAE,CAAa,CAAC;KACxD;IACD,OAAO,IAAI,CAAC;AACd,CAAC;AAED,SAAgB,UAAU,CAAC,IAAc,EAAE,MAAc,EAAE,IAAoB,EAAE,KAAa;IAC5F,IAAM,SAAS,GAAG,yBAAyB,CAAC,IAAI,CAAC,CAAC;IAClD,IAAI,MAAM,GAAG,SAAS,CAAC;IACvB,IAAI,SAAS,YAAY,eAAK,CAAC,IAAI,EAAE;QACnC,MAAM,GAAG,iBAAiB,CAAC,SAAS,EAAE,MAAM,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;KAC5D;SAAM;QACL,IAAM,WAAW,GAAI,SAAS,CAAC,QAAyB,CAAC,GAAG,CAAC,UAAC,CAAC;YAC7D,IAAI,CAAC,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE;gBACzB,IAAI,CAAC,eAAe,CAAC,CAAC,EAAE,IAAI,CAAC,EAAE;oBAC7B,CAAC,CAAC,OAAO,EAAE,CAAC;iBACb;gBACD,IAAI,QAAQ,GAAG,iBAAiB,CAAC,CAAC,EAAE,MAAM,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;gBACzD,QAAQ,GAAG,SAAS,CAAC,QAAQ,CAAC,CAAC;gBAC/B,IAAI,QAAQ,CAAC,SAAS,KAAK,CAAC,CAAC,SAAS,EAAE;oBACtC,QAAQ,CAAC,OAAO,EAAE,CAAC;iBACpB;gBACD,IAAI,QAAQ,YAAY,eAAK,CAAC,YAAY,EAAE;oBAC1C,QAAQ,CAAC,WAAW,GAAG,IAAI,CAAC;oBAC5B,OAAO,QAAQ,CAAC,QAAQ,CAAC;iBAC1B;qBAAM;oBACL,OAAO,QAAQ,CAAC;iBACjB;aACF;iBAAM;gBACL,OAAO,IAAI,CAAC;aACb;QACH,CAAC,CAAC,CAAC;QACH,IAAM,QAAQ,GAAG,WAAW,CAAC,IAAI,EAAE,CAAC,MAAM,CAAC,UAAC,CAAC,IAAK,OAAA,CAAC,CAAC,CAAC,EAAH,CAAG,CAAiB,CAAC;QACvE,MAAM,GAAG,IAAI,eAAK,CAAC,YAAY,CAAC,EAAE,QAAQ,UAAA,EAAE,MAAM,EAAE,KAAK,EAAE,CAAC,CAAC;KAC9D;IACD,MAAM,CAAC,cAAc,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC;IACxC,MAAM,CAAC,MAAM,EAAE,CAAC;IAChB,OAAO,MAAM,CAAC;AAChB,CAAC;AAhCD,gCAgCC;AAED,SAAgB,YAAY,CAAC,IAAc,EAAE,MAAc,EAAE,IAAoB,EAAE,GAAkB,EAAE,KAAa;IAClH,IAAM,SAAS,GAAG,yBAAyB,CAAC,IAAI,CAAC,CAAC;IAClD,IAAI,MAAM,GAAG,SAAS,CAAC;IACvB,IAAI,SAAS,YAAY,eAAK,CAAC,IAAI,EAAE;QACnC,MAAM,GAAG,kBAAkB,CAAC,SAAS,EAAE,MAAM,EAAE,IAAI,EAAE,GAAG,EAAE,KAAK,CAAC,CAAC;KAClE;SAAM;QACL,IAAM,QAAQ,GAAI,SAAS,CAAC,QAAyB,CAAC,OAAO,CAAC,UAAC,CAAC;YAC9D,OAAO,kBAAkB,CAAC,CAAC,EAAE,MAAM,EAAE,IAAI,EAAE,GAAG,EAAE,KAAK,CAAC,CAAC;QACzD,CAAC,CAAC,CAAC;QACH,MAAM,GAAG,QAAQ,CAAC,MAAM,CAAC,UAAC,EAAE,EAAE,EAAE,IAAK,OAAA,EAAE,CAAC,KAAK,CAAC,EAAE,EAAE,EAAE,MAAM,EAAE,KAAK,EAAE,CAAa,EAA3C,CAA2C,CAAC,CAAC;KACnF;IACD,MAAM,CAAC,WAAW,GAAG,CAAC,CAAC;IACvB,MAAM,CAAC,SAAS,GAAG,SAAS,CAAC,WAAW,CAAC;IACzC,MAAM,CAAC,UAAU,GAAG,SAAS,CAAC,UAAU,CAAC;IACzC,MAAM,CAAC,WAAW,GAAG,SAAS,CAAC,WAAW,CAAC;IAC3C,MAAM,CAAC,YAAY,GAAG,SAAS,CAAC,YAAY,CAAC;IAC7C,OAAO,MAAM,CAAC;AAChB,CAAC;AAjBD,oCAiBC"}
\ No newline at end of file
diff --git a/node_modules/paperjs-offset/dist/paperjs-offset.js b/node_modules/paperjs-offset/dist/paperjs-offset.js
index 0f1c3e7..b164b94 100644
--- a/node_modules/paperjs-offset/dist/paperjs-offset.js
+++ b/node_modules/paperjs-offset/dist/paperjs-offset.js
@@ -1,410 +1,656 @@
 (function (paper) {
-  'use strict';
+    'use strict';
 
-  paper = paper && Object.prototype.hasOwnProperty.call(paper, 'default') ? paper['default'] : paper;
+    paper = paper && paper.hasOwnProperty('default') ? paper['default'] : paper;
 
-  /**
-   * Offset the start/terminal segment of a bezier curve
-   * @param segment segment to offset
-   * @param curve curve to offset
-   * @param handleNormal the normal of the the line formed of two handles
-   * @param offset offset value
-   */
-  function offsetSegment(segment, curve, handleNormal, offset) {
-      var isFirst = segment.curve === curve;
-      // get offset vector
-      var offsetVector = (curve.getNormalAtTime(isFirst ? 0 : 1)).multiply(offset);
-      // get offset point
-      var point = segment.point.add(offsetVector);
-      var newSegment = new paper.Segment(point);
-      // handleOut for start segment & handleIn for terminal segment
-      var handle = (isFirst ? 'handleOut' : 'handleIn');
-      newSegment[handle] = segment[handle].add(handleNormal.subtract(offsetVector).divide(2));
-      return newSegment;
-  }
-  /**
-   * Adaptive offset a curve by repeatly apply the approximation proposed by Tiller and Hanson.
-   * @param curve curve to offset
-   * @param offset offset value
-   */
-  function adaptiveOffsetCurve(curve, offset) {
-      var hNormal = (new paper.Curve(curve.segment1.handleOut.add(curve.segment1.point), new paper.Point(0, 0), new paper.Point(0, 0), curve.segment2.handleIn.add(curve.segment2.point))).getNormalAtTime(0.5).multiply(offset);
-      var segment1 = offsetSegment(curve.segment1, curve, hNormal, offset);
-      var segment2 = offsetSegment(curve.segment2, curve, hNormal, offset);
-      // divide && re-offset
-      var offsetCurve = new paper.Curve(segment1, segment2);
-      // if the offset curve is not self intersected, divide it
-      if (offsetCurve.getIntersections(offsetCurve).length === 0) {
-          var threshold = Math.min(Math.abs(offset) / 10, 1);
-          var midOffset = offsetCurve.getPointAtTime(0.5).getDistance(curve.getPointAtTime(0.5));
-          if (Math.abs(midOffset - Math.abs(offset)) > threshold) {
-              var subCurve = curve.divideAtTime(0.5);
-              if (subCurve != null) {
-                  return adaptiveOffsetCurve(curve, offset).concat(adaptiveOffsetCurve(subCurve, offset));
-              }
-          }
-      }
-      return [segment1, segment2];
-  }
-  /**
-   * Create a round join segment between two adjacent segments.
-   */
-  function makeRoundJoin(segment1, segment2, originPoint, radius) {
-      var through = segment1.point.subtract(originPoint).add(segment2.point.subtract(originPoint))
-          .normalize(Math.abs(radius)).add(originPoint);
-      var arc = new paper.Path.Arc({ from: segment1.point, to: segment2.point, through: through, insert: false });
-      segment1.handleOut = arc.firstSegment.handleOut;
-      segment2.handleIn = arc.lastSegment.handleIn;
-      return arc.segments.length === 3 ? arc.segments[1] : null;
-  }
-  function det(p1, p2) {
-      return p1.x * p2.y - p1.y * p2.x;
-  }
-  /**
-   * Get the intersection point of point based lines
-   */
-  function getPointLineIntersections(p1, p2, p3, p4) {
-      var l1 = p1.subtract(p2);
-      var l2 = p3.subtract(p4);
-      var dl1 = det(p1, p2);
-      var dl2 = det(p3, p4);
-      return new paper.Point(dl1 * l2.x - l1.x * dl2, dl1 * l2.y - l1.y * dl2).divide(det(l1, l2));
-  }
-  /**
-   * Connect two adjacent bezier curve, each curve is represented by two segments,
-   * create different types of joins or simply removal redundant segment.
-   */
-  function connectAdjacentBezier(segments1, segments2, origin, joinType, offset, limit) {
-      var curve1 = new paper.Curve(segments1[0], segments1[1]);
-      var curve2 = new paper.Curve(segments2[0], segments2[1]);
-      var intersection = curve1.getIntersections(curve2);
-      var distance = segments1[1].point.getDistance(segments2[0].point);
-      if (origin.isSmooth()) {
-          segments2[0].handleOut = segments2[0].handleOut.project(origin.handleOut);
-          segments2[0].handleIn = segments1[1].handleIn.project(origin.handleIn);
-          segments2[0].point = segments1[1].point.add(segments2[0].point).divide(2);
-          segments1.pop();
-      }
-      else {
-          if (intersection.length === 0) {
-              if (distance > Math.abs(offset) * 0.1) {
-                  // connect
-                  switch (joinType) {
-                      case 'miter':
-                          var join = getPointLineIntersections(curve1.point2, curve1.point2.add(curve1.getTangentAtTime(1)), curve2.point1, curve2.point1.add(curve2.getTangentAtTime(0)));
-                          // prevent sharp angle
-                          var joinOffset = Math.max(join.getDistance(curve1.point2), join.getDistance(curve2.point1));
-                          if (joinOffset < Math.abs(offset) * limit) {
-                              segments1.push(new paper.Segment(join));
-                          }
-                          break;
-                      case 'round':
-                          var mid = makeRoundJoin(segments1[1], segments2[0], origin.point, offset);
-                          if (mid) {
-                              segments1.push(mid);
-                          }
-                          break;
-                  }
-              }
-              else {
-                  segments2[0].handleIn = segments1[1].handleIn;
-                  segments1.pop();
-              }
-          }
-          else {
-              var second1 = curve1.divideAt(intersection[0]);
-              if (second1) {
-                  var join = second1.segment1;
-                  var second2 = curve2.divideAt(curve2.getIntersections(curve1)[0]);
-                  join.handleOut = second2 ? second2.segment1.handleOut : segments2[0].handleOut;
-                  segments1.pop();
-                  segments2[0] = join;
-              }
-              else {
-                  segments2[0].handleIn = segments1[1].handleIn;
-                  segments1.pop();
-              }
-          }
-      }
-  }
-  /**
-   * Connect all the segments together.
-   */
-  function connectBeziers(rawSegments, join, source, offset, limit) {
-      var originSegments = source.segments;
-      var first = rawSegments[0].slice();
-      for (var i = 0; i < rawSegments.length - 1; ++i) {
-          connectAdjacentBezier(rawSegments[i], rawSegments[i + 1], originSegments[i + 1], join, offset, limit);
-      }
-      if (source.closed) {
-          connectAdjacentBezier(rawSegments[rawSegments.length - 1], first, originSegments[0], join, offset, limit);
-          rawSegments[0][0] = first[0];
-      }
-      return rawSegments;
-  }
-  function reduceSingleChildCompoundPath(path) {
-      if (path.children.length === 1) {
-          path = path.children[0];
-          path.remove(); // remove from parent, this is critical, or the style attributes will be ignored
-      }
-      return path;
-  }
-  /** Normalize a path, always clockwise, non-self-intersection, ignore really small components, and no one-component compound path. */
-  function normalize(path, areaThreshold) {
-      if (areaThreshold === void 0) { areaThreshold = 0.01; }
-      if (path.closed) {
-          var ignoreArea_1 = Math.abs(path.area * areaThreshold);
-          if (!path.clockwise) {
-              path.reverse();
-          }
-          path = path.unite(path, { insert: false });
-          if (path instanceof paper.CompoundPath) {
-              path.children.filter(function (c) { return Math.abs(c.area) < ignoreArea_1; }).forEach(function (c) { return c.remove(); });
-              if (path.children.length === 1) {
-                  return reduceSingleChildCompoundPath(path);
-              }
-          }
-      }
-      return path;
-  }
-  function isSameDirection(partialPath, fullPath) {
-      var offset1 = partialPath.segments[0].location.offset;
-      var offset2 = partialPath.segments[Math.max(1, Math.floor(partialPath.segments.length / 2))].location.offset;
-      var sampleOffset = (offset1 + offset2) / 3;
-      var originOffset1 = fullPath.getNearestLocation(partialPath.getPointAt(sampleOffset)).offset;
-      var originOffset2 = fullPath.getNearestLocation(partialPath.getPointAt(2 * sampleOffset)).offset;
-      return originOffset1 < originOffset2;
-  }
-  /** Remove self intersection when offset is negative by point direction dectection. */
-  function removeIntersection(path) {
-      if (path.closed) {
-          var newPath = path.unite(path, { insert: false });
-          if (newPath instanceof paper.CompoundPath) {
-              newPath.children.filter(function (c) {
-                  if (c.segments.length > 1) {
-                      return !isSameDirection(c, path);
-                  }
-                  else {
-                      return true;
-                  }
-              }).forEach(function (c) { return c.remove(); });
-              return reduceSingleChildCompoundPath(newPath);
-          }
-      }
-      return path;
-  }
-  function getSegments(path) {
-      if (path instanceof paper.CompoundPath) {
-          return path.children.map(function (c) { return c.segments; }).flat();
-      }
-      else {
-          return path.segments;
-      }
-  }
-  /**
-   * Remove impossible segments in negative offset condition.
-   */
-  function removeOutsiders(newPath, path) {
-      var segments = getSegments(newPath).slice();
-      segments.forEach(function (segment) {
-          if (!path.contains(segment.point)) {
-              segment.remove();
-          }
-      });
-  }
-  function preparePath(path, offset) {
-      var source = path.clone({ insert: false });
-      source.reduce({});
-      if (!path.clockwise) {
-          source.reverse();
-          offset = -offset;
-      }
-      return [source, offset];
-  }
-  function offsetSimpleShape(path, offset, join, limit) {
-      var _a;
-      var source;
-      _a = preparePath(path, offset), source = _a[0], offset = _a[1];
-      var curves = source.curves.slice();
-      var offsetCurves = curves.map(function (curve) { return adaptiveOffsetCurve(curve, offset); }).flat();
-      var raws = [];
-      for (var i = 0; i < offsetCurves.length; i += 2) {
-          raws.push(offsetCurves.slice(i, i + 2));
-      }
-      var segments = connectBeziers(raws, join, source, offset, limit).flat();
-      var newPath = removeIntersection(new paper.Path({ segments: segments, insert: false, closed: path.closed }));
-      newPath.reduce({});
-      if (source.closed && ((source.clockwise && offset < 0) || (!source.clockwise && offset > 0))) {
-          removeOutsiders(newPath, path);
-      }
-      // recovery path
-      if (source.clockwise !== path.clockwise) {
-          newPath.reverse();
-      }
-      return normalize(newPath);
-  }
-  function makeRoundCap(from, to, offset) {
-      var origin = from.point.add(to.point).divide(2);
-      var normal = to.point.subtract(from.point).rotate(-90, new paper.Point(0, 0)).normalize(offset);
-      var through = origin.add(normal);
-      var arc = new paper.Path.Arc({ from: from.point, to: to.point, through: through, insert: false });
-      return arc.segments;
-  }
-  function connectSide(outer, inner, offset, cap) {
-      if (outer instanceof paper.CompoundPath) {
-          var cs = outer.children.map(function (c) { return ({ c: c, a: Math.abs(c.area) }); });
-          cs = cs.sort(function (c1, c2) { return c2.a - c1.a; });
-          outer = cs[0].c;
-      }
-      var oSegments = outer.segments.slice();
-      var iSegments = inner.segments.slice();
-      switch (cap) {
-          case 'round':
-              var heads = makeRoundCap(iSegments[iSegments.length - 1], oSegments[0], offset);
-              var tails = makeRoundCap(oSegments[oSegments.length - 1], iSegments[0], offset);
-              var result = new paper.Path({ segments: heads.concat(oSegments, tails, iSegments), closed: true, insert: false });
-              result.reduce({});
-              return result;
-          default: return new paper.Path({ segments: oSegments.concat(iSegments), closed: true, insert: false });
-      }
-  }
-  function offsetSimpleStroke(path, offset, join, cap, limit) {
-      offset = path.clockwise ? offset : -offset;
-      var positiveOffset = offsetSimpleShape(path, offset, join, limit);
-      var negativeOffset = offsetSimpleShape(path, -offset, join, limit);
-      if (path.closed) {
-          return positiveOffset.subtract(negativeOffset, { insert: false });
-      }
-      else {
-          var inner = negativeOffset;
-          var holes = new Array();
-          if (negativeOffset instanceof paper.CompoundPath) {
-              holes = negativeOffset.children.filter(function (c) { return c.closed; });
-              holes.forEach(function (h) { return h.remove(); });
-              inner = negativeOffset.children[0];
-          }
-          inner.reverse();
-          var final = connectSide(positiveOffset, inner, offset, cap);
-          if (holes.length > 0) {
-              for (var _i = 0, holes_1 = holes; _i < holes_1.length; _i++) {
-                  var hole = holes_1[_i];
-                  final = final.subtract(hole, { insert: false });
-              }
-          }
-          return final;
-      }
-  }
-  function getNonSelfItersectionPath(path) {
-      if (path.closed) {
-          return path.unite(path, { insert: false });
-      }
-      return path;
-  }
-  function offsetPath(path, offset, join, limit) {
-      var nonSIPath = getNonSelfItersectionPath(path);
-      var result = nonSIPath;
-      if (nonSIPath instanceof paper.Path) {
-          result = offsetSimpleShape(nonSIPath, offset, join, limit);
-      }
-      else {
-          var offsetParts = nonSIPath.children.map(function (c) {
-              if (c.segments.length > 1) {
-                  if (!isSameDirection(c, path)) {
-                      c.reverse();
-                  }
-                  var offseted = offsetSimpleShape(c, offset, join, limit);
-                  offseted = normalize(offseted);
-                  if (offseted.clockwise !== c.clockwise) {
-                      offseted.reverse();
-                  }
-                  if (offseted instanceof paper.CompoundPath) {
-                      offseted.applyMatrix = true;
-                      return offseted.children;
-                  }
-                  else {
-                      return offseted;
-                  }
-              }
-              else {
-                  return null;
-              }
-          });
-          var children = offsetParts.flat().filter(function (c) { return !!c; });
-          result = new paper.CompoundPath({ children: children, insert: false });
-      }
-      result.copyAttributes(nonSIPath, false);
-      result.remove();
-      return result;
-  }
-  function offsetStroke(path, offset, join, cap, limit) {
-      var nonSIPath = getNonSelfItersectionPath(path);
-      var result = nonSIPath;
-      if (nonSIPath instanceof paper.Path) {
-          result = offsetSimpleStroke(nonSIPath, offset, join, cap, limit);
-      }
-      else {
-          var children = nonSIPath.children.flatMap(function (c) {
-              return offsetSimpleStroke(c, offset, join, cap, limit);
-          });
-          result = children.reduce(function (c1, c2) { return c1.unite(c2, { insert: false }); });
-      }
-      result.strokeWidth = 0;
-      result.fillColor = nonSIPath.strokeColor;
-      result.shadowBlur = nonSIPath.shadowBlur;
-      result.shadowColor = nonSIPath.shadowColor;
-      result.shadowOffset = nonSIPath.shadowOffset;
-      return result;
-  }
+    var Arrayex;
+    (function (Arrayex) {
+        function Delete(array, item, deleteAll) {
+            if (deleteAll === void 0) { deleteAll = false; }
+            if (deleteAll) {
+                var predicate = (typeof item === 'function') ? (function (v, i, a) { return !item(v, i, a); }) : (function (v) { return v !== item; });
+                var afterDeleted = array.filter(predicate);
+                if (afterDeleted.length < array.length) {
+                    array.splice.apply(array, [0, array.length].concat(afterDeleted));
+                    return true;
+                }
+            }
+            else {
+                var index = (typeof item === 'function') ? array.findIndex(item) : array.indexOf(item);
+                if (index > -1) {
+                    array.splice(index, 1);
+                    return true;
+                }
+            }
+            return false;
+        }
+        Arrayex.Delete = Delete;
+        function BatchDelete(array, items, deleteAll) {
+            if (deleteAll === void 0) { deleteAll = false; }
+            items.forEach(function (item) { Delete(array, item, deleteAll); });
+        }
+        Arrayex.BatchDelete = BatchDelete;
+        function Replace(array, item, newItem, replaceAll) {
+            if (replaceAll === void 0) { replaceAll = false; }
+            if (array != null) {
+                var replaced = false;
+                do {
+                    var index = (typeof item === 'function') ? array.findIndex(item) : array.indexOf(item);
+                    if (index > -1) {
+                        array[index] = newItem;
+                        replaced = true;
+                    }
+                    else {
+                        break;
+                    }
+                } while (replaceAll);
+                return replaced;
+            }
+            return false;
+        }
+        Arrayex.Replace = Replace;
+        function Find(array, predicate) {
+            var index = array.findIndex(predicate);
+            return array[index];
+        }
+        Arrayex.Find = Find;
+        /**
+         * IncludeSome() determines if at least one element in items is included in array.
+         */
+        function IncludeSome(array, items) {
+            return items.some(function (item) { return array.includes(item); });
+        }
+        Arrayex.IncludeSome = IncludeSome;
+        function OrderedInsert(orderedArray, item, compare, unique) {
+            if (unique === void 0) { unique = false; }
+            var index = orderedArray.findIndex(function (val) { return compare(val, item) >= 0; });
+            if (index > -1) {
+                var exist = compare(orderedArray[index], item) === 0;
+                orderedArray.splice(index, (exist && unique) ? 1 : 0, item);
+                return index;
+            }
+            else {
+                orderedArray.push(item);
+                return orderedArray.length - 1;
+            }
+        }
+        Arrayex.OrderedInsert = OrderedInsert;
+        /**
+         * InsertBefore() inserts an item into array before nextItem. insert to the head of array if nextItem doesn't exist.
+         */
+        function InsertBefore(array, item, nextItem) {
+            var index = array.indexOf(nextItem);
+            array.splice(Math.max(index, 0), 0, item);
+        }
+        Arrayex.InsertBefore = InsertBefore;
+        /**
+         * InsertAfter() inserts an item into array after prevItem. insert to the tail of array if prevItem doesn't exist.
+         */
+        function InsertAfter(array, item, prevItem) {
+            var index = array.indexOf(prevItem);
+            if (index > -1) {
+                array.splice(index + 1, 0, item);
+            }
+            else {
+                array.push(prevItem);
+            }
+        }
+        Arrayex.InsertAfter = InsertAfter;
+        function ApproximateIndex(array, value, epsilon) {
+            if (epsilon === void 0) { epsilon = 0; }
+            return array.findIndex(function (val) { return Math.abs(val - value) <= epsilon; });
+        }
+        Arrayex.ApproximateIndex = ApproximateIndex;
+        function Approximate(array, value, epsilon) {
+            if (epsilon === void 0) { epsilon = 0; }
+            var index = array.findIndex(function (val) { return Math.abs(val - value) <= epsilon; });
+            return array[index];
+        }
+        Arrayex.Approximate = Approximate;
+        function Empty(n) {
+            return n > 0 ? new Array(n).fill(null) : [];
+        }
+        Arrayex.Empty = Empty;
+        function Create(n, creator) {
+            return n > 0 ? new Array(n).fill(null).map(function (_, index) { return creator(index, n); }) : [];
+        }
+        Arrayex.Create = Create;
+        /**
+         * Repeat() repeats each element in sequence n times. e.g. Repeat(2, 1, 2) => [1, 1, 2, 2]
+         */
+        function Repeat(n) {
+            var sequence = [];
+            for (var _i = 1; _i < arguments.length; _i++) {
+                sequence[_i - 1] = arguments[_i];
+            }
+            return Create(n * sequence.length, function (index) { return sequence[Math.floor(index / n)]; });
+        }
+        Arrayex.Repeat = Repeat;
+        /**
+         * RepeatSequence() repeats full sequence n tims. e.g. Repeat(2, 1, 2) => [1, 2, 1, 2]
+         */
+        function RepeatSequence(n) {
+            var sequence = [];
+            for (var _i = 1; _i < arguments.length; _i++) {
+                sequence[_i - 1] = arguments[_i];
+            }
+            return Create(n * sequence.length, function (index) { return sequence[index % sequence.length]; });
+        }
+        Arrayex.RepeatSequence = RepeatSequence;
+        /**
+         * AnalyzePeriod() returns the minimum preriod of give array.
+         */
+        function AnalyzePeriod(array) {
+            var threshold = Math.ceil(Math.sqrt(array.length));
+            for (var length_1 = 1; length_1 <= threshold; ++length_1) {
+                if (array.length % length_1 === 0) {
+                    var sample = array.slice(0, length_1);
+                    var validate = true;
+                    for (var i = length_1; i < array.length; ++i) {
+                        if (array[i] !== sample[i % length_1]) {
+                            validate = false;
+                            break;
+                        }
+                    }
+                    if (validate) {
+                        return sample;
+                    }
+                }
+            }
+            return array;
+        }
+        Arrayex.AnalyzePeriod = AnalyzePeriod;
+        /**
+         * Flat() flats the array inside an array.
+         */
+        function Flat(array, keepNull) {
+            if (keepNull === void 0) { keepNull = false; }
+            var flat = Array.prototype.concat.apply([], array);
+            return keepNull ? flat : flat.filter(function (v) { return v != null; });
+        }
+        Arrayex.Flat = Flat;
+        /**
+         * Divide() divides a given array into partitions, each partition contains count element except the last one.
+         */
+        function Divide(array, count) {
+            var divides = [];
+            for (var i = 0; i < array.length; i += count) {
+                divides.push(array.slice(i, i + count));
+            }
+            return divides;
+        }
+        Arrayex.Divide = Divide;
+        /**
+         * Group() groups items in array into a directMap by a groupBy function.
+         */
+        function Group(array, groupBy) {
+            var groups = {};
+            array.forEach(function (item, index) {
+                var group = groupBy(item, index, array);
+                if (!groups[group]) {
+                    groups[group] = [];
+                }
+                groups[group].push(item);
+            });
+            return groups;
+        }
+        Arrayex.Group = Group;
+        /**
+         * Sample() samples a subarray of count in array.
+         */
+        function Sample(array, count, random) {
+            if (random === void 0) { random = false; }
+            if (count >= array.length) {
+                return array;
+            }
+            else {
+                if (!random) {
+                    var interval_1 = array.length / count;
+                    return Create(count, function (index) { return array[Math.round(interval_1 * index)]; });
+                }
+                else {
+                    var result = [];
+                    var copy = array.slice();
+                    for (var i = 0; i < count; ++i) {
+                        var item = copy.splice(Math.round(copy.length * Math.random()), 1)[0];
+                        result.push(item);
+                    }
+                    return result;
+                }
+            }
+        }
+        Arrayex.Sample = Sample;
+        function Union(arrays, unique) {
+            if (unique === void 0) { unique = false; }
+            var union = Array.prototype.concat.apply([], arrays);
+            return unique ? Array.from(new Set(union)) : union;
+        }
+        Arrayex.Union = Union;
+        function Intersect(arrays) {
+            if (arrays.length > 1) {
+                var intersectMap_1 = new Map();
+                arrays[0].forEach(function (v) { return intersectMap_1.set(v, 1); });
+                for (var i = 1; i < arrays.length; ++i) {
+                    arrays[i].forEach(function (item) {
+                        if (intersectMap_1.has(item)) {
+                            intersectMap_1.set(item, intersectMap_1.get(item) + 1);
+                        }
+                    });
+                }
+                var intersect_1 = new Array();
+                intersectMap_1.forEach(function (value, item) {
+                    if (value === arrays.length) {
+                        intersect_1.push(item);
+                    }
+                });
+                return intersect_1;
+            }
+            else {
+                return arrays[0] || [];
+            }
+        }
+        Arrayex.Intersect = Intersect;
+        function Subtract(array, arrays) {
+            if (arrays.length > 1) {
+                var union_1 = new Set(Array.prototype.concat.apply([], arrays));
+                return array.filter(function (item) { return !union_1.has(item); });
+            }
+            else {
+                return array || [];
+            }
+        }
+        Arrayex.Subtract = Subtract;
+        function NonNull(array) {
+            return array.filter(function (i) { return i != null; });
+        }
+        Arrayex.NonNull = NonNull;
+    })(Arrayex || (Arrayex = {}));
 
-  var PaperOffset = /** @class */ (function () {
-      function PaperOffset() {
-      }
-      PaperOffset.offset = function (path, offset, options) {
-          options = options || {};
-          var newPath = offsetPath(path, offset, options.join || 'miter', options.limit || 10);
-          if (options.insert === undefined) {
-              options.insert = true;
-          }
-          if (options.insert) {
-              (path.parent || paper.project.activeLayer).addChild(newPath);
-          }
-          return newPath;
-      };
-      PaperOffset.offsetStroke = function (path, offset, options) {
-          options = options || {};
-          var newPath = offsetStroke(path, offset, options.join || 'miter', options.cap || 'butt', options.limit || 10);
-          if (options.insert === undefined) {
-              options.insert = true;
-          }
-          if (options.insert) {
-              (path.parent || paper.project.activeLayer).addChild(newPath);
-          }
-          return newPath;
-      };
-      return PaperOffset;
-  }());
-  /**
-   * @deprecated EXTEND existing paper module is not recommend anymore
-   */
-  function ExtendPaperJs(paperNs) {
-      paperNs.Path.prototype.offset = function (offset, options) {
-          return PaperOffset.offset(this, offset, options);
-      };
-      paperNs.Path.prototype.offsetStroke = function (offset, options) {
-          return PaperOffset.offsetStroke(this, offset, options);
-      };
-      paperNs.CompoundPath.prototype.offset = function (offset, options) {
-          return PaperOffset.offset(this, offset, options);
-      };
-      paperNs.CompoundPath.prototype.offsetStroke = function (offset, options) {
-          return PaperOffset.offsetStroke(this, offset, options);
-      };
-  }
+    var Offsets;
+    (function (Offsets) {
+        /**
+         * Offset the start/terminal segment of a bezier curve
+         * @param segment segment to offset
+         * @param curve curve to offset
+         * @param handleNormal the normal of the the line formed of two handles
+         * @param offset offset value
+         */
+        function OffsetSegment(segment, curve, handleNormal, offset) {
+            var isFirst = segment.curve === curve;
+            // get offset vector
+            var offsetVector = (curve.getNormalAt(isFirst ? 0 : 1, true)).multiply(offset);
+            // get offset point
+            var point = segment.point.add(offsetVector);
+            var newSegment = new paper.Segment(point);
+            // handleOut for start segment & handleIn for terminal segment
+            var handle = (isFirst ? 'handleOut' : 'handleIn');
+            newSegment[handle] = segment[handle].add(handleNormal.subtract(offsetVector).divide(2));
+            return newSegment;
+        }
+        /**
+         * Adaptive offset a curve by repeatly apply the approximation proposed by Tiller and Hanson.
+         * @param curve curve to offset
+         * @param offset offset value
+         */
+        function AdaptiveOffsetCurve(curve, offset) {
+            var hNormal = (new paper.Curve(curve.segment1.handleOut.add(curve.segment1.point), new paper.Point(0, 0), new paper.Point(0, 0), curve.segment2.handleIn.add(curve.segment2.point))).getNormalAt(0.5, true).multiply(offset);
+            var segment1 = OffsetSegment(curve.segment1, curve, hNormal, offset);
+            var segment2 = OffsetSegment(curve.segment2, curve, hNormal, offset);
+            // divide && re-offset
+            var offsetCurve = new paper.Curve(segment1, segment2);
+            // if the offset curve is not self intersected, divide it
+            if (offsetCurve.getIntersections(offsetCurve).length === 0) {
+                var threshold = Math.min(Math.abs(offset) / 10, 1);
+                var midOffset = offsetCurve.getPointAt(0.5, true).getDistance(curve.getPointAt(0.5, true));
+                if (Math.abs(midOffset - Math.abs(offset)) > threshold) {
+                    var subCurve = curve.divideAtTime(0.5);
+                    if (subCurve != null) {
+                        return AdaptiveOffsetCurve(curve, offset).concat(AdaptiveOffsetCurve(subCurve, offset));
+                    }
+                }
+            }
+            return [segment1, segment2];
+        }
+        /**
+         * Create a round join segment between two adjacent segments.
+         */
+        function MakeRoundJoin(segment1, segment2, originPoint, radius) {
+            var through = segment1.point.subtract(originPoint).add(segment2.point.subtract(originPoint)).normalize(Math.abs(radius)).add(originPoint);
+            var arc = new paper.Path.Arc({ from: segment1.point, to: segment2.point, through: through, insert: false });
+            segment1.handleOut = arc.firstSegment.handleOut;
+            segment2.handleIn = arc.lastSegment.handleIn;
+            return arc.segments.length === 3 ? arc.segments[1] : null;
+        }
+        function Det(p1, p2) {
+            return p1.x * p2.y - p1.y * p2.x;
+        }
+        /**
+         * Get the intersection point of two point
+         */
+        function Intersection(p1, p2, p3, p4) {
+            var l1 = p1.subtract(p2);
+            var l2 = p3.subtract(p4);
+            var dl1 = Det(p1, p2);
+            var dl2 = Det(p3, p4);
+            return new paper.Point(dl1 * l2.x - l1.x * dl2, dl1 * l2.y - l1.y * dl2).divide(Det(l1, l2));
+        }
+        /**
+         * Connect two adjacent bezier curve, each curve is represented by two segments, create different types of joins or simply removal redundant segment.
+         */
+        function ConnectAdjacentBezier(segments1, segments2, origin, join, offset, limit) {
+            var curve1 = new paper.Curve(segments1[0], segments1[1]);
+            var curve2 = new paper.Curve(segments2[0], segments2[1]);
+            var intersection = curve1.getIntersections(curve2);
+            var distance = segments1[1].point.getDistance(segments2[0].point);
+            if (origin.isSmooth()) {
+                segments2[0].handleOut = segments2[0].handleOut.project(origin.handleOut);
+                segments2[0].handleIn = segments1[1].handleIn.project(origin.handleIn);
+                segments2[0].point = segments1[1].point.add(segments2[0].point).divide(2);
+                segments1.pop();
+            }
+            else {
+                if (intersection.length === 0) {
+                    if (distance > Math.abs(offset) * 0.1) {
+                        // connect
+                        switch (join) {
+                            case 'miter':
+                                var join_1 = Intersection(curve1.point2, curve1.point2.add(curve1.getTangentAt(1, true)), curve2.point1, curve2.point1.add(curve2.getTangentAt(0, true)));
+                                // prevent sharp angle
+                                var joinOffset = Math.max(join_1.getDistance(curve1.point2), join_1.getDistance(curve2.point1));
+                                if (joinOffset < Math.abs(offset) * limit) {
+                                    segments1.push(new paper.Segment(join_1));
+                                }
+                                break;
+                            case 'round':
+                                var mid = MakeRoundJoin(segments1[1], segments2[0], origin.point, offset);
+                                if (mid) {
+                                    segments1.push(mid);
+                                }
+                                break;
+                            default: break;
+                        }
+                    }
+                    else {
+                        segments2[0].handleIn = segments1[1].handleIn;
+                        segments1.pop();
+                    }
+                }
+                else {
+                    var second1 = curve1.divideAt(intersection[0]);
+                    if (second1) {
+                        var join_2 = second1.segment1;
+                        var second2 = curve2.divideAt(curve2.getIntersections(curve1)[0]);
+                        join_2.handleOut = second2 ? second2.segment1.handleOut : segments2[0].handleOut;
+                        segments1.pop();
+                        segments2[0] = join_2;
+                    }
+                    else {
+                        segments2[0].handleIn = segments1[1].handleIn;
+                        segments1.pop();
+                    }
+                }
+            }
+        }
+        Offsets.ConnectAdjacentBezier = ConnectAdjacentBezier;
+        /**
+         * Connect all the segments together.
+         */
+        function ConnectBeziers(rawSegments, join, source, offset, limit) {
+            var originSegments = source.segments;
+            var first = rawSegments[0].slice();
+            for (var i = 0; i < rawSegments.length - 1; ++i) {
+                ConnectAdjacentBezier(rawSegments[i], rawSegments[i + 1], originSegments[i + 1], join, offset, limit);
+            }
+            if (source.closed) {
+                ConnectAdjacentBezier(rawSegments[rawSegments.length - 1], first, originSegments[0], join, offset, limit);
+                rawSegments[0][0] = first[0];
+            }
+            return rawSegments;
+        }
+        function Decompound(path) {
+            if (path.children.length === 1) {
+                path = path.children[0];
+                path.remove(); // remove from parent, this is critical, or the style attributes will be ignored
+            }
+            return path;
+        }
+        /** Normalize a path, always clockwise, non-self-intersection, ignore really small components, and no one-component compound path. */
+        function Normalize(path, areaThreshold) {
+            if (areaThreshold === void 0) { areaThreshold = 0.01; }
+            if (path.closed) {
+                var ignoreArea_1 = Math.abs(path.area * areaThreshold);
+                if (!path.clockwise) {
+                    path.reverse();
+                }
+                path = path.unite(path, { insert: false });
+                if (path instanceof paper.CompoundPath) {
+                    path.children.filter(function (c) { return Math.abs(c.area) < ignoreArea_1; }).forEach(function (c) { return c.remove(); });
+                    if (path.children.length === 1) {
+                        return Decompound(path);
+                    }
+                }
+            }
+            return path;
+        }
+        Offsets.Normalize = Normalize;
+        function IsSameDirection(partialPath, fullPath) {
+            var offset1 = partialPath.segments[0].location.offset;
+            var offset2 = partialPath.segments[Math.max(1, Math.floor(partialPath.segments.length / 2))].location.offset;
+            var sampleOffset = (offset1 + offset2) / 3;
+            var originOffset1 = fullPath.getNearestLocation(partialPath.getPointAt(sampleOffset)).offset;
+            var originOffset2 = fullPath.getNearestLocation(partialPath.getPointAt(2 * sampleOffset)).offset;
+            return originOffset1 < originOffset2;
+        }
+        Offsets.IsSameDirection = IsSameDirection;
+        /** Remove self intersection when offset is negative by point direction dectection. */
+        function RemoveIntersection(path) {
+            var newPath = path.unite(path, { insert: false });
+            if (newPath instanceof paper.CompoundPath) {
+                newPath.children.filter(function (c) {
+                    if (c.segments.length > 1) {
+                        return !IsSameDirection(c, path);
+                    }
+                    else {
+                        return true;
+                    }
+                }).forEach(function (c) { return c.remove(); });
+                return Decompound(newPath);
+            }
+            return path;
+        }
+        Offsets.RemoveIntersection = RemoveIntersection;
+        function Segments(path) {
+            if (path instanceof paper.CompoundPath) {
+                return Arrayex.Flat(path.children.map(function (c) { return c.segments; }));
+            }
+            else {
+                return path.segments;
+            }
+        }
+        /**
+         * Remove impossible segments in negative offset condition.
+         */
+        function RemoveOutsiders(offsetPath, path) {
+            var segments = Segments(offsetPath).slice();
+            segments.forEach(function (segment) {
+                if (!path.contains(segment.point)) {
+                    segment.remove();
+                }
+            });
+        }
+        function PreparePath(path, offset) {
+            var source = path.clone({ insert: false });
+            source.reduce();
+            if (!path.clockwise) {
+                source.reverse();
+                offset = -offset;
+            }
+            return [source, offset];
+        }
+        function OffsetSimpleShape(path, offset, join, limit) {
+            var _a;
+            var source;
+            _a = PreparePath(path, offset), source = _a[0], offset = _a[1];
+            var curves = source.curves.slice();
+            var raws = Arrayex.Divide(Arrayex.Flat(curves.map(function (curve) { return AdaptiveOffsetCurve(curve, offset); })), 2);
+            var segments = Arrayex.Flat(ConnectBeziers(raws, join, source, offset, limit));
+            var offsetPath = RemoveIntersection(new paper.Path({ segments: segments, insert: false, closed: path.closed }));
+            offsetPath.reduce();
+            if (source.closed && ((source.clockwise && offset < 0) || (!source.clockwise && offset > 0))) {
+                RemoveOutsiders(offsetPath, path);
+            }
+            // recovery path
+            if (source.clockwise !== path.clockwise) {
+                offsetPath.reverse();
+            }
+            return Normalize(offsetPath);
+        }
+        Offsets.OffsetSimpleShape = OffsetSimpleShape;
+        function MakeRoundCap(from, to, offset) {
+            var origin = from.point.add(to.point).divide(2);
+            var normal = to.point.subtract(from.point).rotate(-90).normalize(offset);
+            var through = origin.add(normal);
+            var arc = new paper.Path.Arc({ from: from.point, to: to.point, through: through, insert: false });
+            return arc.segments;
+        }
+        function ConnectSide(outer, inner, offset, cap) {
+            if (outer instanceof paper.CompoundPath) {
+                var cs = outer.children.map(function (c) { return ({ c: c, a: Math.abs(c.area) }); });
+                cs = cs.sort(function (c1, c2) { return c2.a - c1.a; });
+                outer = cs[0].c;
+            }
+            var oSegments = outer.segments.slice();
+            var iSegments = inner.segments.slice();
+            switch (cap) {
+                case 'round':
+                    var heads = MakeRoundCap(iSegments[iSegments.length - 1], oSegments[0], offset);
+                    var tails = MakeRoundCap(oSegments[oSegments.length - 1], iSegments[0], offset);
+                    var result = new paper.Path({ segments: heads.concat(oSegments, tails, iSegments), closed: true, insert: false });
+                    result.reduce();
+                    return result;
+                default: return new paper.Path({ segments: oSegments.concat(iSegments), closed: true, insert: false });
+            }
+        }
+        function OffsetSimpleStroke(path, offset, join, cap, limit) {
+            offset = path.clockwise ? offset : -offset;
+            var positiveOffset = OffsetSimpleShape(path, offset, join, limit);
+            var negativeOffset = OffsetSimpleShape(path, -offset, join, limit);
+            if (path.closed) {
+                return positiveOffset.subtract(negativeOffset, { insert: false });
+            }
+            else {
+                var inner = negativeOffset;
+                var holes = new Array();
+                if (negativeOffset instanceof paper.CompoundPath) {
+                    holes = negativeOffset.children.filter(function (c) { return c.closed; });
+                    holes.forEach(function (h) { return h.remove(); });
+                    inner = negativeOffset.children[0];
+                }
+                inner.reverse();
+                var final = ConnectSide(positiveOffset, inner, offset, cap);
+                if (holes.length > 0) {
+                    for (var _i = 0, holes_1 = holes; _i < holes_1.length; _i++) {
+                        var hole = holes_1[_i];
+                        final = final.subtract(hole, { insert: false });
+                    }
+                }
+                return final;
+            }
+        }
+        Offsets.OffsetSimpleStroke = OffsetSimpleStroke;
+    })(Offsets || (Offsets = {}));
+    function OffsetPath(path, offset, join, limit) {
+        var nonSIPath = path.unite(path, { insert: false });
+        var result = nonSIPath;
+        if (nonSIPath instanceof paper.Path) {
+            result = Offsets.OffsetSimpleShape(nonSIPath, offset, join, limit);
+        }
+        else {
+            var children = Arrayex.Flat(nonSIPath.children.map(function (c) {
+                if (c.segments.length > 1) {
+                    if (!Offsets.IsSameDirection(c, path)) {
+                        c.reverse();
+                    }
+                    var offseted = Offsets.OffsetSimpleShape(c, offset, join, limit);
+                    offseted = Offsets.Normalize(offseted);
+                    if (offseted.clockwise !== c.clockwise) {
+                        offseted.reverse();
+                    }
+                    if (offseted instanceof paper.CompoundPath) {
+                        offseted.applyMatrix = true;
+                        return offseted.children;
+                    }
+                    else {
+                        return offseted;
+                    }
+                }
+                else {
+                    return null;
+                }
+            }), false);
+            result = new paper.CompoundPath({ children: children, insert: false });
+        }
+        result.copyAttributes(nonSIPath, false);
+        result.remove();
+        return result;
+    }
+    function OffsetStroke(path, offset, join, cap, limit) {
+        var nonSIPath = path.unite(path, { insert: false });
+        var result = nonSIPath;
+        if (nonSIPath instanceof paper.Path) {
+            result = Offsets.OffsetSimpleStroke(nonSIPath, offset, join, cap, limit);
+        }
+        else {
+            var children = Arrayex.Flat(nonSIPath.children.map(function (c) {
+                return Offsets.OffsetSimpleStroke(c, offset, join, cap, limit);
+            }));
+            result = children.reduce(function (c1, c2) { return c1.unite(c2, { insert: false }); });
+        }
+        result.strokeWidth = 0;
+        result.fillColor = nonSIPath.strokeColor;
+        result.shadowBlur = nonSIPath.shadowBlur;
+        result.shadowColor = nonSIPath.shadowColor;
+        result.shadowOffset = nonSIPath.shadowOffset;
+        return result;
+    }
 
-  ExtendPaperJs(paper);
-  window.PaperOffset = {
-      offset: PaperOffset.offset,
-      offsetStroke: PaperOffset.offsetStroke,
-  };
+    function PrototypedOffset(path, offset, options) {
+        options = options || {};
+        var offsetPath = OffsetPath(path, offset, options.join || 'miter', options.limit || 10);
+        if (options.insert === undefined) {
+            options.insert = true;
+        }
+        if (options.insert) {
+            (path.parent || paper.project.activeLayer).addChild(offsetPath);
+        }
+        return offsetPath;
+    }
+    function PrototypedOffsetStroke(path, offset, options) {
+        options = options || {};
+        var offsetPath = OffsetStroke(path, offset, options.join || 'miter', options.cap || 'butt', options.limit || 10);
+        if (options.insert === undefined) {
+            options.insert = true;
+        }
+        if (options.insert) {
+            (path.parent || paper.project.activeLayer).addChild(offsetPath);
+        }
+        return offsetPath;
+    }
+    function ExtendPaperJs(paper) {
+        paper.Path.prototype.offset = function (offset, options) {
+            return PrototypedOffset(this, offset, options);
+        };
+        paper.Path.prototype.offsetStroke = function (offset, options) {
+            return PrototypedOffsetStroke(this, offset, options);
+        };
+        paper.CompoundPath.prototype.offset = function (offset, options) {
+            return PrototypedOffset(this, offset, options);
+        };
+        paper.CompoundPath.prototype.offsetStroke = function (offset, options) {
+            return PrototypedOffsetStroke(this, offset, options);
+        };
+    }
+
+    ExtendPaperJs(paper);
 
 }(paper));
diff --git a/node_modules/paperjs-offset/dist/paperjs-offset.min.js b/node_modules/paperjs-offset/dist/paperjs-offset.min.js
index 51a8ec0..b66fd9f 100644
--- a/node_modules/paperjs-offset/dist/paperjs-offset.min.js
+++ b/node_modules/paperjs-offset/dist/paperjs-offset.min.js
@@ -1 +1 @@
-!function(S){"use strict";function p(e,t,n,r){var o=e.curve===t,i=t.getNormalAtTime(o?0:1).multiply(r),a=e.point.add(i),s=new S.Segment(a),c=o?"handleOut":"handleIn";return s[c]=e[c].add(n.subtract(i).divide(2)),s}function T(e,t){return e.x*t.y-e.y*t.x}function m(e,t,n,r,o,i){var a,s,c,u,f,l,d,h,p,m,g,v,w,P,b=new S.Curve(e[0],e[1]),k=new S.Curve(t[0],t[1]),C=b.getIntersections(k),y=e[1].point.getDistance(t[0].point);if(n.isSmooth())t[0].handleOut=t[0].handleOut.project(n.handleOut),t[0].handleIn=e[1].handleIn.project(n.handleIn),t[0].point=e[1].point.add(t[0].point).divide(2),e.pop();else if(0===C.length)if(y>.1*Math.abs(o))switch(r){case"miter":var A=(d=b.point2,h=b.point2.add(b.getTangentAtTime(1)),p=k.point1,m=k.point1.add(k.getTangentAtTime(0)),g=d.subtract(h),v=p.subtract(m),w=T(d,h),P=T(p,m),new S.Point(w*v.x-g.x*P,w*v.y-g.y*P).divide(T(g,v)));Math.max(A.getDistance(b.point2),A.getDistance(k.point1))<Math.abs(o)*i&&e.push(new S.Segment(A));break;case"round":var M=(a=e[1],s=t[0],c=n.point,u=o,f=a.point.subtract(c).add(s.point.subtract(c)).normalize(Math.abs(u)).add(c),l=new S.Path.Arc({from:a.point,to:s.point,through:f,insert:!1}),a.handleOut=l.firstSegment.handleOut,s.handleIn=l.lastSegment.handleIn,3===l.segments.length?l.segments[1]:null);M&&e.push(M)}else t[0].handleIn=e[1].handleIn,e.pop();else{var O=b.divideAt(C[0]);if(O){A=O.segment1;var I=k.divideAt(k.getIntersections(b)[0]);A.handleOut=I?I.segment1.handleOut:t[0].handleOut,e.pop(),t[0]=A}else t[0].handleIn=e[1].handleIn,e.pop()}}function g(e){return 1===e.children.length&&(e=e.children[0]).remove(),e}function v(e,t){if(void 0===t&&(t=.01),e.closed){var n=Math.abs(e.area*t);if(e.clockwise||e.reverse(),(e=e.unite(e,{insert:!1}))instanceof S.CompoundPath&&(e.children.filter(function(e){return Math.abs(e.area)<n}).forEach(function(e){return e.remove()}),1===e.children.length))return g(e)}return e}function w(e,t){var n=(e.segments[0].location.offset+e.segments[Math.max(1,Math.floor(e.segments.length/2))].location.offset)/3;return t.getNearestLocation(e.getPointAt(n)).offset<t.getNearestLocation(e.getPointAt(2*n)).offset}function P(e,t){var n;((n=e)instanceof S.CompoundPath?n.children.map(function(e){return e.segments}).flat():n.segments).slice().forEach(function(e){t.contains(e.point)||e.remove()})}function h(e,t,n,r){var o,i,a,s,c;s=t,(c=(a=e).clone({insert:!1})).reduce({}),a.clockwise||(c.reverse(),s=-s),t=(o=[c,s])[1];for(var u=(i=o[0]).curves.slice().map(function(e){return function e(t,n){var r=new S.Curve(t.segment1.handleOut.add(t.segment1.point),new S.Point(0,0),new S.Point(0,0),t.segment2.handleIn.add(t.segment2.point)).getNormalAtTime(.5).multiply(n),o=p(t.segment1,t,r,n),i=p(t.segment2,t,r,n),a=new S.Curve(o,i);if(0===a.getIntersections(a).length){var s=Math.min(Math.abs(n)/10,1),c=a.getPointAtTime(.5).getDistance(t.getPointAtTime(.5));if(Math.abs(c-Math.abs(n))>s){var u=t.divideAtTime(.5);if(null!=u)return e(t,n).concat(e(u,n))}}return[o,i]}(e,t)}).flat(),f=[],l=0;l<u.length;l+=2)f.push(u.slice(l,l+2));var d=function(e,t,n,r,o){for(var i=n.segments,a=e[0].slice(),s=0;s<e.length-1;++s)m(e[s],e[s+1],i[s+1],t,r,o);return n.closed&&(m(e[e.length-1],a,i[0],t,r,o),e[0][0]=a[0]),e}(f,n,i,t,r).flat(),h=function(t){if(t.closed){var e=t.unite(t,{insert:!1});if(e instanceof S.CompoundPath)return e.children.filter(function(e){return!(1<e.segments.length)||!w(e,t)}).forEach(function(e){return e.remove()}),g(e)}return t}(new S.Path({segments:d,insert:!1,closed:e.closed}));return h.reduce({}),i.closed&&(i.clockwise&&t<0||!i.clockwise&&0<t)&&P(h,e),i.clockwise!==e.clockwise&&h.reverse(),v(h)}function b(e,t,n){var r=e.point.add(t.point).divide(2),o=t.point.subtract(e.point).rotate(-90,new S.Point(0,0)).normalize(n),i=r.add(o);return new S.Path.Arc({from:e.point,to:t.point,through:i,insert:!1}).segments}function l(e,t,n,r,o){var i=h(e,t=e.clockwise?t:-t,n,o),a=h(e,-t,n,o);if(e.closed)return i.subtract(a,{insert:!1});var s=a,c=new Array;a instanceof S.CompoundPath&&((c=a.children.filter(function(e){return e.closed})).forEach(function(e){return e.remove()}),s=a.children[0]),s.reverse();var u=function(e,t,n,r){if(e instanceof S.CompoundPath){var o=e.children.map(function(e){return{c:e,a:Math.abs(e.area)}});e=(o=o.sort(function(e,t){return t.a-e.a}))[0].c}var i=e.segments.slice(),a=t.segments.slice();switch(r){case"round":var s=b(a[a.length-1],i[0],n),c=b(i[i.length-1],a[0],n),u=new S.Path({segments:s.concat(i,c,a),closed:!0,insert:!1});return u.reduce({}),u;default:return new S.Path({segments:i.concat(a),closed:!0,insert:!1})}}(i,s,t,r);if(0<c.length)for(var f=0,l=c;f<l.length;f++){var d=l[f];u=u.subtract(d,{insert:!1})}return u}function d(e){return e.closed?e.unite(e,{insert:!1}):e}S=S&&Object.prototype.hasOwnProperty.call(S,"default")?S.default:S;var e,n=(t.offset=function(e,t,n){var r=function(n,r,o,i){var e=d(n),t=e;if(e instanceof S.Path)t=h(e,r,o,i);else{var a=e.children.map(function(e){if(1<e.segments.length){w(e,n)||e.reverse();var t=h(e,r,o,i);return(t=v(t)).clockwise!==e.clockwise&&t.reverse(),t instanceof S.CompoundPath?(t.applyMatrix=!0,t.children):t}return null}).flat().filter(function(e){return!!e});t=new S.CompoundPath({children:a,insert:!1})}return t.copyAttributes(e,!1),t.remove(),t}(e,t,(n=n||{}).join||"miter",n.limit||10);return void 0===n.insert&&(n.insert=!0),n.insert&&(e.parent||S.project.activeLayer).addChild(r),r},t.offsetStroke=function(e,t,n){var r,o,i,a,s,c,u,f=(r=e,o=t,i=(n=n||{}).join||"miter",a=n.cap||"butt",s=n.limit||10,c=d(r),(u=(u=c)instanceof S.Path?l(c,o,i,a,s):c.children.flatMap(function(e){return l(e,o,i,a,s)}).reduce(function(e,t){return e.unite(t,{insert:!1})})).strokeWidth=0,u.fillColor=c.strokeColor,u.shadowBlur=c.shadowBlur,u.shadowColor=c.shadowColor,u.shadowOffset=c.shadowOffset,u);return void 0===n.insert&&(n.insert=!0),n.insert&&(e.parent||S.project.activeLayer).addChild(f),f},t);function t(){}(e=S).Path.prototype.offset=function(e,t){return n.offset(this,e,t)},e.Path.prototype.offsetStroke=function(e,t){return n.offsetStroke(this,e,t)},e.CompoundPath.prototype.offset=function(e,t){return n.offset(this,e,t)},e.CompoundPath.prototype.offsetStroke=function(e,t){return n.offsetStroke(this,e,t)},window.PaperOffset={offset:n.offset,offsetStroke:n.offsetStroke}}(paper);
+!function(w){"use strict";var y,u,n;function e(n,t,e){var r=function(e,r,i,o){var n=e.unite(e,{insert:!1}),t=n;if(n instanceof w.Path)t=u.OffsetSimpleShape(n,r,i,o);else{var a=y.Flat(n.children.map(function(n){if(1<n.segments.length){u.IsSameDirection(n,e)||n.reverse();var t=u.OffsetSimpleShape(n,r,i,o);return(t=u.Normalize(t)).clockwise!==n.clockwise&&t.reverse(),t instanceof w.CompoundPath?(t.applyMatrix=!0,t.children):t}return null}),!1);t=new w.CompoundPath({children:a,insert:!1})}return t.copyAttributes(n,!1),t.remove(),t}(n,t,(e=e||{}).join||"miter",e.limit||10);return void 0===e.insert&&(e.insert=!0),e.insert&&(n.parent||w.project.activeLayer).addChild(r),r}function r(n,t,e){var r=function(n,t,e,r,i){var o=n.unite(n,{insert:!1}),a=o;return(a=o instanceof w.Path?u.OffsetSimpleStroke(o,t,e,r,i):y.Flat(o.children.map(function(n){return u.OffsetSimpleStroke(n,t,e,r,i)})).reduce(function(n,t){return n.unite(t,{insert:!1})})).strokeWidth=0,a.fillColor=o.strokeColor,a.shadowBlur=o.shadowBlur,a.shadowColor=o.shadowColor,a.shadowOffset=o.shadowOffset,a}(n,t,(e=e||{}).join||"miter",e.cap||"butt",e.limit||10);return void 0===e.insert&&(e.insert=!0),e.insert&&(n.parent||w.project.activeLayer).addChild(r),r}w=w&&w.hasOwnProperty("default")?w.default:w,function(n){function r(n,r,t){if(void 0===t&&(t=!1),t){var e="function"==typeof r?function(n,t,e){return!r(n,t,e)}:function(n){return n!==r},i=n.filter(e);if(i.length<n.length)return n.splice.apply(n,[0,n.length].concat(i)),!0}else{var o="function"==typeof r?n.findIndex(r):n.indexOf(r);if(-1<o)return n.splice(o,1),!0}return!1}function c(e,r){return 0<e?new Array(e).fill(null).map(function(n,t){return r(t,e)}):[]}n.Delete=r,n.BatchDelete=function(t,n,e){void 0===e&&(e=!1),n.forEach(function(n){r(t,n,e)})},n.Replace=function(n,t,e,r){if(void 0===r&&(r=!1),null==n)return!1;var i=!1;do{var o="function"==typeof t?n.findIndex(t):n.indexOf(t);if(!(-1<o))break;n[o]=e,i=!0}while(r);return i},n.Find=function(n,t){var e=n.findIndex(t);return n[e]},n.IncludeSome=function(t,n){return n.some(function(n){return t.includes(n)})},n.OrderedInsert=function(n,t,e,r){void 0===r&&(r=!1);var i=n.findIndex(function(n){return 0<=e(n,t)});if(-1<i){var o=0===e(n[i],t);return n.splice(i,o&&r?1:0,t),i}return n.push(t),n.length-1},n.InsertBefore=function(n,t,e){var r=n.indexOf(e);n.splice(Math.max(r,0),0,t)},n.InsertAfter=function(n,t,e){var r=n.indexOf(e);-1<r?n.splice(r+1,0,t):n.push(e)},n.ApproximateIndex=function(n,t,e){return void 0===e&&(e=0),n.findIndex(function(n){return Math.abs(n-t)<=e})},n.Approximate=function(n,t,e){void 0===e&&(e=0);var r=n.findIndex(function(n){return Math.abs(n-t)<=e});return n[r]},n.Empty=function(n){return 0<n?new Array(n).fill(null):[]},n.Create=c,n.Repeat=function(t){for(var e=[],n=1;n<arguments.length;n++)e[n-1]=arguments[n];return c(t*e.length,function(n){return e[Math.floor(n/t)]})},n.RepeatSequence=function(n){for(var t=[],e=1;e<arguments.length;e++)t[e-1]=arguments[e];return c(n*t.length,function(n){return t[n%t.length]})},n.AnalyzePeriod=function(n){for(var t=Math.ceil(Math.sqrt(n.length)),e=1;e<=t;++e)if(n.length%e==0){for(var r=n.slice(0,e),i=!0,o=e;o<n.length;++o)if(n[o]!==r[o%e]){i=!1;break}if(i)return r}return n},n.Flat=function(n,t){void 0===t&&(t=!1);var e=Array.prototype.concat.apply([],n);return t?e:e.filter(function(n){return null!=n})},n.Divide=function(n,t){for(var e=[],r=0;r<n.length;r+=t)e.push(n.slice(r,r+t));return e},n.Group=function(r,i){var o={};return r.forEach(function(n,t){var e=i(n,t,r);o[e]||(o[e]=[]),o[e].push(n)}),o},n.Sample=function(t,n,e){if(void 0===e&&(e=!1),n>=t.length)return t;if(e){for(var r=[],i=t.slice(),o=0;o<n;++o){var a=i.splice(Math.round(i.length*Math.random()),1)[0];r.push(a)}return r}var u=t.length/n;return c(n,function(n){return t[Math.round(u*n)]})},n.Union=function(n,t){void 0===t&&(t=!1);var e=Array.prototype.concat.apply([],n);return t?Array.from(new Set(e)):e},n.Intersect=function(e){if(1<e.length){var t=new Map;e[0].forEach(function(n){return t.set(n,1)});for(var n=1;n<e.length;++n)e[n].forEach(function(n){t.has(n)&&t.set(n,t.get(n)+1)});var r=new Array;return t.forEach(function(n,t){n===e.length&&r.push(t)}),r}return e[0]||[]},n.Subtract=function(n,t){if(1<t.length){var e=new Set(Array.prototype.concat.apply([],t));return n.filter(function(n){return!e.has(n)})}return n||[]},n.NonNull=function(n){return n.filter(function(n){return null!=n})}}(y||(y={})),function(n){function f(n,t,e,r){var i=n.curve===t,o=t.getNormalAt(i?0:1,!0).multiply(r),a=n.point.add(o),u=new w.Segment(a),c=i?"handleOut":"handleIn";return u[c]=n[c].add(e.subtract(o).divide(2)),u}function v(n,t){return n.x*t.y-n.y*t.x}function l(n,t,e,r,i,o){var a=new w.Curve(n[0],n[1]),u=new w.Curve(t[0],t[1]),c=a.getIntersections(u),s=n[1].point.getDistance(t[0].point);if(e.isSmooth())t[0].handleOut=t[0].handleOut.project(e.handleOut),t[0].handleIn=n[1].handleIn.project(e.handleIn),t[0].point=n[1].point.add(t[0].point).divide(2),n.pop();else if(0===c.length)if(s>.1*Math.abs(i))switch(r){case"miter":var f=function(n,t,e,r){var i=n.subtract(t),o=e.subtract(r),a=v(n,t),u=v(e,r);return new w.Point(a*o.x-i.x*u,a*o.y-i.y*u).divide(v(i,o))}(a.point2,a.point2.add(a.getTangentAt(1,!0)),u.point1,u.point1.add(u.getTangentAt(0,!0)));Math.max(f.getDistance(a.point2),f.getDistance(u.point1))<Math.abs(i)*o&&n.push(new w.Segment(f));break;case"round":var l=function(n,t,e,r){var i=n.point.subtract(e).add(t.point.subtract(e)).normalize(Math.abs(r)).add(e),o=new w.Path.Arc({from:n.point,to:t.point,through:i,insert:!1});return n.handleOut=o.firstSegment.handleOut,t.handleIn=o.lastSegment.handleIn,3===o.segments.length?o.segments[1]:null}(n[1],t[0],e.point,i);l&&n.push(l)}else t[0].handleIn=n[1].handleIn,n.pop();else{var h=a.divideAt(c[0]);if(h){var d=h.segment1,p=u.divideAt(u.getIntersections(a)[0]);d.handleOut=p?p.segment1.handleOut:t[0].handleOut,n.pop(),t[0]=d}else t[0].handleIn=n[1].handleIn,n.pop()}}function r(n){return 1===n.children.length&&(n=n.children[0]).remove(),n}function h(n,t){if(void 0===t&&(t=.01),n.closed){var e=Math.abs(n.area*t);if(n.clockwise||n.reverse(),(n=n.unite(n,{insert:!1}))instanceof w.CompoundPath&&(n.children.filter(function(n){return Math.abs(n.area)<e}).forEach(function(n){return n.remove()}),1===n.children.length))return r(n)}return n}function e(n,t){var e=(n.segments[0].location.offset+n.segments[Math.max(1,Math.floor(n.segments.length/2))].location.offset)/3;return t.getNearestLocation(n.getPointAt(e)).offset<t.getNearestLocation(n.getPointAt(2*e)).offset}function d(t){var n=t.unite(t,{insert:!1});return n instanceof w.CompoundPath?(n.children.filter(function(n){return!(1<n.segments.length)||!e(n,t)}).forEach(function(n){return n.remove()}),r(n)):t}function p(n,t){(function(n){return n instanceof w.CompoundPath?y.Flat(n.children.map(function(n){return n.segments})):n.segments})(n).slice().forEach(function(n){t.contains(n.point)||n.remove()})}function m(n,t,e,r){var i,o;o=(i=function(n,t){var e=n.clone({insert:!1});return e.reduce(),n.clockwise||(e.reverse(),t=-t),[e,t]}(n,t))[0],t=i[1];var a=o.curves.slice(),u=y.Divide(y.Flat(a.map(function(n){return function n(t,e){var r=new w.Curve(t.segment1.handleOut.add(t.segment1.point),new w.Point(0,0),new w.Point(0,0),t.segment2.handleIn.add(t.segment2.point)).getNormalAt(.5,!0).multiply(e),i=f(t.segment1,t,r,e),o=f(t.segment2,t,r,e),a=new w.Curve(i,o);if(0===a.getIntersections(a).length){var u=Math.min(Math.abs(e)/10,1),c=a.getPointAt(.5,!0).getDistance(t.getPointAt(.5,!0));if(Math.abs(c-Math.abs(e))>u){var s=t.divideAtTime(.5);if(null!=s)return n(t,e).concat(n(s,e))}}return[i,o]}(n,t)})),2),c=y.Flat(function(n,t,e,r,i){for(var o=e.segments,a=n[0].slice(),u=0;u<n.length-1;++u)l(n[u],n[u+1],o[u+1],t,r,i);return e.closed&&(l(n[n.length-1],a,o[0],t,r,i),n[0][0]=a[0]),n}(u,e,o,t,r)),s=d(new w.Path({segments:c,insert:!1,closed:n.closed}));return s.reduce(),o.closed&&(o.clockwise&&t<0||!o.clockwise&&0<t)&&p(s,n),o.clockwise!==n.clockwise&&s.reverse(),h(s)}function g(n,t,e){var r=n.point.add(t.point).divide(2),i=t.point.subtract(n.point).rotate(-90).normalize(e),o=r.add(i);return new w.Path.Arc({from:n.point,to:t.point,through:o,insert:!1}).segments}n.ConnectAdjacentBezier=l,n.Normalize=h,n.IsSameDirection=e,n.RemoveIntersection=d,n.OffsetSimpleShape=m,n.OffsetSimpleStroke=function(n,t,e,r,i){var o=m(n,t=n.clockwise?t:-t,e,i),a=m(n,-t,e,i);if(n.closed)return o.subtract(a,{insert:!1});var u=a,c=new Array;a instanceof w.CompoundPath&&((c=a.children.filter(function(n){return n.closed})).forEach(function(n){return n.remove()}),u=a.children[0]),u.reverse();var s=function(n,t,e,r){if(n instanceof w.CompoundPath){var i=n.children.map(function(n){return{c:n,a:Math.abs(n.area)}});n=(i=i.sort(function(n,t){return t.a-n.a}))[0].c}var o=n.segments.slice(),a=t.segments.slice();switch(r){case"round":var u=g(a[a.length-1],o[0],e),c=g(o[o.length-1],a[0],e),s=new w.Path({segments:u.concat(o,c,a),closed:!0,insert:!1});return s.reduce(),s;default:return new w.Path({segments:o.concat(a),closed:!0,insert:!1})}}(o,u,t,r);if(0<c.length)for(var f=0,l=c;f<l.length;f++){var h=l[f];s=s.subtract(h,{insert:!1})}return s}}(u||(u={})),(n=w).Path.prototype.offset=function(n,t){return e(this,n,t)},n.Path.prototype.offsetStroke=function(n,t){return r(this,n,t)},n.CompoundPath.prototype.offset=function(n,t){return e(this,n,t)},n.CompoundPath.prototype.offsetStroke=function(n,t){return r(this,n,t)}}(paper);
diff --git a/node_modules/paperjs-offset/dist/types/offset_core.d.ts b/node_modules/paperjs-offset/dist/types/Offset.d.ts
similarity index 65%
rename from node_modules/paperjs-offset/dist/types/offset_core.d.ts
rename to node_modules/paperjs-offset/dist/types/Offset.d.ts
index 6e8e7d1..2125399 100644
--- a/node_modules/paperjs-offset/dist/types/offset_core.d.ts
+++ b/node_modules/paperjs-offset/dist/types/Offset.d.ts
@@ -1,5 +1,6 @@
+import paper from 'paper';
 export declare type StrokeJoinType = 'miter' | 'bevel' | 'round';
 export declare type StrokeCapType = 'round' | 'butt';
 export declare type PathType = paper.Path | paper.CompoundPath;
-export declare function offsetPath(path: PathType, offset: number, join: StrokeJoinType, limit: number): PathType;
-export declare function offsetStroke(path: PathType, offset: number, join: StrokeJoinType, cap: StrokeCapType, limit: number): PathType;
+export declare function OffsetPath(path: PathType, offset: number, join: StrokeJoinType, limit: number): PathType;
+export declare function OffsetStroke(path: PathType, offset: number, join: StrokeJoinType, cap: StrokeCapType, limit: number): PathType;
diff --git a/node_modules/paperjs-offset/dist/types/bundle.d.ts b/node_modules/paperjs-offset/dist/types/bundle.d.ts
index a4b24d8..509db18 100644
--- a/node_modules/paperjs-offset/dist/types/bundle.d.ts
+++ b/node_modules/paperjs-offset/dist/types/bundle.d.ts
@@ -1,9 +1 @@
-import { PaperOffset } from './index';
-declare global {
-    interface Window {
-        PaperOffset: {
-            offset: typeof PaperOffset.offset;
-            offsetStroke: typeof PaperOffset.offsetStroke;
-        };
-    }
-}
+export {};
diff --git a/node_modules/paperjs-offset/dist/types/index.d.ts b/node_modules/paperjs-offset/dist/types/index.d.ts
deleted file mode 100644
index abbcceb..0000000
--- a/node_modules/paperjs-offset/dist/types/index.d.ts
+++ /dev/null
@@ -1,15 +0,0 @@
-import { StrokeJoinType, PathType, StrokeCapType } from './offset_core';
-export interface OffsetOptions {
-    join?: StrokeJoinType;
-    cap?: StrokeCapType;
-    limit?: number;
-    insert?: boolean;
-}
-export declare class PaperOffset {
-    static offset(path: PathType, offset: number, options?: OffsetOptions): PathType;
-    static offsetStroke(path: PathType, offset: number, options?: OffsetOptions): PathType;
-}
-/**
- * @deprecated EXTEND existing paper module is not recommend anymore
- */
-export default function ExtendPaperJs(paperNs: any): void;
diff --git a/node_modules/paperjs-offset/src/Offset.ts b/node_modules/paperjs-offset/src/Offset.ts
new file mode 100644
index 0000000..472c2c5
--- /dev/null
+++ b/node_modules/paperjs-offset/src/Offset.ts
@@ -0,0 +1,354 @@
+import paper, { Point } from 'paper'
+import { Arrayex } from 'arrayex'
+
+type HandleType = 'handleIn' | 'handleOut'
+export type StrokeJoinType = 'miter' | 'bevel' | 'round'
+export type StrokeCapType = 'round' | 'butt'
+export type PathType = paper.Path | paper.CompoundPath
+
+namespace Offsets {
+  /**
+   * Offset the start/terminal segment of a bezier curve
+   * @param segment segment to offset
+   * @param curve curve to offset
+   * @param handleNormal the normal of the the line formed of two handles
+   * @param offset offset value
+   */
+  function OffsetSegment(segment: paper.Segment, curve: paper.Curve, handleNormal: paper.Point, offset: number) {
+    let isFirst = segment.curve === curve
+    // get offset vector
+    let offsetVector = (curve.getNormalAt(isFirst ? 0 : 1, true)).multiply(offset)
+    // get offset point
+    let point = segment.point.add(offsetVector)
+    let newSegment = new paper.Segment(point)
+    // handleOut for start segment & handleIn for terminal segment
+    let handle = (isFirst ? 'handleOut' : 'handleIn') as HandleType
+    newSegment[handle] = segment[handle]!.add(handleNormal.subtract(offsetVector).divide(2))
+    return newSegment
+  }
+
+  /**
+   * Adaptive offset a curve by repeatly apply the approximation proposed by Tiller and Hanson.
+   * @param curve curve to offset
+   * @param offset offset value
+   */
+  function AdaptiveOffsetCurve(curve: paper.Curve, offset: number): Array<paper.Segment> {
+    offset
+    let hNormal = (new paper.Curve(curve.segment1.handleOut!.add(curve.segment1.point), new paper.Point(0, 0), new paper.Point(0, 0), curve.segment2.handleIn!.add(curve.segment2.point))).getNormalAt(0.5, true).multiply(offset)
+    let segment1 = OffsetSegment(curve.segment1, curve, hNormal, offset)
+    let segment2 = OffsetSegment(curve.segment2, curve, hNormal, offset)
+    // divide && re-offset
+    let offsetCurve = new paper.Curve(segment1, segment2)
+    // if the offset curve is not self intersected, divide it
+    if (offsetCurve.getIntersections(offsetCurve).length === 0) {
+      let threshold = Math.min(Math.abs(offset) / 10, 1)
+      let midOffset = offsetCurve.getPointAt(0.5, true).getDistance(curve.getPointAt(0.5, true))
+      if (Math.abs(midOffset - Math.abs(offset)) > threshold) {
+        let subCurve = curve.divideAtTime(0.5)
+        if (subCurve != null) {
+          return [...AdaptiveOffsetCurve(curve, offset), ...AdaptiveOffsetCurve(subCurve, offset)]
+        }
+      }
+    }
+    return [segment1, segment2]
+  }
+
+  /**
+   * Create a round join segment between two adjacent segments.
+   */
+  function MakeRoundJoin(segment1: paper.Segment, segment2: paper.Segment, originPoint: paper.Point, radius: number) {
+    let through = segment1.point.subtract(originPoint).add(segment2.point.subtract(originPoint)).normalize(Math.abs(radius)).add(originPoint)
+    let arc = new paper.Path.Arc({ from: segment1.point, to: segment2.point, through, insert: false })
+    segment1.handleOut = arc.firstSegment.handleOut
+    segment2.handleIn = arc.lastSegment.handleIn
+    return arc.segments.length === 3 ? arc.segments[1] : null
+  }
+
+  function Det(p1: paper.Point, p2: paper.Point) {
+    return p1.x * p2.y - p1.y * p2.x
+  }
+
+  /**
+   * Get the intersection point of two point
+   */
+  function Intersection(p1: paper.Point, p2: paper.Point, p3: paper.Point, p4: paper.Point) {
+    let l1 = p1.subtract(p2)
+    let l2 = p3.subtract(p4)
+    let dl1 = Det(p1, p2)
+    let dl2 = Det(p3, p4)
+    return new paper.Point(dl1 * l2.x - l1.x * dl2, dl1 * l2.y - l1.y * dl2).divide(Det(l1, l2))
+  }
+
+  /**
+   * Connect two adjacent bezier curve, each curve is represented by two segments, create different types of joins or simply removal redundant segment.
+   */
+  export function ConnectAdjacentBezier(segments1: Array<paper.Segment>, segments2: Array<paper.Segment>, origin: paper.Segment, join: StrokeJoinType, offset: number, limit: number) {
+    let curve1 = new paper.Curve(segments1[0], segments1[1])
+    let curve2 = new paper.Curve(segments2[0], segments2[1])
+    let intersection = curve1.getIntersections(curve2)
+    let distance = segments1[1].point.getDistance(segments2[0].point)
+    if (origin.isSmooth()) {
+      segments2[0].handleOut = segments2[0].handleOut!.project(origin.handleOut!)
+      segments2[0].handleIn = segments1[1].handleIn!.project(origin.handleIn!)
+      segments2[0].point = segments1[1].point.add(segments2[0].point).divide(2)
+      segments1.pop()
+    } else {
+      if (intersection.length === 0) {
+        if (distance > Math.abs(offset) * 0.1) {
+          // connect
+          switch (join) {
+            case 'miter':
+              let join = Intersection(curve1.point2, curve1.point2.add(curve1.getTangentAt(1, true)), curve2.point1, curve2.point1.add(curve2.getTangentAt(0, true)))
+              // prevent sharp angle
+              let joinOffset = Math.max(join.getDistance(curve1.point2), join.getDistance(curve2.point1))
+              if (joinOffset < Math.abs(offset) * limit) {
+                segments1.push(new paper.Segment(join))
+              }
+              break
+            case 'round':
+              let mid = MakeRoundJoin(segments1[1], segments2[0], origin.point, offset)
+              if (mid) {
+                segments1.push(mid)
+              }
+              break
+            default: break
+          }
+        } else {
+          segments2[0].handleIn = segments1[1].handleIn
+          segments1.pop()
+        }
+      } else {
+        let second1 = curve1.divideAt(intersection[0])
+        if (second1) {
+          let join = second1.segment1
+          let second2 = curve2.divideAt(curve2.getIntersections(curve1)[0])
+          join.handleOut = second2 ? second2.segment1.handleOut : segments2[0].handleOut
+          segments1.pop()
+          segments2[0] = join
+        } else {
+          segments2[0].handleIn = segments1[1].handleIn
+          segments1.pop()
+        }
+      }
+    }
+  }
+
+  /**
+   * Connect all the segments together.
+   */
+  function ConnectBeziers(rawSegments: Array<Array<paper.Segment>>, join: StrokeJoinType, source: paper.Path, offset: number, limit: number) {
+    let originSegments = source.segments
+    let first = rawSegments[0].slice()
+    for (let i = 0; i < rawSegments.length - 1; ++i) {
+      ConnectAdjacentBezier(rawSegments[i], rawSegments[i + 1], originSegments[i + 1], join, offset, limit)
+    }
+    if (source.closed) {
+      ConnectAdjacentBezier(rawSegments[rawSegments.length - 1], first, originSegments[0], join, offset, limit)
+      rawSegments[0][0] = first[0]
+    }
+    return rawSegments
+  }
+
+  function Decompound(path: PathType) {
+    if (path.children.length === 1) {
+      path = path.children[0] as paper.Path
+      path.remove() // remove from parent, this is critical, or the style attributes will be ignored
+    }
+    return path
+  }
+
+  /** Normalize a path, always clockwise, non-self-intersection, ignore really small components, and no one-component compound path. */
+  export function Normalize(path: PathType, areaThreshold = 0.01) {
+    if (path.closed) {
+      let ignoreArea = Math.abs(path.area * areaThreshold)
+      if (!path.clockwise) {
+        path.reverse()
+      }
+      path = path.unite(path, { insert: false }) as PathType
+      if (path instanceof paper.CompoundPath) {
+        path.children.filter(c => Math.abs((c as PathType).area) < ignoreArea).forEach(c => c.remove())
+        if (path.children.length === 1) {
+          return Decompound(path)
+        }
+      }
+    }
+    return path
+  }
+
+  export function IsSameDirection(partialPath: paper.Path, fullPath: PathType) {
+    let offset1 = partialPath.segments[0].location.offset
+    let offset2 = partialPath.segments[Math.max(1, Math.floor(partialPath.segments.length / 2))].location.offset
+    let sampleOffset = (offset1 + offset2) / 3
+    let originOffset1 = fullPath.getNearestLocation(partialPath.getPointAt(sampleOffset)).offset
+    let originOffset2 = fullPath.getNearestLocation(partialPath.getPointAt(2 * sampleOffset)).offset
+    return originOffset1 < originOffset2
+  }
+
+  /** Remove self intersection when offset is negative by point direction dectection. */
+  export function RemoveIntersection(path: PathType) {
+    let newPath = path.unite(path, { insert: false }) as PathType
+    if (newPath instanceof paper.CompoundPath) {
+      (newPath.children as Array<paper.Path>).filter(c => {
+        if (c.segments.length > 1) {
+          return !IsSameDirection(c, path)
+        } else {
+          return true
+        }
+      }).forEach(c => c.remove())
+      return Decompound(newPath)
+    }
+    return path
+  }
+
+  function Segments(path: PathType) {
+    if (path instanceof paper.CompoundPath) {
+      return Arrayex.Flat<paper.Segment>(path.children.map(c => (c as paper.Path).segments))
+    } else {
+      return (path as paper.Path).segments
+    }
+  }
+
+  /**
+   * Remove impossible segments in negative offset condition.
+   */
+  function RemoveOutsiders(offsetPath: PathType, path: PathType) {
+    let segments = Segments(offsetPath).slice()
+    segments.forEach(segment => {
+      if (!path.contains(segment.point)) {
+        segment.remove()
+      }
+    })
+  }
+
+  function PreparePath(path: paper.Path, offset: number): [paper.Path, number] {
+    let source = path.clone({ insert: false }) as paper.Path
+    source.reduce()
+    if (!path.clockwise) {
+      source.reverse()
+      offset = -offset
+    }
+    return [source, offset]
+  }
+
+  export function OffsetSimpleShape(path: paper.Path, offset: number, join: StrokeJoinType, limit: number): PathType {
+    let source: paper.Path
+    [source, offset] = PreparePath(path, offset)
+    let curves = source.curves.slice()
+    let raws = Arrayex.Divide(Arrayex.Flat<paper.Segment>(curves.map(curve => AdaptiveOffsetCurve(curve, offset))), 2)
+    let segments = Arrayex.Flat(ConnectBeziers(raws, join, source, offset, limit))
+    let offsetPath = RemoveIntersection(new paper.Path({ segments, insert: false, closed: path.closed }))
+    offsetPath.reduce()
+    if (source.closed && ((source.clockwise && offset < 0) || (!source.clockwise && offset > 0))) {
+      RemoveOutsiders(offsetPath, path)
+    }
+    // recovery path
+    if (source.clockwise !== path.clockwise) {
+      offsetPath.reverse()
+    }
+    return Normalize(offsetPath)
+  }
+
+  function MakeRoundCap(from: paper.Segment, to: paper.Segment, offset: number) {
+    let origin = from.point.add(to.point).divide(2)
+    let normal = to.point.subtract(from.point).rotate(-90).normalize(offset)
+    let through = origin.add(normal)
+    let arc = new paper.Path.Arc({ from: from.point, to: to.point, through, insert: false })
+    return arc.segments
+  }
+
+  function ConnectSide(outer: PathType, inner: paper.Path, offset: number, cap: StrokeCapType): paper.Path {
+    if (outer instanceof paper.CompoundPath) {
+      let cs = outer.children.map(c => ({ c, a: Math.abs((c as paper.Path).area) }))
+      cs = cs.sort((c1, c2) => c2.a - c1.a)
+      outer = cs[0].c as paper.Path
+    }
+    let oSegments = (outer as paper.Path).segments.slice()
+    let iSegments = inner.segments.slice()
+    switch (cap) {
+      case 'round':
+        let heads = MakeRoundCap(iSegments[iSegments.length - 1], oSegments[0], offset)
+        let tails = MakeRoundCap(oSegments[oSegments.length - 1], iSegments[0], offset)
+        let result = new paper.Path({ segments: [...heads, ...oSegments, ...tails, ...iSegments], closed: true, insert: false })
+        result.reduce()
+        return result
+      default: return new paper.Path({ segments: [...oSegments, ...iSegments], closed: true, insert: false })
+    }
+  }
+
+  export function OffsetSimpleStroke(path: paper.Path, offset: number, join: StrokeJoinType, cap: StrokeCapType, limit: number): PathType {
+    offset = path.clockwise ? offset : -offset
+    let positiveOffset = OffsetSimpleShape(path, offset, join, limit)
+    let negativeOffset = OffsetSimpleShape(path, -offset, join, limit)
+    if (path.closed) {
+      return positiveOffset.subtract(negativeOffset, { insert: false }) as PathType
+    } else {
+      let inner = negativeOffset
+      let holes = new Array<paper.Path>()
+      if (negativeOffset instanceof paper.CompoundPath) {
+        holes = negativeOffset.children.filter(c => (c as paper.Path).closed) as Array<paper.Path>
+        holes.forEach(h => h.remove())
+        inner = negativeOffset.children[0] as paper.Path
+      }
+      inner.reverse()
+      let final = ConnectSide(positiveOffset, inner as paper.Path, offset, cap) as PathType
+      if (holes.length > 0) {
+        for(let hole of holes) {
+          final = final.subtract(hole, { insert: false }) as PathType
+        }
+      }
+      return final
+    }
+  }
+}
+
+export function OffsetPath(path: PathType, offset: number, join: StrokeJoinType, limit: number) {
+  let nonSIPath = path.unite(path, { insert: false }) as PathType
+  let result = nonSIPath
+  if (nonSIPath instanceof paper.Path) {
+    result = Offsets.OffsetSimpleShape(nonSIPath, offset, join, limit)
+  } else {
+    let children = Arrayex.Flat((nonSIPath.children as Array<paper.Path>).map(c => {
+      if (c.segments.length > 1) {
+        if (!Offsets.IsSameDirection(c, path)) {
+          c.reverse()
+        }
+        let offseted = Offsets.OffsetSimpleShape(c, offset, join, limit)
+        offseted = Offsets.Normalize(offseted)
+        if (offseted.clockwise !== c.clockwise) {
+          offseted.reverse()
+        }
+        if (offseted instanceof paper.CompoundPath) {
+          offseted.applyMatrix = true
+          return offseted.children
+        } else {
+          return offseted
+        }
+      } else {
+        return null
+      }
+    }), false)
+    result = new paper.CompoundPath({ children, insert: false })
+  }
+  result.copyAttributes(nonSIPath, false)
+  result.remove()
+  return result
+}
+
+export function OffsetStroke(path: PathType, offset: number, join: StrokeJoinType, cap: StrokeCapType, limit: number) {
+  let nonSIPath = path.unite(path, { insert: false }) as PathType
+  let result = nonSIPath as PathType
+  if (nonSIPath instanceof paper.Path) {
+    result = Offsets.OffsetSimpleStroke(nonSIPath, offset, join, cap, limit)
+  } else {
+    let children = Arrayex.Flat((nonSIPath.children as Array<paper.Path>).map(c => {
+      return Offsets.OffsetSimpleStroke(c, offset, join, cap, limit)
+    }))
+    result = children.reduce((c1, c2) => c1.unite(c2, { insert: false }) as PathType)
+  }
+  result.strokeWidth = 0
+  result.fillColor = nonSIPath.strokeColor
+  result.shadowBlur = nonSIPath.shadowBlur
+  result.shadowColor = nonSIPath.shadowColor
+  result.shadowOffset = nonSIPath.shadowOffset
+  return result
+}
diff --git a/node_modules/paperjs-offset/src/bundle.ts b/node_modules/paperjs-offset/src/bundle.ts
index 36275da..9f7187a 100644
--- a/node_modules/paperjs-offset/src/bundle.ts
+++ b/node_modules/paperjs-offset/src/bundle.ts
@@ -1,18 +1,4 @@
-import paper from 'paper';
-import ExtendPaperJs, { PaperOffset } from './index';
+import paper from 'paper'
+import ExtendPaperJs from './index'
 
-ExtendPaperJs(paper);
-
-declare global {
-  interface Window {
-    PaperOffset: {
-      offset: typeof PaperOffset.offset;
-      offsetStroke: typeof PaperOffset.offsetStroke;
-    }
-  }
-}
-
-window.PaperOffset = {
-  offset: PaperOffset.offset,
-  offsetStroke: PaperOffset.offsetStroke,
-};
+ExtendPaperJs(paper)
\ No newline at end of file
diff --git a/node_modules/paperjs-offset/src/index.ts b/node_modules/paperjs-offset/src/index.ts
index 8c0bf7d..f5413e4 100644
--- a/node_modules/paperjs-offset/src/index.ts
+++ b/node_modules/paperjs-offset/src/index.ts
@@ -1,56 +1,63 @@
-import paper from 'paper';
-import { StrokeJoinType, PathType, StrokeCapType, offsetPath, offsetStroke } from './offset_core';
+import paper from 'paper'
+import { OffsetPath, StrokeJoinType, PathType, StrokeCapType, OffsetStroke } from './Offset'
 
 export interface OffsetOptions {
-  join?: StrokeJoinType;
-  cap?: StrokeCapType;
-  limit?: number;
-  insert?: boolean;
+  join?: StrokeJoinType,
+  cap?: StrokeCapType,
+  limit?: number,
+  insert?: boolean,
 }
 
-export class PaperOffset {
-  public static offset(path: PathType, offset: number, options?: OffsetOptions): PathType {
-    options = options || {};
-    const newPath = offsetPath(path, offset, options.join || 'miter', options.limit || 10);
-    if (options.insert === undefined) {
-      options.insert = true;
-    }
-    if (options.insert) {
-      (path.parent || paper.project.activeLayer).addChild(newPath);
-    }
-    return newPath;
-  }
-
-  public static offsetStroke(path: PathType, offset: number, options?: OffsetOptions): PathType {
-    options = options || {};
-    const newPath = offsetStroke(path, offset, options.join || 'miter', options.cap || 'butt', options.limit || 10);
-    if (options.insert === undefined) {
-      options.insert = true;
-    }
-    if (options.insert) {
-      (path.parent || paper.project.activeLayer).addChild(newPath);
-    }
-    return newPath;
+declare module 'paper' {
+  interface Path {
+    offset(offset: number, options?: OffsetOptions): PathType
+    offsetStroke(offset: number, options?: OffsetOptions): PathType | paper.Group
+  }
+
+  interface CompoundPath {
+    offset(offset: number, options?: OffsetOptions): PathType
+    offsetStroke(offset: number, options?: OffsetOptions): PathType | paper.Group
   }
 }
 
-/**
- * @deprecated EXTEND existing paper module is not recommend anymore
- */
-export default function ExtendPaperJs(paperNs: any) {
-  paperNs.Path.prototype.offset = function(offset: number, options?: OffsetOptions) {
-    return PaperOffset.offset(this, offset, options);
-  };
-
-  paperNs.Path.prototype.offsetStroke = function(offset: number, options?: OffsetOptions) {
-    return PaperOffset.offsetStroke(this, offset, options);
-  };
-
-  paperNs.CompoundPath.prototype.offset = function(offset: number, options?: OffsetOptions) {
-    return PaperOffset.offset(this, offset, options);
-  };
-
-  paperNs.CompoundPath.prototype.offsetStroke = function(offset: number, options?: OffsetOptions) {
-    return PaperOffset.offsetStroke(this, offset, options);
-  };
+function PrototypedOffset(path: PathType, offset: number, options?: OffsetOptions) {
+  options = options || {}
+  let offsetPath = OffsetPath(path, offset, options.join || 'miter', options.limit || 10)
+  if (options.insert === undefined) {
+    options.insert = true
+  }
+  if (options.insert) {
+    (path.parent || paper.project.activeLayer).addChild(offsetPath)
+  }
+  return offsetPath
+}
+
+function PrototypedOffsetStroke(path: PathType, offset: number, options?: OffsetOptions) {
+  options = options || {}
+  let offsetPath = OffsetStroke(path, offset, options.join || 'miter', options.cap || 'butt', options.limit || 10)
+  if (options.insert === undefined) {
+    options.insert = true
+  }
+  if (options.insert) {
+    (path.parent || paper.project.activeLayer).addChild(offsetPath)
+  }
+  return offsetPath
+}
+
+export default function ExtendPaperJs(paper: any) {
+  paper.Path.prototype.offset = function(offset: number, options?: OffsetOptions) {
+    return PrototypedOffset(this, offset, options)
+  }
+
+  paper.Path.prototype.offsetStroke = function (offset: number, options?: OffsetOptions) {
+    return PrototypedOffsetStroke(this, offset, options)
+  }
+
+  paper.CompoundPath.prototype.offset = function(offset: number, options?: OffsetOptions) {
+    return PrototypedOffset(this, offset, options)
+  }
+
+  paper.CompoundPath.prototype.offsetStroke = function (offset: number, options?: OffsetOptions) {
+    return PrototypedOffsetStroke(this, offset, options)
+  }
 }
diff --git a/node_modules/paperjs-offset/src/offset_core.ts b/node_modules/paperjs-offset/src/offset_core.ts
deleted file mode 100644
index 949f6df..0000000
--- a/node_modules/paperjs-offset/src/offset_core.ts
+++ /dev/null
@@ -1,369 +0,0 @@
-import paper from 'paper';
-
-export type StrokeJoinType = 'miter' | 'bevel' | 'round';
-export type StrokeCapType = 'round' | 'butt';
-export type PathType = paper.Path | paper.CompoundPath;
-
-type HandleType = 'handleIn' | 'handleOut';
-
-/**
- * Offset the start/terminal segment of a bezier curve
- * @param segment segment to offset
- * @param curve curve to offset
- * @param handleNormal the normal of the the line formed of two handles
- * @param offset offset value
- */
-function offsetSegment(segment: paper.Segment, curve: paper.Curve, handleNormal: paper.Point, offset: number) {
-  const isFirst = segment.curve === curve;
-  // get offset vector
-  const offsetVector = (curve.getNormalAtTime(isFirst ? 0 : 1)).multiply(offset);
-  // get offset point
-  const point = segment.point.add(offsetVector);
-  const newSegment = new paper.Segment(point);
-  // handleOut for start segment & handleIn for terminal segment
-  const handle = (isFirst ? 'handleOut' : 'handleIn') as HandleType;
-  newSegment[handle] = segment[handle]!.add(handleNormal.subtract(offsetVector).divide(2));
-  return newSegment;
-}
-
-/**
- * Adaptive offset a curve by repeatly apply the approximation proposed by Tiller and Hanson.
- * @param curve curve to offset
- * @param offset offset value
- */
-function adaptiveOffsetCurve(curve: paper.Curve, offset: number): paper.Segment[] {
-  const hNormal = (new paper.Curve(curve.segment1.handleOut!.add(curve.segment1.point), new paper.Point(0, 0),
-    new paper.Point(0, 0), curve.segment2.handleIn!.add(curve.segment2.point))).getNormalAtTime(0.5).multiply(offset);
-  const segment1 = offsetSegment(curve.segment1, curve, hNormal, offset);
-  const segment2 = offsetSegment(curve.segment2, curve, hNormal, offset);
-  // divide && re-offset
-  const offsetCurve = new paper.Curve(segment1, segment2);
-  // if the offset curve is not self intersected, divide it
-  if (offsetCurve.getIntersections(offsetCurve).length === 0) {
-    const threshold = Math.min(Math.abs(offset) / 10, 1);
-    const midOffset = offsetCurve.getPointAtTime(0.5).getDistance(curve.getPointAtTime(0.5));
-    if (Math.abs(midOffset - Math.abs(offset)) > threshold) {
-      const subCurve = curve.divideAtTime(0.5);
-      if (subCurve != null) {
-        return [...adaptiveOffsetCurve(curve, offset), ...adaptiveOffsetCurve(subCurve, offset)];
-      }
-    }
-  }
-  return [segment1, segment2];
-}
-
-/**
- * Create a round join segment between two adjacent segments.
- */
-function makeRoundJoin(segment1: paper.Segment, segment2: paper.Segment, originPoint: paper.Point, radius: number) {
-  const through = segment1.point.subtract(originPoint).add(segment2.point.subtract(originPoint))
-    .normalize(Math.abs(radius)).add(originPoint);
-  const arc = new paper.Path.Arc({ from: segment1.point, to: segment2.point, through, insert: false });
-  segment1.handleOut = arc.firstSegment.handleOut;
-  segment2.handleIn = arc.lastSegment.handleIn;
-  return arc.segments.length === 3 ? arc.segments[1] : null;
-}
-
-function det(p1: paper.Point, p2: paper.Point) {
-  return p1.x * p2.y - p1.y * p2.x;
-}
-
-/**
- * Get the intersection point of point based lines
- */
-function getPointLineIntersections(p1: paper.Point, p2: paper.Point, p3: paper.Point, p4: paper.Point) {
-  const l1 = p1.subtract(p2);
-  const l2 = p3.subtract(p4);
-  const dl1 = det(p1, p2);
-  const dl2 = det(p3, p4);
-  return new paper.Point(dl1 * l2.x - l1.x * dl2, dl1 * l2.y - l1.y * dl2).divide(det(l1, l2));
-}
-
-/**
- * Connect two adjacent bezier curve, each curve is represented by two segments,
- * create different types of joins or simply removal redundant segment.
- */
-function connectAdjacentBezier(segments1: paper.Segment[], segments2: paper.Segment[], origin: paper.Segment, joinType: StrokeJoinType, offset: number, limit: number) {
-  const curve1 = new paper.Curve(segments1[0], segments1[1]);
-  const curve2 = new paper.Curve(segments2[0], segments2[1]);
-  const intersection = curve1.getIntersections(curve2);
-  const distance = segments1[1].point.getDistance(segments2[0].point);
-  if (origin.isSmooth()) {
-    segments2[0].handleOut = segments2[0].handleOut!.project(origin.handleOut!);
-    segments2[0].handleIn = segments1[1].handleIn!.project(origin.handleIn!);
-    segments2[0].point = segments1[1].point.add(segments2[0].point).divide(2);
-    segments1.pop();
-  } else {
-    if (intersection.length === 0) {
-      if (distance > Math.abs(offset) * 0.1) {
-        // connect
-        switch (joinType) {
-          case 'miter':
-            const join = getPointLineIntersections(curve1.point2, curve1.point2.add(curve1.getTangentAtTime(1)),
-              curve2.point1, curve2.point1.add(curve2.getTangentAtTime(0)));
-            // prevent sharp angle
-            const joinOffset = Math.max(join.getDistance(curve1.point2), join.getDistance(curve2.point1));
-            if (joinOffset < Math.abs(offset) * limit) {
-              segments1.push(new paper.Segment(join));
-            }
-            break;
-          case 'round':
-            const mid = makeRoundJoin(segments1[1], segments2[0], origin.point, offset);
-            if (mid) {
-              segments1.push(mid);
-            }
-            break;
-          default: break;
-        }
-      } else {
-        segments2[0].handleIn = segments1[1].handleIn;
-        segments1.pop();
-      }
-    } else {
-      const second1 = curve1.divideAt(intersection[0]);
-      if (second1) {
-        const join = second1.segment1;
-        const second2 = curve2.divideAt(curve2.getIntersections(curve1)[0]);
-        join.handleOut = second2 ? second2.segment1.handleOut : segments2[0].handleOut;
-        segments1.pop();
-        segments2[0] = join;
-      } else {
-        segments2[0].handleIn = segments1[1].handleIn;
-        segments1.pop();
-      }
-    }
-  }
-}
-
-/**
- * Connect all the segments together.
- */
-function connectBeziers(rawSegments: paper.Segment[][], join: StrokeJoinType, source: paper.Path, offset: number, limit: number) {
-  const originSegments = source.segments;
-  const first = rawSegments[0].slice();
-  for (let i = 0; i < rawSegments.length - 1; ++i) {
-    connectAdjacentBezier(rawSegments[i], rawSegments[i + 1], originSegments[i + 1], join, offset, limit);
-  }
-  if (source.closed) {
-    connectAdjacentBezier(rawSegments[rawSegments.length - 1], first, originSegments[0], join, offset, limit);
-    rawSegments[0][0] = first[0];
-  }
-  return rawSegments;
-}
-
-function reduceSingleChildCompoundPath(path: PathType) {
-  if (path.children.length === 1) {
-    path = path.children[0] as paper.Path;
-    path.remove(); // remove from parent, this is critical, or the style attributes will be ignored
-  }
-  return path;
-}
-
-/** Normalize a path, always clockwise, non-self-intersection, ignore really small components, and no one-component compound path. */
-function normalize(path: PathType, areaThreshold = 0.01) {
-  if (path.closed) {
-    const ignoreArea = Math.abs(path.area * areaThreshold);
-    if (!path.clockwise) {
-      path.reverse();
-    }
-    path = path.unite(path, { insert: false }) as PathType;
-    if (path instanceof paper.CompoundPath) {
-      path.children.filter((c) => Math.abs((c as PathType).area) < ignoreArea).forEach((c) => c.remove());
-      if (path.children.length === 1) {
-        return reduceSingleChildCompoundPath(path);
-      }
-    }
-  }
-  return path;
-}
-
-function isSameDirection(partialPath: paper.Path, fullPath: PathType) {
-  const offset1 = partialPath.segments[0].location.offset;
-  const offset2 = partialPath.segments[Math.max(1, Math.floor(partialPath.segments.length / 2))].location.offset;
-  const sampleOffset = (offset1 + offset2) / 3;
-  const originOffset1 = fullPath.getNearestLocation(partialPath.getPointAt(sampleOffset)).offset;
-  const originOffset2 = fullPath.getNearestLocation(partialPath.getPointAt(2 * sampleOffset)).offset;
-  return originOffset1 < originOffset2;
-}
-
-/** Remove self intersection when offset is negative by point direction dectection. */
-function removeIntersection(path: PathType) {
-  if (path.closed) {
-    const newPath = path.unite(path, { insert: false }) as PathType;
-    if (newPath instanceof paper.CompoundPath) {
-      (newPath.children as paper.Path[]).filter((c) => {
-        if (c.segments.length > 1) {
-          return !isSameDirection(c, path);
-        } else {
-          return true;
-        }
-      }).forEach((c) => c.remove());
-      return reduceSingleChildCompoundPath(newPath);
-    }
-  }
-  return path;
-}
-
-function getSegments(path: PathType) {
-  if (path instanceof paper.CompoundPath) {
-    return path.children.map((c) => (c as paper.Path).segments).flat();
-  } else {
-    return (path as paper.Path).segments;
-  }
-}
-
-/**
- * Remove impossible segments in negative offset condition.
- */
-function removeOutsiders(newPath: PathType, path: PathType) {
-  const segments = getSegments(newPath).slice();
-  segments.forEach((segment) => {
-    if (!path.contains(segment.point)) {
-      segment.remove();
-    }
-  });
-}
-
-function preparePath(path: paper.Path, offset: number): [paper.Path, number] {
-  const source = path.clone({ insert: false }) as paper.Path;
-  source.reduce({});
-  if (!path.clockwise) {
-    source.reverse();
-    offset = -offset;
-  }
-  return [source, offset];
-}
-
-function offsetSimpleShape(path: paper.Path, offset: number, join: StrokeJoinType, limit: number): PathType {
-  let source: paper.Path;
-  [source, offset] = preparePath(path, offset);
-  const curves = source.curves.slice();
-  const offsetCurves = curves.map((curve) => adaptiveOffsetCurve(curve, offset)).flat();
-  const raws: paper.Segment[][] = [];
-  for (let i = 0; i < offsetCurves.length; i += 2) {
-    raws.push(offsetCurves.slice(i, i + 2));
-  }
-  const segments = connectBeziers(raws, join, source, offset, limit).flat();
-  const newPath = removeIntersection(new paper.Path({ segments, insert: false, closed: path.closed }));
-  newPath.reduce({});
-  if (source.closed && ((source.clockwise && offset < 0) || (!source.clockwise && offset > 0))) {
-    removeOutsiders(newPath, path);
-  }
-  // recovery path
-  if (source.clockwise !== path.clockwise) {
-    newPath.reverse();
-  }
-  return normalize(newPath);
-}
-
-function makeRoundCap(from: paper.Segment, to: paper.Segment, offset: number) {
-  const origin = from.point.add(to.point).divide(2);
-  const normal = to.point.subtract(from.point).rotate(-90, new paper.Point(0, 0)).normalize(offset);
-  const through = origin.add(normal);
-  const arc = new paper.Path.Arc({ from: from.point, to: to.point, through, insert: false });
-  return arc.segments;
-}
-
-function connectSide(outer: PathType, inner: paper.Path, offset: number, cap: StrokeCapType): paper.Path {
-  if (outer instanceof paper.CompoundPath) {
-    let cs = outer.children.map((c) => ({ c, a: Math.abs((c as paper.Path).area) }));
-    cs = cs.sort((c1, c2) => c2.a - c1.a);
-    outer = cs[0].c as paper.Path;
-  }
-  const oSegments = (outer as paper.Path).segments.slice();
-  const iSegments = inner.segments.slice();
-  switch (cap) {
-    case 'round':
-      const heads = makeRoundCap(iSegments[iSegments.length - 1], oSegments[0], offset);
-      const tails = makeRoundCap(oSegments[oSegments.length - 1], iSegments[0], offset);
-      const result = new paper.Path({ segments: [...heads, ...oSegments, ...tails, ...iSegments], closed: true, insert: false });
-      result.reduce({});
-      return result;
-    default: return new paper.Path({ segments: [...oSegments, ...iSegments], closed: true, insert: false });
-  }
-}
-
-function offsetSimpleStroke(path: paper.Path, offset: number, join: StrokeJoinType, cap: StrokeCapType, limit: number): PathType {
-  offset = path.clockwise ? offset : -offset;
-  const positiveOffset = offsetSimpleShape(path, offset, join, limit);
-  const negativeOffset = offsetSimpleShape(path, -offset, join, limit);
-  if (path.closed) {
-    return positiveOffset.subtract(negativeOffset, { insert: false }) as PathType;
-  } else {
-    let inner = negativeOffset;
-    let holes = new Array<paper.Path>();
-    if (negativeOffset instanceof paper.CompoundPath) {
-      holes = negativeOffset.children.filter((c) => (c as paper.Path).closed) as paper.Path[];
-      holes.forEach((h) => h.remove());
-      inner = negativeOffset.children[0] as paper.Path;
-    }
-    inner.reverse();
-    let final = connectSide(positiveOffset, inner as paper.Path, offset, cap) as PathType;
-    if (holes.length > 0) {
-      for (const hole of holes) {
-        final = final.subtract(hole, { insert: false }) as PathType;
-      }
-    }
-    return final;
-  }
-}
-
-function getNonSelfItersectionPath(path: PathType) {
-  if (path.closed) {
-    return path.unite(path, { insert: false }) as PathType;
-  }
-  return path;
-}
-
-export function offsetPath(path: PathType, offset: number, join: StrokeJoinType, limit: number): PathType {
-  const nonSIPath = getNonSelfItersectionPath(path);
-  let result = nonSIPath;
-  if (nonSIPath instanceof paper.Path) {
-    result = offsetSimpleShape(nonSIPath, offset, join, limit);
-  } else {
-    const offsetParts = (nonSIPath.children as paper.Path[]).map((c) => {
-      if (c.segments.length > 1) {
-        if (!isSameDirection(c, path)) {
-          c.reverse();
-        }
-        let offseted = offsetSimpleShape(c, offset, join, limit);
-        offseted = normalize(offseted);
-        if (offseted.clockwise !== c.clockwise) {
-          offseted.reverse();
-        }
-        if (offseted instanceof paper.CompoundPath) {
-          offseted.applyMatrix = true;
-          return offseted.children;
-        } else {
-          return offseted;
-        }
-      } else {
-        return null;
-      }
-    });
-    const children = offsetParts.flat().filter((c) => !!c) as paper.Item[];
-    result = new paper.CompoundPath({ children, insert: false });
-  }
-  result.copyAttributes(nonSIPath, false);
-  result.remove();
-  return result;
-}
-
-export function offsetStroke(path: PathType, offset: number, join: StrokeJoinType, cap: StrokeCapType, limit: number): PathType {
-  const nonSIPath = getNonSelfItersectionPath(path);
-  let result = nonSIPath;
-  if (nonSIPath instanceof paper.Path) {
-    result = offsetSimpleStroke(nonSIPath, offset, join, cap, limit);
-  } else {
-    const children = (nonSIPath.children as paper.Path[]).flatMap((c) => {
-      return offsetSimpleStroke(c, offset, join, cap, limit);
-    });
-    result = children.reduce((c1, c2) => c1.unite(c2, { insert: false }) as PathType);
-  }
-  result.strokeWidth = 0;
-  result.fillColor = nonSIPath.strokeColor;
-  result.shadowBlur = nonSIPath.shadowBlur;
-  result.shadowColor = nonSIPath.shadowColor;
-  result.shadowOffset = nonSIPath.shadowOffset;
-  return result;
-}
diff --git a/node_modules/paperjs-offset/tsconfig.json b/node_modules/paperjs-offset/tsconfig.json
index 7a9ef7a..35d1056 100644
--- a/node_modules/paperjs-offset/tsconfig.json
+++ b/node_modules/paperjs-offset/tsconfig.json
@@ -3,7 +3,7 @@
     "moduleResolution": "node",
     "target": "es5",
     "module":"es2015",
-    "lib": ["es2019", "dom"],
+    "lib": ["es2015", "es2016", "es2017", "dom"],
     "strict": true,
     "sourceMap": true,
     "declaration": true,
diff --git a/node_modules/paperjs-offset/tslint.json b/node_modules/paperjs-offset/tslint.json
index bffe99b..1b2a2c0 100644
--- a/node_modules/paperjs-offset/tslint.json
+++ b/node_modules/paperjs-offset/tslint.json
@@ -10,8 +10,25 @@
   },
   "rules": {
     "quotemark": [true, "single"],
+    "indent": [true, "spaces", 2],
+    "semicolon": [true, "never"],
     "interface-name": false,
     "ordered-imports": false,
-    "max-line-length": [true, 180]
+    "object-literal-sort-keys": false,
+    "no-consecutive-blank-lines": false,
+    "prefer-const": false,
+    "no-console": false,
+    "no-namespace": false,
+    "arrow-parens": false,
+    "array-type": [true, "generic"],
+    "variable-name": [true, "check-format", "allow-leading-underscore", "allow-pascal-case"],
+    "max-line-length": [true, 280],
+    "member-access": [true, "no-public"],
+    "no-empty": [true, "allow-empty-catch", "allow-empty-functions"],
+    "no-shadowed-variable": false,
+    "interface-over-type-literal": false,
+    "member-ordering": false,
+    "max-classes-per-file": false,
+    "no-bitwise": false
   }
 }
